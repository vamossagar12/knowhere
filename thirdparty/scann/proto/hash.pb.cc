// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scann/proto/hash.proto

#include "scann/proto/hash.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_scann_2fproto_2fhash_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_AsymmetricHasherConfig_scann_2fproto_2fhash_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_scann_2fproto_2fhash_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AsymmetricHasherConfig_FixedPointLUTConversionOptions_scann_2fproto_2fhash_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_scann_2fproto_2fhash_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BitSamplingHasherConfig_scann_2fproto_2fhash_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_scann_2fproto_2fhash_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BncHasherConfig_scann_2fproto_2fhash_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_scann_2fproto_2fdistance_5fmeasure_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_DistanceMeasureConfig_scann_2fproto_2fdistance_5fmeasure_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_scann_2fproto_2fhash_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MinHasherConfig_scann_2fproto_2fhash_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_scann_2fproto_2fhash_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PcaHasherConfig_scann_2fproto_2fhash_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_scann_2fproto_2fprojection_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_ProjectionConfig_scann_2fproto_2fprojection_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_scann_2fproto_2fhash_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StackedQuantizersConfig_scann_2fproto_2fhash_2eproto;
namespace research_scann {
class HashConfigDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<HashConfig> _instance;
} _HashConfig_default_instance_;
class AsymmetricHasherConfig_FixedPointLUTConversionOptionsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AsymmetricHasherConfig_FixedPointLUTConversionOptions> _instance;
} _AsymmetricHasherConfig_FixedPointLUTConversionOptions_default_instance_;
class AsymmetricHasherConfigDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AsymmetricHasherConfig> _instance;
  float sampling_fraction_;
  ::PROTOBUF_NAMESPACE_ID::int32 expected_sample_size_;
} _AsymmetricHasherConfig_default_instance_;
class MinHasherConfigDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MinHasherConfig> _instance;
} _MinHasherConfig_default_instance_;
class BitSamplingHasherConfigDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BitSamplingHasherConfig> _instance;
} _BitSamplingHasherConfig_default_instance_;
class PcaHasherConfigDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PcaHasherConfig> _instance;
} _PcaHasherConfig_default_instance_;
class BncHasherConfigDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BncHasherConfig> _instance;
} _BncHasherConfig_default_instance_;
class StackedQuantizersConfigDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StackedQuantizersConfig> _instance;
} _StackedQuantizersConfig_default_instance_;
}  // namespace research_scann
static void InitDefaultsscc_info_AsymmetricHasherConfig_scann_2fproto_2fhash_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::research_scann::_AsymmetricHasherConfig_default_instance_;
    new (ptr) ::research_scann::AsymmetricHasherConfig();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::research_scann::AsymmetricHasherConfig::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_AsymmetricHasherConfig_scann_2fproto_2fhash_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 4, InitDefaultsscc_info_AsymmetricHasherConfig_scann_2fproto_2fhash_2eproto}, {
      &scc_info_ProjectionConfig_scann_2fproto_2fprojection_2eproto.base,
      &scc_info_AsymmetricHasherConfig_FixedPointLUTConversionOptions_scann_2fproto_2fhash_2eproto.base,
      &scc_info_DistanceMeasureConfig_scann_2fproto_2fdistance_5fmeasure_2eproto.base,
      &scc_info_StackedQuantizersConfig_scann_2fproto_2fhash_2eproto.base,}};

static void InitDefaultsscc_info_AsymmetricHasherConfig_FixedPointLUTConversionOptions_scann_2fproto_2fhash_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::research_scann::_AsymmetricHasherConfig_FixedPointLUTConversionOptions_default_instance_;
    new (ptr) ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AsymmetricHasherConfig_FixedPointLUTConversionOptions_scann_2fproto_2fhash_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_AsymmetricHasherConfig_FixedPointLUTConversionOptions_scann_2fproto_2fhash_2eproto}, {}};

static void InitDefaultsscc_info_BitSamplingHasherConfig_scann_2fproto_2fhash_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::research_scann::_BitSamplingHasherConfig_default_instance_;
    new (ptr) ::research_scann::BitSamplingHasherConfig();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::research_scann::BitSamplingHasherConfig::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BitSamplingHasherConfig_scann_2fproto_2fhash_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_BitSamplingHasherConfig_scann_2fproto_2fhash_2eproto}, {}};

static void InitDefaultsscc_info_BncHasherConfig_scann_2fproto_2fhash_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::research_scann::_BncHasherConfig_default_instance_;
    new (ptr) ::research_scann::BncHasherConfig();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::research_scann::BncHasherConfig::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BncHasherConfig_scann_2fproto_2fhash_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_BncHasherConfig_scann_2fproto_2fhash_2eproto}, {}};

static void InitDefaultsscc_info_HashConfig_scann_2fproto_2fhash_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::research_scann::_HashConfig_default_instance_;
    new (ptr) ::research_scann::HashConfig();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::research_scann::HashConfig::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_HashConfig_scann_2fproto_2fhash_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 6, InitDefaultsscc_info_HashConfig_scann_2fproto_2fhash_2eproto}, {
      &scc_info_ProjectionConfig_scann_2fproto_2fprojection_2eproto.base,
      &scc_info_AsymmetricHasherConfig_scann_2fproto_2fhash_2eproto.base,
      &scc_info_MinHasherConfig_scann_2fproto_2fhash_2eproto.base,
      &scc_info_PcaHasherConfig_scann_2fproto_2fhash_2eproto.base,
      &scc_info_BitSamplingHasherConfig_scann_2fproto_2fhash_2eproto.base,
      &scc_info_BncHasherConfig_scann_2fproto_2fhash_2eproto.base,}};

static void InitDefaultsscc_info_MinHasherConfig_scann_2fproto_2fhash_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::research_scann::_MinHasherConfig_default_instance_;
    new (ptr) ::research_scann::MinHasherConfig();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::research_scann::MinHasherConfig::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MinHasherConfig_scann_2fproto_2fhash_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_MinHasherConfig_scann_2fproto_2fhash_2eproto}, {}};

static void InitDefaultsscc_info_PcaHasherConfig_scann_2fproto_2fhash_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::research_scann::_PcaHasherConfig_default_instance_;
    new (ptr) ::research_scann::PcaHasherConfig();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::research_scann::PcaHasherConfig::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PcaHasherConfig_scann_2fproto_2fhash_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_PcaHasherConfig_scann_2fproto_2fhash_2eproto}, {}};

static void InitDefaultsscc_info_StackedQuantizersConfig_scann_2fproto_2fhash_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::research_scann::_StackedQuantizersConfig_default_instance_;
    new (ptr) ::research_scann::StackedQuantizersConfig();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::research_scann::StackedQuantizersConfig::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StackedQuantizersConfig_scann_2fproto_2fhash_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_StackedQuantizersConfig_scann_2fproto_2fhash_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_scann_2fproto_2fhash_2eproto[8];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_scann_2fproto_2fhash_2eproto[4];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_scann_2fproto_2fhash_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_scann_2fproto_2fhash_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, num_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, projection_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, threshold_type_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, parameters_filename_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, asymmetric_hash_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, min_hash_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, pca_hash_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, bit_sampling_hash_),
  PROTOBUF_FIELD_OFFSET(::research_scann::HashConfig, bnc_hash_),
  7,
  1,
  8,
  0,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions, float_to_int_conversion_method_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions, multiplier_quantile_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, projection_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, num_clusters_per_block_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, lookup_type_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, clustering_seed_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, use_residual_quantization_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, use_normalized_residual_quantization_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, noise_shaping_threshold_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, use_norm_biasing_correction_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, use_global_topn_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, use_noise_shaped_training_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, fixed_point_lut_conversion_options_),
  offsetof(::research_scann::AsymmetricHasherConfigDefaultTypeInternal, sampling_fraction_),
  offsetof(::research_scann::AsymmetricHasherConfigDefaultTypeInternal, expected_sample_size_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, sampling_seed_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, quantization_distance_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, max_clustering_iterations_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, clustering_convergence_tolerance_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, min_cluster_size_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, centers_filename_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, num_machines_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, use_per_leaf_partition_training_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, mr_jobname_prefix_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, cell_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, ram_gb_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, num_cpus_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, quantization_scheme_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, stacked_quantizers_config_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, partition_level_confidence_interval_stdevs_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, use_single_machine_trainer_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, min_number_machines_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, max_sample_size_),
  PROTOBUF_FIELD_OFFSET(::research_scann::AsymmetricHasherConfig, SamplingFractionOrExpectedSize_),
  3,
  20,
  11,
  24,
  15,
  16,
  28,
  17,
  18,
  8,
  6,
  ~0u,
  ~0u,
  25,
  4,
  22,
  23,
  19,
  0,
  14,
  9,
  1,
  2,
  26,
  27,
  12,
  5,
  13,
  10,
  7,
  21,
  PROTOBUF_FIELD_OFFSET(::research_scann::MinHasherConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::MinHasherConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::research_scann::MinHasherConfig, config_id_),
  PROTOBUF_FIELD_OFFSET(::research_scann::MinHasherConfig, num_sketches_),
  PROTOBUF_FIELD_OFFSET(::research_scann::MinHasherConfig, num_hashes_),
  PROTOBUF_FIELD_OFFSET(::research_scann::MinHasherConfig, seeds_),
  PROTOBUF_FIELD_OFFSET(::research_scann::MinHasherConfig, num_bits_per_hash_),
  0,
  1,
  2,
  ~0u,
  3,
  PROTOBUF_FIELD_OFFSET(::research_scann::BitSamplingHasherConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BitSamplingHasherConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::research_scann::BitSamplingHasherConfig, num_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BitSamplingHasherConfig, use_entropy_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, rotate_projections_),
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, sampling_fraction_),
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, sampling_seed_),
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, max_sample_size_),
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, learn_projections_),
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, max_num_iteration_),
  PROTOBUF_FIELD_OFFSET(::research_scann::PcaHasherConfig, iteration_tolerance_),
  0,
  3,
  4,
  2,
  1,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, compression_ratio_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, gamma_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, learning_rate_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, batch_size_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, num_phase1_iterations_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, num_phase2_iterations_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, sampling_seed_),
  PROTOBUF_FIELD_OFFSET(::research_scann::BncHasherConfig, num_cpus_),
  0,
  2,
  3,
  4,
  5,
  6,
  7,
  1,
  PROTOBUF_FIELD_OFFSET(::research_scann::StackedQuantizersConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::research_scann::StackedQuantizersConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::research_scann::StackedQuantizersConfig, min_num_iterations_),
  PROTOBUF_FIELD_OFFSET(::research_scann::StackedQuantizersConfig, max_num_iterations_),
  PROTOBUF_FIELD_OFFSET(::research_scann::StackedQuantizersConfig, relative_improvement_threshold_),
  1,
  2,
  0,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 14, sizeof(::research_scann::HashConfig)},
  { 23, 30, sizeof(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions)},
  { 32, 69, sizeof(::research_scann::AsymmetricHasherConfig)},
  { 100, 110, sizeof(::research_scann::MinHasherConfig)},
  { 115, 122, sizeof(::research_scann::BitSamplingHasherConfig)},
  { 124, 136, sizeof(::research_scann::PcaHasherConfig)},
  { 143, 156, sizeof(::research_scann::BncHasherConfig)},
  { 164, 172, sizeof(::research_scann::StackedQuantizersConfig)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::research_scann::_HashConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::research_scann::_AsymmetricHasherConfig_FixedPointLUTConversionOptions_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::research_scann::_AsymmetricHasherConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::research_scann::_MinHasherConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::research_scann::_BitSamplingHasherConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::research_scann::_PcaHasherConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::research_scann::_BncHasherConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::research_scann::_StackedQuantizersConfig_default_instance_),
};

const char descriptor_table_protodef_scann_2fproto_2fhash_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\026scann/proto/hash.proto\022\016research_scann"
  "\032\"scann/proto/distance_measure.proto\032\034sc"
  "ann/proto/projection.proto\"\245\004\n\nHashConfi"
  "g\022\020\n\010num_bits\030\001 \001(\005\0224\n\nprojection\030\002 \001(\0132"
  " .research_scann.ProjectionConfig\022F\n\016thr"
  "eshold_type\030\003 \001(\0162(.research_scann.HashC"
  "onfig.ThresholdType:\004SIGN\022\033\n\023parameters_"
  "filename\030\004 \001(\t\022\?\n\017asymmetric_hash\030\005 \001(\0132"
  "&.research_scann.AsymmetricHasherConfig\022"
  "1\n\010min_hash\030\006 \001(\0132\037.research_scann.MinHa"
  "sherConfig\0221\n\010pca_hash\030\007 \001(\0132\037.research_"
  "scann.PcaHasherConfig\022B\n\021bit_sampling_ha"
  "sh\030\t \001(\0132\'.research_scann.BitSamplingHas"
  "herConfig\0221\n\010bnc_hash\030\n \001(\0132\037.research_s"
  "cann.BncHasherConfig\"L\n\rThresholdType\022\013\n"
  "\007UNKNOWN\020\000\022\010\n\004SIGN\020\001\022\010\n\004MEAN\020\002\022\n\n\006MEDIAN"
  "\020\003\022\016\n\nSINUSOIDAL\020\004\"\272\016\n\026AsymmetricHasherC"
  "onfig\0224\n\nprojection\030\001 \001(\0132 .research_sca"
  "nn.ProjectionConfig\022#\n\026num_clusters_per_"
  "block\030\002 \001(\005:\003256\022M\n\013lookup_type\030\024 \001(\01621."
  "research_scann.AsymmetricHasherConfig.Lo"
  "okupType:\005FLOAT\022\032\n\017clustering_seed\030\t \001(\005"
  ":\0011\022(\n\031use_residual_quantization\030\026 \001(\010:\005"
  "false\0223\n$use_normalized_residual_quantiz"
  "ation\030  \001(\010:\005false\022$\n\027noise_shaping_thre"
  "shold\030\034 \001(\001:\003nan\022*\n\033use_norm_biasing_cor"
  "rection\030\037 \001(\010:\005false\022\036\n\017use_global_topn\030"
  "! \001(\010:\005false\022(\n\031use_noise_shaped_trainin"
  "g\030\036 \001(\010:\005false\022q\n\"fixed_point_lut_conver"
  "sion_options\030\031 \001(\0132E.research_scann.Asym"
  "metricHasherConfig.FixedPointLUTConversi"
  "onOptions\022\036\n\021sampling_fraction\030\n \001(\002:\0011H"
  "\000\022\036\n\024expected_sample_size\030\035 \001(\005H\000\022\030\n\rsam"
  "pling_seed\030\013 \001(\005:\0011\022D\n\025quantization_dist"
  "ance\030\022 \001(\0132%.research_scann.DistanceMeas"
  "ureConfig\022%\n\031max_clustering_iterations\030\004"
  " \001(\005:\00210\022/\n clustering_convergence_toler"
  "ance\030\005 \001(\002:\0051e-05\022\033\n\020min_cluster_size\030\023 "
  "\001(\002:\0011\022\030\n\020centers_filename\030\006 \001(\t\022\024\n\014num_"
  "machines\030\033 \001(\005\022.\n\037use_per_leaf_partition"
  "_training\030\021 \001(\010:\005false\022\031\n\021mr_jobname_pre"
  "fix\030\014 \001(\t\022\014\n\004cell\030\r \001(\t\022\021\n\006ram_gb\030\016 \001(\005:"
  "\0014\022\023\n\010num_cpus\030\017 \001(\005:\0011\022_\n\023quantization_"
  "scheme\030\027 \001(\01629.research_scann.Asymmetric"
  "HasherConfig.QuantizationScheme:\007PRODUCT"
  "\022J\n\031stacked_quantizers_config\030\030 \001(\0132\'.re"
  "search_scann.StackedQuantizersConfig\0229\n*"
  "partition_level_confidence_interval_stde"
  "vs\030\032 \001(\002:\0010B\002\030\001\022-\n\032use_single_machine_tr"
  "ainer\030\010 \001(\010:\005falseB\002\030\001\022\037\n\023min_number_mac"
  "hines\030\007 \001(\005B\002\030\001\022#\n\017max_sample_size\030\003 \001(\005"
  ":\n2147483647\032\214\002\n\036FixedPointLUTConversion"
  "Options\022\222\001\n\036float_to_int_conversion_meth"
  "od\030\001 \001(\0162`.research_scann.AsymmetricHash"
  "erConfig.FixedPointLUTConversionOptions."
  "FloatToIntConversionMethod:\010TRUNCATE\022\036\n\023"
  "multiplier_quantile\030\002 \001(\002:\0011\"5\n\032FloatToI"
  "ntConversionMethod\022\014\n\010TRUNCATE\020\000\022\t\n\005ROUN"
  "D\020\001\"<\n\nLookupType\022\t\n\005FLOAT\020\000\022\010\n\004INT8\020\001\022\t"
  "\n\005INT16\020\002\022\016\n\nINT8_LUT16\020\003\"Z\n\022Quantizatio"
  "nScheme\022\013\n\007PRODUCT\020\000\022\013\n\007STACKED\020\001\022\024\n\020PRO"
  "DUCT_AND_BIAS\020\002\022\024\n\020PRODUCT_AND_PACK\020\003B \n"
  "\036SamplingFractionOrExpectedSize\"x\n\017MinHa"
  "sherConfig\022\021\n\tconfig_id\030\001 \001(\005\022\024\n\014num_ske"
  "tches\030\002 \001(\005\022\022\n\nnum_hashes\030\003 \001(\005\022\r\n\005seeds"
  "\030\004 \003(\003\022\031\n\021num_bits_per_hash\030\005 \001(\005\"a\n\027Bit"
  "SamplingHasherConfig\022\023\n\010num_bits\030\001 \001(\005:\001"
  "3\022\032\n\013use_entropy\030\002 \001(\010:\005falseJ\004\010\003\020\004R\017chu"
  "nked_hamming\"\352\001\n\017PcaHasherConfig\022!\n\022rota"
  "te_projections\030\001 \001(\010:\005false\022\034\n\021sampling_"
  "fraction\030\002 \001(\002:\0011\022\030\n\rsampling_seed\030\003 \001(\005"
  ":\0011\022\027\n\017max_sample_size\030\004 \001(\005\022 \n\021learn_pr"
  "ojections\030\005 \001(\010:\005false\022\035\n\021max_num_iterat"
  "ion\030\006 \001(\005:\00240\022\"\n\023iteration_tolerance\030\007 \001"
  "(\002:\0051e-05\"\355\001\n\017BncHasherConfig\022\034\n\021compres"
  "sion_ratio\030\001 \001(\002:\0010\022\021\n\005gamma\030\002 \001(\002:\00210\022\032"
  "\n\rlearning_rate\030\003 \001(\002:\0030.1\022\027\n\nbatch_size"
  "\030\004 \001(\005:\003128\022!\n\025num_phase1_iterations\030\005 \001"
  "(\005:\00250\022\"\n\025num_phase2_iterations\030\006 \001(\005:\0031"
  "00\022\030\n\rsampling_seed\030\007 \001(\005:\0011\022\023\n\010num_cpus"
  "\030\010 \001(\005:\0011\"\207\001\n\027StackedQuantizersConfig\022\035\n"
  "\022min_num_iterations\030\001 \001(\005:\0013\022\036\n\022max_num_"
  "iterations\030\002 \001(\005:\00210\022-\n\036relative_improve"
  "ment_threshold\030\003 \001(\002:\0050.001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_scann_2fproto_2fhash_2eproto_deps[2] = {
  &::descriptor_table_scann_2fproto_2fdistance_5fmeasure_2eproto,
  &::descriptor_table_scann_2fproto_2fprojection_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_scann_2fproto_2fhash_2eproto_sccs[8] = {
  &scc_info_AsymmetricHasherConfig_scann_2fproto_2fhash_2eproto.base,
  &scc_info_AsymmetricHasherConfig_FixedPointLUTConversionOptions_scann_2fproto_2fhash_2eproto.base,
  &scc_info_BitSamplingHasherConfig_scann_2fproto_2fhash_2eproto.base,
  &scc_info_BncHasherConfig_scann_2fproto_2fhash_2eproto.base,
  &scc_info_HashConfig_scann_2fproto_2fhash_2eproto.base,
  &scc_info_MinHasherConfig_scann_2fproto_2fhash_2eproto.base,
  &scc_info_PcaHasherConfig_scann_2fproto_2fhash_2eproto.base,
  &scc_info_StackedQuantizersConfig_scann_2fproto_2fhash_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_scann_2fproto_2fhash_2eproto_once;
static bool descriptor_table_scann_2fproto_2fhash_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scann_2fproto_2fhash_2eproto = {
  &descriptor_table_scann_2fproto_2fhash_2eproto_initialized, descriptor_table_protodef_scann_2fproto_2fhash_2eproto, "scann/proto/hash.proto", 3347,
  &descriptor_table_scann_2fproto_2fhash_2eproto_once, descriptor_table_scann_2fproto_2fhash_2eproto_sccs, descriptor_table_scann_2fproto_2fhash_2eproto_deps, 8, 2,
  schemas, file_default_instances, TableStruct_scann_2fproto_2fhash_2eproto::offsets,
  file_level_metadata_scann_2fproto_2fhash_2eproto, 8, file_level_enum_descriptors_scann_2fproto_2fhash_2eproto, file_level_service_descriptors_scann_2fproto_2fhash_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_scann_2fproto_2fhash_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_scann_2fproto_2fhash_2eproto), true);
namespace research_scann {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HashConfig_ThresholdType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_scann_2fproto_2fhash_2eproto);
  return file_level_enum_descriptors_scann_2fproto_2fhash_2eproto[0];
}
bool HashConfig_ThresholdType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr HashConfig_ThresholdType HashConfig::UNKNOWN;
constexpr HashConfig_ThresholdType HashConfig::SIGN;
constexpr HashConfig_ThresholdType HashConfig::MEAN;
constexpr HashConfig_ThresholdType HashConfig::MEDIAN;
constexpr HashConfig_ThresholdType HashConfig::SINUSOIDAL;
constexpr HashConfig_ThresholdType HashConfig::ThresholdType_MIN;
constexpr HashConfig_ThresholdType HashConfig::ThresholdType_MAX;
constexpr int HashConfig::ThresholdType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_scann_2fproto_2fhash_2eproto);
  return file_level_enum_descriptors_scann_2fproto_2fhash_2eproto[1];
}
bool AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod AsymmetricHasherConfig_FixedPointLUTConversionOptions::TRUNCATE;
constexpr AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod AsymmetricHasherConfig_FixedPointLUTConversionOptions::ROUND;
constexpr AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod AsymmetricHasherConfig_FixedPointLUTConversionOptions::FloatToIntConversionMethod_MIN;
constexpr AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod AsymmetricHasherConfig_FixedPointLUTConversionOptions::FloatToIntConversionMethod_MAX;
constexpr int AsymmetricHasherConfig_FixedPointLUTConversionOptions::FloatToIntConversionMethod_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AsymmetricHasherConfig_LookupType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_scann_2fproto_2fhash_2eproto);
  return file_level_enum_descriptors_scann_2fproto_2fhash_2eproto[2];
}
bool AsymmetricHasherConfig_LookupType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr AsymmetricHasherConfig_LookupType AsymmetricHasherConfig::FLOAT;
constexpr AsymmetricHasherConfig_LookupType AsymmetricHasherConfig::INT8;
constexpr AsymmetricHasherConfig_LookupType AsymmetricHasherConfig::INT16;
constexpr AsymmetricHasherConfig_LookupType AsymmetricHasherConfig::INT8_LUT16;
constexpr AsymmetricHasherConfig_LookupType AsymmetricHasherConfig::LookupType_MIN;
constexpr AsymmetricHasherConfig_LookupType AsymmetricHasherConfig::LookupType_MAX;
constexpr int AsymmetricHasherConfig::LookupType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AsymmetricHasherConfig_QuantizationScheme_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_scann_2fproto_2fhash_2eproto);
  return file_level_enum_descriptors_scann_2fproto_2fhash_2eproto[3];
}
bool AsymmetricHasherConfig_QuantizationScheme_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig::PRODUCT;
constexpr AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig::STACKED;
constexpr AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig::PRODUCT_AND_BIAS;
constexpr AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig::PRODUCT_AND_PACK;
constexpr AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig::QuantizationScheme_MIN;
constexpr AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig::QuantizationScheme_MAX;
constexpr int AsymmetricHasherConfig::QuantizationScheme_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void HashConfig::InitAsDefaultInstance() {
  ::research_scann::_HashConfig_default_instance_._instance.get_mutable()->projection_ = const_cast< ::research_scann::ProjectionConfig*>(
      ::research_scann::ProjectionConfig::internal_default_instance());
  ::research_scann::_HashConfig_default_instance_._instance.get_mutable()->asymmetric_hash_ = const_cast< ::research_scann::AsymmetricHasherConfig*>(
      ::research_scann::AsymmetricHasherConfig::internal_default_instance());
  ::research_scann::_HashConfig_default_instance_._instance.get_mutable()->min_hash_ = const_cast< ::research_scann::MinHasherConfig*>(
      ::research_scann::MinHasherConfig::internal_default_instance());
  ::research_scann::_HashConfig_default_instance_._instance.get_mutable()->pca_hash_ = const_cast< ::research_scann::PcaHasherConfig*>(
      ::research_scann::PcaHasherConfig::internal_default_instance());
  ::research_scann::_HashConfig_default_instance_._instance.get_mutable()->bit_sampling_hash_ = const_cast< ::research_scann::BitSamplingHasherConfig*>(
      ::research_scann::BitSamplingHasherConfig::internal_default_instance());
  ::research_scann::_HashConfig_default_instance_._instance.get_mutable()->bnc_hash_ = const_cast< ::research_scann::BncHasherConfig*>(
      ::research_scann::BncHasherConfig::internal_default_instance());
}
class HashConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<HashConfig>()._has_bits_);
  static void set_has_num_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::research_scann::ProjectionConfig& projection(const HashConfig* msg);
  static void set_has_projection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_threshold_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_parameters_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::research_scann::AsymmetricHasherConfig& asymmetric_hash(const HashConfig* msg);
  static void set_has_asymmetric_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::research_scann::MinHasherConfig& min_hash(const HashConfig* msg);
  static void set_has_min_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::research_scann::PcaHasherConfig& pca_hash(const HashConfig* msg);
  static void set_has_pca_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::research_scann::BitSamplingHasherConfig& bit_sampling_hash(const HashConfig* msg);
  static void set_has_bit_sampling_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::research_scann::BncHasherConfig& bnc_hash(const HashConfig* msg);
  static void set_has_bnc_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::research_scann::ProjectionConfig&
HashConfig::_Internal::projection(const HashConfig* msg) {
  return *msg->projection_;
}
const ::research_scann::AsymmetricHasherConfig&
HashConfig::_Internal::asymmetric_hash(const HashConfig* msg) {
  return *msg->asymmetric_hash_;
}
const ::research_scann::MinHasherConfig&
HashConfig::_Internal::min_hash(const HashConfig* msg) {
  return *msg->min_hash_;
}
const ::research_scann::PcaHasherConfig&
HashConfig::_Internal::pca_hash(const HashConfig* msg) {
  return *msg->pca_hash_;
}
const ::research_scann::BitSamplingHasherConfig&
HashConfig::_Internal::bit_sampling_hash(const HashConfig* msg) {
  return *msg->bit_sampling_hash_;
}
const ::research_scann::BncHasherConfig&
HashConfig::_Internal::bnc_hash(const HashConfig* msg) {
  return *msg->bnc_hash_;
}
void HashConfig::clear_projection() {
  if (projection_ != nullptr) projection_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
HashConfig::HashConfig()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:research_scann.HashConfig)
}
HashConfig::HashConfig(const HashConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  parameters_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_parameters_filename()) {
    parameters_filename_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.parameters_filename_);
  }
  if (from.has_projection()) {
    projection_ = new ::research_scann::ProjectionConfig(*from.projection_);
  } else {
    projection_ = nullptr;
  }
  if (from.has_asymmetric_hash()) {
    asymmetric_hash_ = new ::research_scann::AsymmetricHasherConfig(*from.asymmetric_hash_);
  } else {
    asymmetric_hash_ = nullptr;
  }
  if (from.has_min_hash()) {
    min_hash_ = new ::research_scann::MinHasherConfig(*from.min_hash_);
  } else {
    min_hash_ = nullptr;
  }
  if (from.has_pca_hash()) {
    pca_hash_ = new ::research_scann::PcaHasherConfig(*from.pca_hash_);
  } else {
    pca_hash_ = nullptr;
  }
  if (from.has_bit_sampling_hash()) {
    bit_sampling_hash_ = new ::research_scann::BitSamplingHasherConfig(*from.bit_sampling_hash_);
  } else {
    bit_sampling_hash_ = nullptr;
  }
  if (from.has_bnc_hash()) {
    bnc_hash_ = new ::research_scann::BncHasherConfig(*from.bnc_hash_);
  } else {
    bnc_hash_ = nullptr;
  }
  ::memcpy(&num_bits_, &from.num_bits_,
    static_cast<size_t>(reinterpret_cast<char*>(&threshold_type_) -
    reinterpret_cast<char*>(&num_bits_)) + sizeof(threshold_type_));
  // @@protoc_insertion_point(copy_constructor:research_scann.HashConfig)
}

void HashConfig::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_HashConfig_scann_2fproto_2fhash_2eproto.base);
  parameters_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&projection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_bits_) -
      reinterpret_cast<char*>(&projection_)) + sizeof(num_bits_));
  threshold_type_ = 1;
}

HashConfig::~HashConfig() {
  // @@protoc_insertion_point(destructor:research_scann.HashConfig)
  SharedDtor();
}

void HashConfig::SharedDtor() {
  parameters_filename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete projection_;
  if (this != internal_default_instance()) delete asymmetric_hash_;
  if (this != internal_default_instance()) delete min_hash_;
  if (this != internal_default_instance()) delete pca_hash_;
  if (this != internal_default_instance()) delete bit_sampling_hash_;
  if (this != internal_default_instance()) delete bnc_hash_;
}

void HashConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const HashConfig& HashConfig::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_HashConfig_scann_2fproto_2fhash_2eproto.base);
  return *internal_default_instance();
}


void HashConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:research_scann.HashConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      parameters_filename_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(projection_ != nullptr);
      projection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(asymmetric_hash_ != nullptr);
      asymmetric_hash_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(min_hash_ != nullptr);
      min_hash_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(pca_hash_ != nullptr);
      pca_hash_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(bit_sampling_hash_ != nullptr);
      bit_sampling_hash_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(bnc_hash_ != nullptr);
      bnc_hash_->Clear();
    }
  }
  num_bits_ = 0;
  threshold_type_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* HashConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 num_bits = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_num_bits(&has_bits);
          num_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.ProjectionConfig projection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_projection(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.HashConfig.ThresholdType threshold_type = 3 [default = SIGN];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::research_scann::HashConfig_ThresholdType_IsValid(val))) {
            set_threshold_type(static_cast<::research_scann::HashConfig_ThresholdType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string parameters_filename = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_parameters_filename(), ptr, ctx, "research_scann.HashConfig.parameters_filename");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.AsymmetricHasherConfig asymmetric_hash = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(mutable_asymmetric_hash(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.MinHasherConfig min_hash = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_min_hash(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.PcaHasherConfig pca_hash = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(mutable_pca_hash(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.BitSamplingHasherConfig bit_sampling_hash = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(mutable_bit_sampling_hash(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.BncHasherConfig bnc_hash = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(mutable_bnc_hash(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool HashConfig::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:research_scann.HashConfig)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 num_bits = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_num_bits(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_bits_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .research_scann.ProjectionConfig projection = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_projection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .research_scann.HashConfig.ThresholdType threshold_type = 3 [default = SIGN];
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::research_scann::HashConfig_ThresholdType_IsValid(value)) {
            set_threshold_type(static_cast< ::research_scann::HashConfig_ThresholdType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string parameters_filename = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_parameters_filename()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->parameters_filename().data(), static_cast<int>(this->parameters_filename().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "research_scann.HashConfig.parameters_filename");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .research_scann.AsymmetricHasherConfig asymmetric_hash = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_asymmetric_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .research_scann.MinHasherConfig min_hash = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_min_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .research_scann.PcaHasherConfig pca_hash = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_pca_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .research_scann.BitSamplingHasherConfig bit_sampling_hash = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (74 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_bit_sampling_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .research_scann.BncHasherConfig bnc_hash = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (82 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_bnc_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:research_scann.HashConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:research_scann.HashConfig)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void HashConfig::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:research_scann.HashConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 num_bits = 1;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->num_bits(), output);
  }

  // optional .research_scann.ProjectionConfig projection = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, _Internal::projection(this), output);
  }

  // optional .research_scann.HashConfig.ThresholdType threshold_type = 3 [default = SIGN];
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->threshold_type(), output);
  }

  // optional string parameters_filename = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->parameters_filename().data(), static_cast<int>(this->parameters_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "research_scann.HashConfig.parameters_filename");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->parameters_filename(), output);
  }

  // optional .research_scann.AsymmetricHasherConfig asymmetric_hash = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, _Internal::asymmetric_hash(this), output);
  }

  // optional .research_scann.MinHasherConfig min_hash = 6;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, _Internal::min_hash(this), output);
  }

  // optional .research_scann.PcaHasherConfig pca_hash = 7;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, _Internal::pca_hash(this), output);
  }

  // optional .research_scann.BitSamplingHasherConfig bit_sampling_hash = 9;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, _Internal::bit_sampling_hash(this), output);
  }

  // optional .research_scann.BncHasherConfig bnc_hash = 10;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, _Internal::bnc_hash(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:research_scann.HashConfig)
}

::PROTOBUF_NAMESPACE_ID::uint8* HashConfig::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:research_scann.HashConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 num_bits = 1;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->num_bits(), target);
  }

  // optional .research_scann.ProjectionConfig projection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::projection(this), target);
  }

  // optional .research_scann.HashConfig.ThresholdType threshold_type = 3 [default = SIGN];
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->threshold_type(), target);
  }

  // optional string parameters_filename = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->parameters_filename().data(), static_cast<int>(this->parameters_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "research_scann.HashConfig.parameters_filename");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        4, this->parameters_filename(), target);
  }

  // optional .research_scann.AsymmetricHasherConfig asymmetric_hash = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, _Internal::asymmetric_hash(this), target);
  }

  // optional .research_scann.MinHasherConfig min_hash = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, _Internal::min_hash(this), target);
  }

  // optional .research_scann.PcaHasherConfig pca_hash = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, _Internal::pca_hash(this), target);
  }

  // optional .research_scann.BitSamplingHasherConfig bit_sampling_hash = 9;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, _Internal::bit_sampling_hash(this), target);
  }

  // optional .research_scann.BncHasherConfig bnc_hash = 10;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        10, _Internal::bnc_hash(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:research_scann.HashConfig)
  return target;
}

size_t HashConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:research_scann.HashConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string parameters_filename = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->parameters_filename());
    }

    // optional .research_scann.ProjectionConfig projection = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *projection_);
    }

    // optional .research_scann.AsymmetricHasherConfig asymmetric_hash = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *asymmetric_hash_);
    }

    // optional .research_scann.MinHasherConfig min_hash = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *min_hash_);
    }

    // optional .research_scann.PcaHasherConfig pca_hash = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pca_hash_);
    }

    // optional .research_scann.BitSamplingHasherConfig bit_sampling_hash = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bit_sampling_hash_);
    }

    // optional .research_scann.BncHasherConfig bnc_hash = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bnc_hash_);
    }

    // optional int32 num_bits = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_bits());
    }

  }
  // optional .research_scann.HashConfig.ThresholdType threshold_type = 3 [default = SIGN];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->threshold_type());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HashConfig::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:research_scann.HashConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const HashConfig* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<HashConfig>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:research_scann.HashConfig)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:research_scann.HashConfig)
    MergeFrom(*source);
  }
}

void HashConfig::MergeFrom(const HashConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:research_scann.HashConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      parameters_filename_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.parameters_filename_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_projection()->::research_scann::ProjectionConfig::MergeFrom(from.projection());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_asymmetric_hash()->::research_scann::AsymmetricHasherConfig::MergeFrom(from.asymmetric_hash());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_min_hash()->::research_scann::MinHasherConfig::MergeFrom(from.min_hash());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_pca_hash()->::research_scann::PcaHasherConfig::MergeFrom(from.pca_hash());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_bit_sampling_hash()->::research_scann::BitSamplingHasherConfig::MergeFrom(from.bit_sampling_hash());
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_bnc_hash()->::research_scann::BncHasherConfig::MergeFrom(from.bnc_hash());
    }
    if (cached_has_bits & 0x00000080u) {
      num_bits_ = from.num_bits_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_threshold_type(from.threshold_type());
  }
}

void HashConfig::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:research_scann.HashConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HashConfig::CopyFrom(const HashConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:research_scann.HashConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HashConfig::IsInitialized() const {
  if (has_projection()) {
    if (!this->projection_->IsInitialized()) return false;
  }
  if (has_asymmetric_hash()) {
    if (!this->asymmetric_hash_->IsInitialized()) return false;
  }
  return true;
}

void HashConfig::InternalSwap(HashConfig* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  parameters_filename_.Swap(&other->parameters_filename_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(projection_, other->projection_);
  swap(asymmetric_hash_, other->asymmetric_hash_);
  swap(min_hash_, other->min_hash_);
  swap(pca_hash_, other->pca_hash_);
  swap(bit_sampling_hash_, other->bit_sampling_hash_);
  swap(bnc_hash_, other->bnc_hash_);
  swap(num_bits_, other->num_bits_);
  swap(threshold_type_, other->threshold_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HashConfig::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AsymmetricHasherConfig_FixedPointLUTConversionOptions::InitAsDefaultInstance() {
}
class AsymmetricHasherConfig_FixedPointLUTConversionOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<AsymmetricHasherConfig_FixedPointLUTConversionOptions>()._has_bits_);
  static void set_has_float_to_int_conversion_method(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_multiplier_quantile(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AsymmetricHasherConfig_FixedPointLUTConversionOptions::AsymmetricHasherConfig_FixedPointLUTConversionOptions()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
}
AsymmetricHasherConfig_FixedPointLUTConversionOptions::AsymmetricHasherConfig_FixedPointLUTConversionOptions(const AsymmetricHasherConfig_FixedPointLUTConversionOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&float_to_int_conversion_method_, &from.float_to_int_conversion_method_,
    static_cast<size_t>(reinterpret_cast<char*>(&multiplier_quantile_) -
    reinterpret_cast<char*>(&float_to_int_conversion_method_)) + sizeof(multiplier_quantile_));
  // @@protoc_insertion_point(copy_constructor:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
}

void AsymmetricHasherConfig_FixedPointLUTConversionOptions::SharedCtor() {
  float_to_int_conversion_method_ = 0;
  multiplier_quantile_ = 1;
}

AsymmetricHasherConfig_FixedPointLUTConversionOptions::~AsymmetricHasherConfig_FixedPointLUTConversionOptions() {
  // @@protoc_insertion_point(destructor:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  SharedDtor();
}

void AsymmetricHasherConfig_FixedPointLUTConversionOptions::SharedDtor() {
}

void AsymmetricHasherConfig_FixedPointLUTConversionOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AsymmetricHasherConfig_FixedPointLUTConversionOptions& AsymmetricHasherConfig_FixedPointLUTConversionOptions::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AsymmetricHasherConfig_FixedPointLUTConversionOptions_scann_2fproto_2fhash_2eproto.base);
  return *internal_default_instance();
}


void AsymmetricHasherConfig_FixedPointLUTConversionOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    float_to_int_conversion_method_ = 0;
    multiplier_quantile_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AsymmetricHasherConfig_FixedPointLUTConversionOptions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.FloatToIntConversionMethod float_to_int_conversion_method = 1 [default = TRUNCATE];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_IsValid(val))) {
            set_float_to_int_conversion_method(static_cast<::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional float multiplier_quantile = 2 [default = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_multiplier_quantile(&has_bits);
          multiplier_quantile_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AsymmetricHasherConfig_FixedPointLUTConversionOptions::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.FloatToIntConversionMethod float_to_int_conversion_method = 1 [default = TRUNCATE];
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_IsValid(value)) {
            set_float_to_int_conversion_method(static_cast< ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float multiplier_quantile = 2 [default = 1];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (21 & 0xFF)) {
          _Internal::set_has_multiplier_quantile(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &multiplier_quantile_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AsymmetricHasherConfig_FixedPointLUTConversionOptions::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.FloatToIntConversionMethod float_to_int_conversion_method = 1 [default = TRUNCATE];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->float_to_int_conversion_method(), output);
  }

  // optional float multiplier_quantile = 2 [default = 1];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(2, this->multiplier_quantile(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
}

::PROTOBUF_NAMESPACE_ID::uint8* AsymmetricHasherConfig_FixedPointLUTConversionOptions::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.FloatToIntConversionMethod float_to_int_conversion_method = 1 [default = TRUNCATE];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->float_to_int_conversion_method(), target);
  }

  // optional float multiplier_quantile = 2 [default = 1];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->multiplier_quantile(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  return target;
}

size_t AsymmetricHasherConfig_FixedPointLUTConversionOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.FloatToIntConversionMethod float_to_int_conversion_method = 1 [default = TRUNCATE];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->float_to_int_conversion_method());
    }

    // optional float multiplier_quantile = 2 [default = 1];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AsymmetricHasherConfig_FixedPointLUTConversionOptions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  GOOGLE_DCHECK_NE(&from, this);
  const AsymmetricHasherConfig_FixedPointLUTConversionOptions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AsymmetricHasherConfig_FixedPointLUTConversionOptions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
    MergeFrom(*source);
  }
}

void AsymmetricHasherConfig_FixedPointLUTConversionOptions::MergeFrom(const AsymmetricHasherConfig_FixedPointLUTConversionOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      float_to_int_conversion_method_ = from.float_to_int_conversion_method_;
    }
    if (cached_has_bits & 0x00000002u) {
      multiplier_quantile_ = from.multiplier_quantile_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AsymmetricHasherConfig_FixedPointLUTConversionOptions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AsymmetricHasherConfig_FixedPointLUTConversionOptions::CopyFrom(const AsymmetricHasherConfig_FixedPointLUTConversionOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AsymmetricHasherConfig_FixedPointLUTConversionOptions::IsInitialized() const {
  return true;
}

void AsymmetricHasherConfig_FixedPointLUTConversionOptions::InternalSwap(AsymmetricHasherConfig_FixedPointLUTConversionOptions* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(float_to_int_conversion_method_, other->float_to_int_conversion_method_);
  swap(multiplier_quantile_, other->multiplier_quantile_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AsymmetricHasherConfig_FixedPointLUTConversionOptions::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AsymmetricHasherConfig::InitAsDefaultInstance() {
  ::research_scann::_AsymmetricHasherConfig_default_instance_._instance.get_mutable()->projection_ = const_cast< ::research_scann::ProjectionConfig*>(
      ::research_scann::ProjectionConfig::internal_default_instance());
  ::research_scann::_AsymmetricHasherConfig_default_instance_._instance.get_mutable()->fixed_point_lut_conversion_options_ = const_cast< ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions*>(
      ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions::internal_default_instance());
  ::research_scann::_AsymmetricHasherConfig_default_instance_.sampling_fraction_ = 1;
  ::research_scann::_AsymmetricHasherConfig_default_instance_.expected_sample_size_ = 0;
  ::research_scann::_AsymmetricHasherConfig_default_instance_._instance.get_mutable()->quantization_distance_ = const_cast< ::research_scann::DistanceMeasureConfig*>(
      ::research_scann::DistanceMeasureConfig::internal_default_instance());
  ::research_scann::_AsymmetricHasherConfig_default_instance_._instance.get_mutable()->stacked_quantizers_config_ = const_cast< ::research_scann::StackedQuantizersConfig*>(
      ::research_scann::StackedQuantizersConfig::internal_default_instance());
}
class AsymmetricHasherConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<AsymmetricHasherConfig>()._has_bits_);
  static const ::research_scann::ProjectionConfig& projection(const AsymmetricHasherConfig* msg);
  static void set_has_projection(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_num_clusters_per_block(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_lookup_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_clustering_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_use_residual_quantization(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_use_normalized_residual_quantization(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_noise_shaping_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_use_norm_biasing_correction(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_use_global_topn(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_use_noise_shaped_training(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions& fixed_point_lut_conversion_options(const AsymmetricHasherConfig* msg);
  static void set_has_fixed_point_lut_conversion_options(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_sampling_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static const ::research_scann::DistanceMeasureConfig& quantization_distance(const AsymmetricHasherConfig* msg);
  static void set_has_quantization_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_clustering_iterations(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_clustering_convergence_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_min_cluster_size(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_centers_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_machines(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_use_per_leaf_partition_training(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_mr_jobname_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ram_gb(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_num_cpus(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_quantization_scheme(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::research_scann::StackedQuantizersConfig& stacked_quantizers_config(const AsymmetricHasherConfig* msg);
  static void set_has_stacked_quantizers_config(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_partition_level_confidence_interval_stdevs(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_use_single_machine_trainer(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_min_number_machines(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_max_sample_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
};

const ::research_scann::ProjectionConfig&
AsymmetricHasherConfig::_Internal::projection(const AsymmetricHasherConfig* msg) {
  return *msg->projection_;
}
const ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions&
AsymmetricHasherConfig::_Internal::fixed_point_lut_conversion_options(const AsymmetricHasherConfig* msg) {
  return *msg->fixed_point_lut_conversion_options_;
}
const ::research_scann::DistanceMeasureConfig&
AsymmetricHasherConfig::_Internal::quantization_distance(const AsymmetricHasherConfig* msg) {
  return *msg->quantization_distance_;
}
const ::research_scann::StackedQuantizersConfig&
AsymmetricHasherConfig::_Internal::stacked_quantizers_config(const AsymmetricHasherConfig* msg) {
  return *msg->stacked_quantizers_config_;
}
void AsymmetricHasherConfig::clear_projection() {
  if (projection_ != nullptr) projection_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
void AsymmetricHasherConfig::clear_quantization_distance() {
  if (quantization_distance_ != nullptr) quantization_distance_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
AsymmetricHasherConfig::AsymmetricHasherConfig()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:research_scann.AsymmetricHasherConfig)
}
AsymmetricHasherConfig::AsymmetricHasherConfig(const AsymmetricHasherConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  centers_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_centers_filename()) {
    centers_filename_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.centers_filename_);
  }
  mr_jobname_prefix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_mr_jobname_prefix()) {
    mr_jobname_prefix_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.mr_jobname_prefix_);
  }
  cell_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_cell()) {
    cell_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.cell_);
  }
  if (from.has_projection()) {
    projection_ = new ::research_scann::ProjectionConfig(*from.projection_);
  } else {
    projection_ = nullptr;
  }
  if (from.has_quantization_distance()) {
    quantization_distance_ = new ::research_scann::DistanceMeasureConfig(*from.quantization_distance_);
  } else {
    quantization_distance_ = nullptr;
  }
  if (from.has_stacked_quantizers_config()) {
    stacked_quantizers_config_ = new ::research_scann::StackedQuantizersConfig(*from.stacked_quantizers_config_);
  } else {
    stacked_quantizers_config_ = nullptr;
  }
  if (from.has_fixed_point_lut_conversion_options()) {
    fixed_point_lut_conversion_options_ = new ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions(*from.fixed_point_lut_conversion_options_);
  } else {
    fixed_point_lut_conversion_options_ = nullptr;
  }
  ::memcpy(&min_number_machines_, &from.min_number_machines_,
    static_cast<size_t>(reinterpret_cast<char*>(&noise_shaping_threshold_) -
    reinterpret_cast<char*>(&min_number_machines_)) + sizeof(noise_shaping_threshold_));
  clear_has_SamplingFractionOrExpectedSize();
  switch (from.SamplingFractionOrExpectedSize_case()) {
    case kSamplingFraction: {
      set_sampling_fraction(from.sampling_fraction());
      break;
    }
    case kExpectedSampleSize: {
      set_expected_sample_size(from.expected_sample_size());
      break;
    }
    case SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:research_scann.AsymmetricHasherConfig)
}

void AsymmetricHasherConfig::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AsymmetricHasherConfig_scann_2fproto_2fhash_2eproto.base);
  centers_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  mr_jobname_prefix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cell_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&projection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&use_global_topn_) -
      reinterpret_cast<char*>(&projection_)) + sizeof(use_global_topn_));
  min_cluster_size_ = 1;
  num_clusters_per_block_ = 256;
  max_sample_size_ = 2147483647;
  max_clustering_iterations_ = 10;
  clustering_convergence_tolerance_ = 1e-05f;
  clustering_seed_ = 1;
  sampling_seed_ = 1;
  ram_gb_ = 4;
  num_cpus_ = 1;
  noise_shaping_threshold_ = std::numeric_limits<double>::quiet_NaN();
  clear_has_SamplingFractionOrExpectedSize();
}

AsymmetricHasherConfig::~AsymmetricHasherConfig() {
  // @@protoc_insertion_point(destructor:research_scann.AsymmetricHasherConfig)
  SharedDtor();
}

void AsymmetricHasherConfig::SharedDtor() {
  centers_filename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  mr_jobname_prefix_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cell_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete projection_;
  if (this != internal_default_instance()) delete quantization_distance_;
  if (this != internal_default_instance()) delete stacked_quantizers_config_;
  if (this != internal_default_instance()) delete fixed_point_lut_conversion_options_;
  if (has_SamplingFractionOrExpectedSize()) {
    clear_SamplingFractionOrExpectedSize();
  }
}

void AsymmetricHasherConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AsymmetricHasherConfig& AsymmetricHasherConfig::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AsymmetricHasherConfig_scann_2fproto_2fhash_2eproto.base);
  return *internal_default_instance();
}


void AsymmetricHasherConfig::clear_SamplingFractionOrExpectedSize() {
// @@protoc_insertion_point(one_of_clear_start:research_scann.AsymmetricHasherConfig)
  switch (SamplingFractionOrExpectedSize_case()) {
    case kSamplingFraction: {
      // No need to clear
      break;
    }
    case kExpectedSampleSize: {
      // No need to clear
      break;
    }
    case SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET;
}


void AsymmetricHasherConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:research_scann.AsymmetricHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      centers_filename_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      mr_jobname_prefix_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      cell_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(projection_ != nullptr);
      projection_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(quantization_distance_ != nullptr);
      quantization_distance_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(stacked_quantizers_config_ != nullptr);
      stacked_quantizers_config_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(fixed_point_lut_conversion_options_ != nullptr);
      fixed_point_lut_conversion_options_->Clear();
    }
  }
  min_number_machines_ = 0;
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&use_noise_shaped_training_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&use_residual_quantization_) -
        reinterpret_cast<char*>(&use_noise_shaped_training_)) + sizeof(use_residual_quantization_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&use_normalized_residual_quantization_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&use_global_topn_) -
        reinterpret_cast<char*>(&use_normalized_residual_quantization_)) + sizeof(use_global_topn_));
    min_cluster_size_ = 1;
    num_clusters_per_block_ = 256;
    max_sample_size_ = 2147483647;
    max_clustering_iterations_ = 10;
    clustering_convergence_tolerance_ = 1e-05f;
  }
  if (cached_has_bits & 0x1f000000u) {
    clustering_seed_ = 1;
    sampling_seed_ = 1;
    ram_gb_ = 4;
    num_cpus_ = 1;
    noise_shaping_threshold_ = std::numeric_limits<double>::quiet_NaN();
  }
  clear_SamplingFractionOrExpectedSize();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AsymmetricHasherConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .research_scann.ProjectionConfig projection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_projection(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_clusters_per_block = 2 [default = 256];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_num_clusters_per_block(&has_bits);
          num_clusters_per_block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_sample_size = 3 [default = 2147483647];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_max_sample_size(&has_bits);
          max_sample_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_clustering_iterations = 4 [default = 10];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_max_clustering_iterations(&has_bits);
          max_clustering_iterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float clustering_convergence_tolerance = 5 [default = 1e-05];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_clustering_convergence_tolerance(&has_bits);
          clustering_convergence_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional string centers_filename = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_centers_filename(), ptr, ctx, "research_scann.AsymmetricHasherConfig.centers_filename");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 min_number_machines = 7 [deprecated = true];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_min_number_machines(&has_bits);
          min_number_machines_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_single_machine_trainer = 8 [default = false, deprecated = true];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_use_single_machine_trainer(&has_bits);
          use_single_machine_trainer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 clustering_seed = 9 [default = 1];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_clustering_seed(&has_bits);
          clustering_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float sampling_fraction = 10 [default = 1];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          set_sampling_fraction(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 sampling_seed = 11 [default = 1];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_sampling_seed(&has_bits);
          sampling_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string mr_jobname_prefix = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_mr_jobname_prefix(), ptr, ctx, "research_scann.AsymmetricHasherConfig.mr_jobname_prefix");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string cell = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_cell(), ptr, ctx, "research_scann.AsymmetricHasherConfig.cell");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 ram_gb = 14 [default = 4];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_ram_gb(&has_bits);
          ram_gb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_cpus = 15 [default = 1];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_num_cpus(&has_bits);
          num_cpus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_per_leaf_partition_training = 17 [default = false];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_use_per_leaf_partition_training(&has_bits);
          use_per_leaf_partition_training_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.DistanceMeasureConfig quantization_distance = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr = ctx->ParseMessage(mutable_quantization_distance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float min_cluster_size = 19 [default = 1];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 157)) {
          _Internal::set_has_min_cluster_size(&has_bits);
          min_cluster_size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.AsymmetricHasherConfig.LookupType lookup_type = 20 [default = FLOAT];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::research_scann::AsymmetricHasherConfig_LookupType_IsValid(val))) {
            set_lookup_type(static_cast<::research_scann::AsymmetricHasherConfig_LookupType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool use_residual_quantization = 22 [default = false];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 176)) {
          _Internal::set_has_use_residual_quantization(&has_bits);
          use_residual_quantization_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.AsymmetricHasherConfig.QuantizationScheme quantization_scheme = 23 [default = PRODUCT];
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::research_scann::AsymmetricHasherConfig_QuantizationScheme_IsValid(val))) {
            set_quantization_scheme(static_cast<::research_scann::AsymmetricHasherConfig_QuantizationScheme>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(23, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .research_scann.StackedQuantizersConfig stacked_quantizers_config = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 194)) {
          ptr = ctx->ParseMessage(mutable_stacked_quantizers_config(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions fixed_point_lut_conversion_options = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 202)) {
          ptr = ctx->ParseMessage(mutable_fixed_point_lut_conversion_options(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float partition_level_confidence_interval_stdevs = 26 [default = 0, deprecated = true];
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 213)) {
          _Internal::set_has_partition_level_confidence_interval_stdevs(&has_bits);
          partition_level_confidence_interval_stdevs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 num_machines = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 216)) {
          _Internal::set_has_num_machines(&has_bits);
          num_machines_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double noise_shaping_threshold = 28 [default = nan];
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 225)) {
          _Internal::set_has_noise_shaping_threshold(&has_bits);
          noise_shaping_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional int32 expected_sample_size = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          set_expected_sample_size(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_noise_shaped_training = 30 [default = false];
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 240)) {
          _Internal::set_has_use_noise_shaped_training(&has_bits);
          use_noise_shaped_training_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_norm_biasing_correction = 31 [default = false];
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 248)) {
          _Internal::set_has_use_norm_biasing_correction(&has_bits);
          use_norm_biasing_correction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_normalized_residual_quantization = 32 [default = false];
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 0)) {
          _Internal::set_has_use_normalized_residual_quantization(&has_bits);
          use_normalized_residual_quantization_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_global_topn = 33 [default = false];
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_use_global_topn(&has_bits);
          use_global_topn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AsymmetricHasherConfig::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:research_scann.AsymmetricHasherConfig)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .research_scann.ProjectionConfig projection = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_projection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_clusters_per_block = 2 [default = 256];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_num_clusters_per_block(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_clusters_per_block_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_sample_size = 3 [default = 2147483647];
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_max_sample_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_sample_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_clustering_iterations = 4 [default = 10];
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_max_clustering_iterations(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_clustering_iterations_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float clustering_convergence_tolerance = 5 [default = 1e-05];
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (45 & 0xFF)) {
          _Internal::set_has_clustering_convergence_tolerance(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &clustering_convergence_tolerance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string centers_filename = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_centers_filename()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->centers_filename().data(), static_cast<int>(this->centers_filename().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "research_scann.AsymmetricHasherConfig.centers_filename");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 min_number_machines = 7 [deprecated = true];
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_min_number_machines(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &min_number_machines_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool use_single_machine_trainer = 8 [default = false, deprecated = true];
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_use_single_machine_trainer(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_single_machine_trainer_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 clustering_seed = 9 [default = 1];
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_clustering_seed(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &clustering_seed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float sampling_fraction = 10 [default = 1];
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (85 & 0xFF)) {
          clear_SamplingFractionOrExpectedSize();
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &SamplingFractionOrExpectedSize_.sampling_fraction_)));
          set_has_sampling_fraction();
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 sampling_seed = 11 [default = 1];
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          _Internal::set_has_sampling_seed(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &sampling_seed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string mr_jobname_prefix = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (98 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_mr_jobname_prefix()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->mr_jobname_prefix().data(), static_cast<int>(this->mr_jobname_prefix().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "research_scann.AsymmetricHasherConfig.mr_jobname_prefix");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string cell = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (106 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_cell()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->cell().data(), static_cast<int>(this->cell().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "research_scann.AsymmetricHasherConfig.cell");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 ram_gb = 14 [default = 4];
      case 14: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (112 & 0xFF)) {
          _Internal::set_has_ram_gb(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &ram_gb_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_cpus = 15 [default = 1];
      case 15: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (120 & 0xFF)) {
          _Internal::set_has_num_cpus(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_cpus_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool use_per_leaf_partition_training = 17 [default = false];
      case 17: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (136 & 0xFF)) {
          _Internal::set_has_use_per_leaf_partition_training(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_per_leaf_partition_training_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .research_scann.DistanceMeasureConfig quantization_distance = 18;
      case 18: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (146 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_quantization_distance()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float min_cluster_size = 19 [default = 1];
      case 19: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (157 & 0xFF)) {
          _Internal::set_has_min_cluster_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_cluster_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .research_scann.AsymmetricHasherConfig.LookupType lookup_type = 20 [default = FLOAT];
      case 20: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (160 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::research_scann::AsymmetricHasherConfig_LookupType_IsValid(value)) {
            set_lookup_type(static_cast< ::research_scann::AsymmetricHasherConfig_LookupType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                20, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool use_residual_quantization = 22 [default = false];
      case 22: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (176 & 0xFF)) {
          _Internal::set_has_use_residual_quantization(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_residual_quantization_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .research_scann.AsymmetricHasherConfig.QuantizationScheme quantization_scheme = 23 [default = PRODUCT];
      case 23: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (184 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::research_scann::AsymmetricHasherConfig_QuantizationScheme_IsValid(value)) {
            set_quantization_scheme(static_cast< ::research_scann::AsymmetricHasherConfig_QuantizationScheme >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                23, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .research_scann.StackedQuantizersConfig stacked_quantizers_config = 24;
      case 24: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (194 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_stacked_quantizers_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions fixed_point_lut_conversion_options = 25;
      case 25: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (202 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_fixed_point_lut_conversion_options()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float partition_level_confidence_interval_stdevs = 26 [default = 0, deprecated = true];
      case 26: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (213 & 0xFF)) {
          _Internal::set_has_partition_level_confidence_interval_stdevs(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &partition_level_confidence_interval_stdevs_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_machines = 27;
      case 27: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (216 & 0xFF)) {
          _Internal::set_has_num_machines(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_machines_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double noise_shaping_threshold = 28 [default = nan];
      case 28: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (225 & 0xFF)) {
          _Internal::set_has_noise_shaping_threshold(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &noise_shaping_threshold_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 expected_sample_size = 29;
      case 29: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (232 & 0xFF)) {
          clear_SamplingFractionOrExpectedSize();
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &SamplingFractionOrExpectedSize_.expected_sample_size_)));
          set_has_expected_sample_size();
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool use_noise_shaped_training = 30 [default = false];
      case 30: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (240 & 0xFF)) {
          _Internal::set_has_use_noise_shaped_training(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_noise_shaped_training_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool use_norm_biasing_correction = 31 [default = false];
      case 31: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (248 & 0xFF)) {
          _Internal::set_has_use_norm_biasing_correction(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_norm_biasing_correction_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool use_normalized_residual_quantization = 32 [default = false];
      case 32: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (256 & 0xFF)) {
          _Internal::set_has_use_normalized_residual_quantization(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_normalized_residual_quantization_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool use_global_topn = 33 [default = false];
      case 33: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (264 & 0xFF)) {
          _Internal::set_has_use_global_topn(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_global_topn_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:research_scann.AsymmetricHasherConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:research_scann.AsymmetricHasherConfig)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AsymmetricHasherConfig::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:research_scann.AsymmetricHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .research_scann.ProjectionConfig projection = 1;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::projection(this), output);
  }

  // optional int32 num_clusters_per_block = 2 [default = 256];
  if (cached_has_bits & 0x00100000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->num_clusters_per_block(), output);
  }

  // optional int32 max_sample_size = 3 [default = 2147483647];
  if (cached_has_bits & 0x00200000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->max_sample_size(), output);
  }

  // optional int32 max_clustering_iterations = 4 [default = 10];
  if (cached_has_bits & 0x00400000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->max_clustering_iterations(), output);
  }

  // optional float clustering_convergence_tolerance = 5 [default = 1e-05];
  if (cached_has_bits & 0x00800000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(5, this->clustering_convergence_tolerance(), output);
  }

  // optional string centers_filename = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->centers_filename().data(), static_cast<int>(this->centers_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "research_scann.AsymmetricHasherConfig.centers_filename");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->centers_filename(), output);
  }

  // optional int32 min_number_machines = 7 [deprecated = true];
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->min_number_machines(), output);
  }

  // optional bool use_single_machine_trainer = 8 [default = false, deprecated = true];
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(8, this->use_single_machine_trainer(), output);
  }

  // optional int32 clustering_seed = 9 [default = 1];
  if (cached_has_bits & 0x01000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(9, this->clustering_seed(), output);
  }

  // optional float sampling_fraction = 10 [default = 1];
  if (has_sampling_fraction()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(10, this->sampling_fraction(), output);
  }

  // optional int32 sampling_seed = 11 [default = 1];
  if (cached_has_bits & 0x02000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(11, this->sampling_seed(), output);
  }

  // optional string mr_jobname_prefix = 12;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mr_jobname_prefix().data(), static_cast<int>(this->mr_jobname_prefix().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "research_scann.AsymmetricHasherConfig.mr_jobname_prefix");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      12, this->mr_jobname_prefix(), output);
  }

  // optional string cell = 13;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->cell().data(), static_cast<int>(this->cell().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "research_scann.AsymmetricHasherConfig.cell");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      13, this->cell(), output);
  }

  // optional int32 ram_gb = 14 [default = 4];
  if (cached_has_bits & 0x04000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(14, this->ram_gb(), output);
  }

  // optional int32 num_cpus = 15 [default = 1];
  if (cached_has_bits & 0x08000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(15, this->num_cpus(), output);
  }

  // optional bool use_per_leaf_partition_training = 17 [default = false];
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(17, this->use_per_leaf_partition_training(), output);
  }

  // optional .research_scann.DistanceMeasureConfig quantization_distance = 18;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      18, _Internal::quantization_distance(this), output);
  }

  // optional float min_cluster_size = 19 [default = 1];
  if (cached_has_bits & 0x00080000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(19, this->min_cluster_size(), output);
  }

  // optional .research_scann.AsymmetricHasherConfig.LookupType lookup_type = 20 [default = FLOAT];
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      20, this->lookup_type(), output);
  }

  // optional bool use_residual_quantization = 22 [default = false];
  if (cached_has_bits & 0x00008000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(22, this->use_residual_quantization(), output);
  }

  // optional .research_scann.AsymmetricHasherConfig.QuantizationScheme quantization_scheme = 23 [default = PRODUCT];
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      23, this->quantization_scheme(), output);
  }

  // optional .research_scann.StackedQuantizersConfig stacked_quantizers_config = 24;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      24, _Internal::stacked_quantizers_config(this), output);
  }

  // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions fixed_point_lut_conversion_options = 25;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      25, _Internal::fixed_point_lut_conversion_options(this), output);
  }

  // optional float partition_level_confidence_interval_stdevs = 26 [default = 0, deprecated = true];
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(26, this->partition_level_confidence_interval_stdevs(), output);
  }

  // optional int32 num_machines = 27;
  if (cached_has_bits & 0x00004000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(27, this->num_machines(), output);
  }

  // optional double noise_shaping_threshold = 28 [default = nan];
  if (cached_has_bits & 0x10000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(28, this->noise_shaping_threshold(), output);
  }

  // optional int32 expected_sample_size = 29;
  if (has_expected_sample_size()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(29, this->expected_sample_size(), output);
  }

  // optional bool use_noise_shaped_training = 30 [default = false];
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(30, this->use_noise_shaped_training(), output);
  }

  // optional bool use_norm_biasing_correction = 31 [default = false];
  if (cached_has_bits & 0x00020000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(31, this->use_norm_biasing_correction(), output);
  }

  // optional bool use_normalized_residual_quantization = 32 [default = false];
  if (cached_has_bits & 0x00010000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(32, this->use_normalized_residual_quantization(), output);
  }

  // optional bool use_global_topn = 33 [default = false];
  if (cached_has_bits & 0x00040000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(33, this->use_global_topn(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:research_scann.AsymmetricHasherConfig)
}

::PROTOBUF_NAMESPACE_ID::uint8* AsymmetricHasherConfig::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:research_scann.AsymmetricHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .research_scann.ProjectionConfig projection = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::projection(this), target);
  }

  // optional int32 num_clusters_per_block = 2 [default = 256];
  if (cached_has_bits & 0x00100000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->num_clusters_per_block(), target);
  }

  // optional int32 max_sample_size = 3 [default = 2147483647];
  if (cached_has_bits & 0x00200000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->max_sample_size(), target);
  }

  // optional int32 max_clustering_iterations = 4 [default = 10];
  if (cached_has_bits & 0x00400000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->max_clustering_iterations(), target);
  }

  // optional float clustering_convergence_tolerance = 5 [default = 1e-05];
  if (cached_has_bits & 0x00800000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->clustering_convergence_tolerance(), target);
  }

  // optional string centers_filename = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->centers_filename().data(), static_cast<int>(this->centers_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "research_scann.AsymmetricHasherConfig.centers_filename");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        6, this->centers_filename(), target);
  }

  // optional int32 min_number_machines = 7 [deprecated = true];
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->min_number_machines(), target);
  }

  // optional bool use_single_machine_trainer = 8 [default = false, deprecated = true];
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->use_single_machine_trainer(), target);
  }

  // optional int32 clustering_seed = 9 [default = 1];
  if (cached_has_bits & 0x01000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->clustering_seed(), target);
  }

  // optional float sampling_fraction = 10 [default = 1];
  if (has_sampling_fraction()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->sampling_fraction(), target);
  }

  // optional int32 sampling_seed = 11 [default = 1];
  if (cached_has_bits & 0x02000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->sampling_seed(), target);
  }

  // optional string mr_jobname_prefix = 12;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mr_jobname_prefix().data(), static_cast<int>(this->mr_jobname_prefix().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "research_scann.AsymmetricHasherConfig.mr_jobname_prefix");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        12, this->mr_jobname_prefix(), target);
  }

  // optional string cell = 13;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->cell().data(), static_cast<int>(this->cell().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "research_scann.AsymmetricHasherConfig.cell");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        13, this->cell(), target);
  }

  // optional int32 ram_gb = 14 [default = 4];
  if (cached_has_bits & 0x04000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(14, this->ram_gb(), target);
  }

  // optional int32 num_cpus = 15 [default = 1];
  if (cached_has_bits & 0x08000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(15, this->num_cpus(), target);
  }

  // optional bool use_per_leaf_partition_training = 17 [default = false];
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->use_per_leaf_partition_training(), target);
  }

  // optional .research_scann.DistanceMeasureConfig quantization_distance = 18;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        18, _Internal::quantization_distance(this), target);
  }

  // optional float min_cluster_size = 19 [default = 1];
  if (cached_has_bits & 0x00080000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(19, this->min_cluster_size(), target);
  }

  // optional .research_scann.AsymmetricHasherConfig.LookupType lookup_type = 20 [default = FLOAT];
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      20, this->lookup_type(), target);
  }

  // optional bool use_residual_quantization = 22 [default = false];
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(22, this->use_residual_quantization(), target);
  }

  // optional .research_scann.AsymmetricHasherConfig.QuantizationScheme quantization_scheme = 23 [default = PRODUCT];
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      23, this->quantization_scheme(), target);
  }

  // optional .research_scann.StackedQuantizersConfig stacked_quantizers_config = 24;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        24, _Internal::stacked_quantizers_config(this), target);
  }

  // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions fixed_point_lut_conversion_options = 25;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        25, _Internal::fixed_point_lut_conversion_options(this), target);
  }

  // optional float partition_level_confidence_interval_stdevs = 26 [default = 0, deprecated = true];
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(26, this->partition_level_confidence_interval_stdevs(), target);
  }

  // optional int32 num_machines = 27;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(27, this->num_machines(), target);
  }

  // optional double noise_shaping_threshold = 28 [default = nan];
  if (cached_has_bits & 0x10000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(28, this->noise_shaping_threshold(), target);
  }

  // optional int32 expected_sample_size = 29;
  if (has_expected_sample_size()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(29, this->expected_sample_size(), target);
  }

  // optional bool use_noise_shaped_training = 30 [default = false];
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(30, this->use_noise_shaped_training(), target);
  }

  // optional bool use_norm_biasing_correction = 31 [default = false];
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(31, this->use_norm_biasing_correction(), target);
  }

  // optional bool use_normalized_residual_quantization = 32 [default = false];
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(32, this->use_normalized_residual_quantization(), target);
  }

  // optional bool use_global_topn = 33 [default = false];
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(33, this->use_global_topn(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:research_scann.AsymmetricHasherConfig)
  return target;
}

size_t AsymmetricHasherConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:research_scann.AsymmetricHasherConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string centers_filename = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->centers_filename());
    }

    // optional string mr_jobname_prefix = 12;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->mr_jobname_prefix());
    }

    // optional string cell = 13;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->cell());
    }

    // optional .research_scann.ProjectionConfig projection = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *projection_);
    }

    // optional .research_scann.DistanceMeasureConfig quantization_distance = 18;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *quantization_distance_);
    }

    // optional .research_scann.StackedQuantizersConfig stacked_quantizers_config = 24;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *stacked_quantizers_config_);
    }

    // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions fixed_point_lut_conversion_options = 25;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *fixed_point_lut_conversion_options_);
    }

    // optional int32 min_number_machines = 7 [deprecated = true];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->min_number_machines());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool use_noise_shaped_training = 30 [default = false];
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 1;
    }

    // optional bool use_per_leaf_partition_training = 17 [default = false];
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 1;
    }

    // optional bool use_single_machine_trainer = 8 [default = false, deprecated = true];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional .research_scann.AsymmetricHasherConfig.LookupType lookup_type = 20 [default = FLOAT];
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->lookup_type());
    }

    // optional .research_scann.AsymmetricHasherConfig.QuantizationScheme quantization_scheme = 23 [default = PRODUCT];
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->quantization_scheme());
    }

    // optional float partition_level_confidence_interval_stdevs = 26 [default = 0, deprecated = true];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 4;
    }

    // optional int32 num_machines = 27;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_machines());
    }

    // optional bool use_residual_quantization = 22 [default = false];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool use_normalized_residual_quantization = 32 [default = false];
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool use_norm_biasing_correction = 31 [default = false];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool use_global_topn = 33 [default = false];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional float min_cluster_size = 19 [default = 1];
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 4;
    }

    // optional int32 num_clusters_per_block = 2 [default = 256];
    if (cached_has_bits & 0x00100000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_clusters_per_block());
    }

    // optional int32 max_sample_size = 3 [default = 2147483647];
    if (cached_has_bits & 0x00200000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->max_sample_size());
    }

    // optional int32 max_clustering_iterations = 4 [default = 10];
    if (cached_has_bits & 0x00400000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->max_clustering_iterations());
    }

    // optional float clustering_convergence_tolerance = 5 [default = 1e-05];
    if (cached_has_bits & 0x00800000u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x1f000000u) {
    // optional int32 clustering_seed = 9 [default = 1];
    if (cached_has_bits & 0x01000000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->clustering_seed());
    }

    // optional int32 sampling_seed = 11 [default = 1];
    if (cached_has_bits & 0x02000000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->sampling_seed());
    }

    // optional int32 ram_gb = 14 [default = 4];
    if (cached_has_bits & 0x04000000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->ram_gb());
    }

    // optional int32 num_cpus = 15 [default = 1];
    if (cached_has_bits & 0x08000000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_cpus());
    }

    // optional double noise_shaping_threshold = 28 [default = nan];
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 8;
    }

  }
  switch (SamplingFractionOrExpectedSize_case()) {
    // optional float sampling_fraction = 10 [default = 1];
    case kSamplingFraction: {
      total_size += 1 + 4;
      break;
    }
    // optional int32 expected_sample_size = 29;
    case kExpectedSampleSize: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->expected_sample_size());
      break;
    }
    case SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET: {
      break;
    }
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AsymmetricHasherConfig::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:research_scann.AsymmetricHasherConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const AsymmetricHasherConfig* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AsymmetricHasherConfig>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:research_scann.AsymmetricHasherConfig)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:research_scann.AsymmetricHasherConfig)
    MergeFrom(*source);
  }
}

void AsymmetricHasherConfig::MergeFrom(const AsymmetricHasherConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:research_scann.AsymmetricHasherConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      centers_filename_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.centers_filename_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      mr_jobname_prefix_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.mr_jobname_prefix_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      cell_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.cell_);
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_projection()->::research_scann::ProjectionConfig::MergeFrom(from.projection());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_quantization_distance()->::research_scann::DistanceMeasureConfig::MergeFrom(from.quantization_distance());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_stacked_quantizers_config()->::research_scann::StackedQuantizersConfig::MergeFrom(from.stacked_quantizers_config());
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_fixed_point_lut_conversion_options()->::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions::MergeFrom(from.fixed_point_lut_conversion_options());
    }
    if (cached_has_bits & 0x00000080u) {
      min_number_machines_ = from.min_number_machines_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      use_noise_shaped_training_ = from.use_noise_shaped_training_;
    }
    if (cached_has_bits & 0x00000200u) {
      use_per_leaf_partition_training_ = from.use_per_leaf_partition_training_;
    }
    if (cached_has_bits & 0x00000400u) {
      use_single_machine_trainer_ = from.use_single_machine_trainer_;
    }
    if (cached_has_bits & 0x00000800u) {
      lookup_type_ = from.lookup_type_;
    }
    if (cached_has_bits & 0x00001000u) {
      quantization_scheme_ = from.quantization_scheme_;
    }
    if (cached_has_bits & 0x00002000u) {
      partition_level_confidence_interval_stdevs_ = from.partition_level_confidence_interval_stdevs_;
    }
    if (cached_has_bits & 0x00004000u) {
      num_machines_ = from.num_machines_;
    }
    if (cached_has_bits & 0x00008000u) {
      use_residual_quantization_ = from.use_residual_quantization_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      use_normalized_residual_quantization_ = from.use_normalized_residual_quantization_;
    }
    if (cached_has_bits & 0x00020000u) {
      use_norm_biasing_correction_ = from.use_norm_biasing_correction_;
    }
    if (cached_has_bits & 0x00040000u) {
      use_global_topn_ = from.use_global_topn_;
    }
    if (cached_has_bits & 0x00080000u) {
      min_cluster_size_ = from.min_cluster_size_;
    }
    if (cached_has_bits & 0x00100000u) {
      num_clusters_per_block_ = from.num_clusters_per_block_;
    }
    if (cached_has_bits & 0x00200000u) {
      max_sample_size_ = from.max_sample_size_;
    }
    if (cached_has_bits & 0x00400000u) {
      max_clustering_iterations_ = from.max_clustering_iterations_;
    }
    if (cached_has_bits & 0x00800000u) {
      clustering_convergence_tolerance_ = from.clustering_convergence_tolerance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x1f000000u) {
    if (cached_has_bits & 0x01000000u) {
      clustering_seed_ = from.clustering_seed_;
    }
    if (cached_has_bits & 0x02000000u) {
      sampling_seed_ = from.sampling_seed_;
    }
    if (cached_has_bits & 0x04000000u) {
      ram_gb_ = from.ram_gb_;
    }
    if (cached_has_bits & 0x08000000u) {
      num_cpus_ = from.num_cpus_;
    }
    if (cached_has_bits & 0x10000000u) {
      noise_shaping_threshold_ = from.noise_shaping_threshold_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.SamplingFractionOrExpectedSize_case()) {
    case kSamplingFraction: {
      set_sampling_fraction(from.sampling_fraction());
      break;
    }
    case kExpectedSampleSize: {
      set_expected_sample_size(from.expected_sample_size());
      break;
    }
    case SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET: {
      break;
    }
  }
}

void AsymmetricHasherConfig::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:research_scann.AsymmetricHasherConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AsymmetricHasherConfig::CopyFrom(const AsymmetricHasherConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:research_scann.AsymmetricHasherConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AsymmetricHasherConfig::IsInitialized() const {
  if (has_projection()) {
    if (!this->projection_->IsInitialized()) return false;
  }
  return true;
}

void AsymmetricHasherConfig::InternalSwap(AsymmetricHasherConfig* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  centers_filename_.Swap(&other->centers_filename_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  mr_jobname_prefix_.Swap(&other->mr_jobname_prefix_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  cell_.Swap(&other->cell_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(projection_, other->projection_);
  swap(quantization_distance_, other->quantization_distance_);
  swap(stacked_quantizers_config_, other->stacked_quantizers_config_);
  swap(fixed_point_lut_conversion_options_, other->fixed_point_lut_conversion_options_);
  swap(min_number_machines_, other->min_number_machines_);
  swap(use_noise_shaped_training_, other->use_noise_shaped_training_);
  swap(use_per_leaf_partition_training_, other->use_per_leaf_partition_training_);
  swap(use_single_machine_trainer_, other->use_single_machine_trainer_);
  swap(lookup_type_, other->lookup_type_);
  swap(quantization_scheme_, other->quantization_scheme_);
  swap(partition_level_confidence_interval_stdevs_, other->partition_level_confidence_interval_stdevs_);
  swap(num_machines_, other->num_machines_);
  swap(use_residual_quantization_, other->use_residual_quantization_);
  swap(use_normalized_residual_quantization_, other->use_normalized_residual_quantization_);
  swap(use_norm_biasing_correction_, other->use_norm_biasing_correction_);
  swap(use_global_topn_, other->use_global_topn_);
  swap(min_cluster_size_, other->min_cluster_size_);
  swap(num_clusters_per_block_, other->num_clusters_per_block_);
  swap(max_sample_size_, other->max_sample_size_);
  swap(max_clustering_iterations_, other->max_clustering_iterations_);
  swap(clustering_convergence_tolerance_, other->clustering_convergence_tolerance_);
  swap(clustering_seed_, other->clustering_seed_);
  swap(sampling_seed_, other->sampling_seed_);
  swap(ram_gb_, other->ram_gb_);
  swap(num_cpus_, other->num_cpus_);
  swap(noise_shaping_threshold_, other->noise_shaping_threshold_);
  swap(SamplingFractionOrExpectedSize_, other->SamplingFractionOrExpectedSize_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata AsymmetricHasherConfig::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MinHasherConfig::InitAsDefaultInstance() {
}
class MinHasherConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<MinHasherConfig>()._has_bits_);
  static void set_has_config_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_sketches(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_hashes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_bits_per_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MinHasherConfig::MinHasherConfig()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:research_scann.MinHasherConfig)
}
MinHasherConfig::MinHasherConfig(const MinHasherConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      seeds_(from.seeds_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&config_id_, &from.config_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_bits_per_hash_) -
    reinterpret_cast<char*>(&config_id_)) + sizeof(num_bits_per_hash_));
  // @@protoc_insertion_point(copy_constructor:research_scann.MinHasherConfig)
}

void MinHasherConfig::SharedCtor() {
  ::memset(&config_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_bits_per_hash_) -
      reinterpret_cast<char*>(&config_id_)) + sizeof(num_bits_per_hash_));
}

MinHasherConfig::~MinHasherConfig() {
  // @@protoc_insertion_point(destructor:research_scann.MinHasherConfig)
  SharedDtor();
}

void MinHasherConfig::SharedDtor() {
}

void MinHasherConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MinHasherConfig& MinHasherConfig::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MinHasherConfig_scann_2fproto_2fhash_2eproto.base);
  return *internal_default_instance();
}


void MinHasherConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:research_scann.MinHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  seeds_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&config_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_bits_per_hash_) -
        reinterpret_cast<char*>(&config_id_)) + sizeof(num_bits_per_hash_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MinHasherConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 config_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_config_id(&has_bits);
          config_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_sketches = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_num_sketches(&has_bits);
          num_sketches_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_hashes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_num_hashes(&has_bits);
          num_hashes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int64 seeds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_seeds(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 32);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(mutable_seeds(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_bits_per_hash = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_num_bits_per_hash(&has_bits);
          num_bits_per_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MinHasherConfig::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:research_scann.MinHasherConfig)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 config_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_config_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &config_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_sketches = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_num_sketches(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_sketches_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_hashes = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_num_hashes(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_hashes_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int64 seeds = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 1, 32u, input, this->mutable_seeds())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_seeds())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_bits_per_hash = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_num_bits_per_hash(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_bits_per_hash_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:research_scann.MinHasherConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:research_scann.MinHasherConfig)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MinHasherConfig::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:research_scann.MinHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 config_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->config_id(), output);
  }

  // optional int32 num_sketches = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->num_sketches(), output);
  }

  // optional int32 num_hashes = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->num_hashes(), output);
  }

  // repeated int64 seeds = 4;
  for (int i = 0, n = this->seeds_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(
      4, this->seeds(i), output);
  }

  // optional int32 num_bits_per_hash = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->num_bits_per_hash(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:research_scann.MinHasherConfig)
}

::PROTOBUF_NAMESPACE_ID::uint8* MinHasherConfig::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:research_scann.MinHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 config_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->config_id(), target);
  }

  // optional int32 num_sketches = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->num_sketches(), target);
  }

  // optional int32 num_hashes = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->num_hashes(), target);
  }

  // repeated int64 seeds = 4;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteInt64ToArray(4, this->seeds_, target);

  // optional int32 num_bits_per_hash = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->num_bits_per_hash(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:research_scann.MinHasherConfig)
  return target;
}

size_t MinHasherConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:research_scann.MinHasherConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 seeds = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->seeds_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->seeds_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 config_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->config_id());
    }

    // optional int32 num_sketches = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_sketches());
    }

    // optional int32 num_hashes = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_hashes());
    }

    // optional int32 num_bits_per_hash = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_bits_per_hash());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MinHasherConfig::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:research_scann.MinHasherConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const MinHasherConfig* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MinHasherConfig>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:research_scann.MinHasherConfig)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:research_scann.MinHasherConfig)
    MergeFrom(*source);
  }
}

void MinHasherConfig::MergeFrom(const MinHasherConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:research_scann.MinHasherConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  seeds_.MergeFrom(from.seeds_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      config_id_ = from.config_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_sketches_ = from.num_sketches_;
    }
    if (cached_has_bits & 0x00000004u) {
      num_hashes_ = from.num_hashes_;
    }
    if (cached_has_bits & 0x00000008u) {
      num_bits_per_hash_ = from.num_bits_per_hash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MinHasherConfig::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:research_scann.MinHasherConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MinHasherConfig::CopyFrom(const MinHasherConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:research_scann.MinHasherConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MinHasherConfig::IsInitialized() const {
  return true;
}

void MinHasherConfig::InternalSwap(MinHasherConfig* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  seeds_.InternalSwap(&other->seeds_);
  swap(config_id_, other->config_id_);
  swap(num_sketches_, other->num_sketches_);
  swap(num_hashes_, other->num_hashes_);
  swap(num_bits_per_hash_, other->num_bits_per_hash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MinHasherConfig::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void BitSamplingHasherConfig::InitAsDefaultInstance() {
}
class BitSamplingHasherConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<BitSamplingHasherConfig>()._has_bits_);
  static void set_has_num_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_use_entropy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BitSamplingHasherConfig::BitSamplingHasherConfig()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:research_scann.BitSamplingHasherConfig)
}
BitSamplingHasherConfig::BitSamplingHasherConfig(const BitSamplingHasherConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&use_entropy_, &from.use_entropy_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_bits_) -
    reinterpret_cast<char*>(&use_entropy_)) + sizeof(num_bits_));
  // @@protoc_insertion_point(copy_constructor:research_scann.BitSamplingHasherConfig)
}

void BitSamplingHasherConfig::SharedCtor() {
  use_entropy_ = false;
  num_bits_ = 3;
}

BitSamplingHasherConfig::~BitSamplingHasherConfig() {
  // @@protoc_insertion_point(destructor:research_scann.BitSamplingHasherConfig)
  SharedDtor();
}

void BitSamplingHasherConfig::SharedDtor() {
}

void BitSamplingHasherConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BitSamplingHasherConfig& BitSamplingHasherConfig::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BitSamplingHasherConfig_scann_2fproto_2fhash_2eproto.base);
  return *internal_default_instance();
}


void BitSamplingHasherConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:research_scann.BitSamplingHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    use_entropy_ = false;
    num_bits_ = 3;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* BitSamplingHasherConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 num_bits = 1 [default = 3];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_num_bits(&has_bits);
          num_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_entropy = 2 [default = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_use_entropy(&has_bits);
          use_entropy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool BitSamplingHasherConfig::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:research_scann.BitSamplingHasherConfig)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 num_bits = 1 [default = 3];
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_num_bits(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_bits_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool use_entropy = 2 [default = false];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_use_entropy(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_entropy_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:research_scann.BitSamplingHasherConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:research_scann.BitSamplingHasherConfig)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void BitSamplingHasherConfig::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:research_scann.BitSamplingHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 num_bits = 1 [default = 3];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->num_bits(), output);
  }

  // optional bool use_entropy = 2 [default = false];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->use_entropy(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:research_scann.BitSamplingHasherConfig)
}

::PROTOBUF_NAMESPACE_ID::uint8* BitSamplingHasherConfig::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:research_scann.BitSamplingHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 num_bits = 1 [default = 3];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->num_bits(), target);
  }

  // optional bool use_entropy = 2 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->use_entropy(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:research_scann.BitSamplingHasherConfig)
  return target;
}

size_t BitSamplingHasherConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:research_scann.BitSamplingHasherConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool use_entropy = 2 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int32 num_bits = 1 [default = 3];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_bits());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BitSamplingHasherConfig::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:research_scann.BitSamplingHasherConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const BitSamplingHasherConfig* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BitSamplingHasherConfig>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:research_scann.BitSamplingHasherConfig)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:research_scann.BitSamplingHasherConfig)
    MergeFrom(*source);
  }
}

void BitSamplingHasherConfig::MergeFrom(const BitSamplingHasherConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:research_scann.BitSamplingHasherConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      use_entropy_ = from.use_entropy_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_bits_ = from.num_bits_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BitSamplingHasherConfig::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:research_scann.BitSamplingHasherConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BitSamplingHasherConfig::CopyFrom(const BitSamplingHasherConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:research_scann.BitSamplingHasherConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BitSamplingHasherConfig::IsInitialized() const {
  return true;
}

void BitSamplingHasherConfig::InternalSwap(BitSamplingHasherConfig* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(use_entropy_, other->use_entropy_);
  swap(num_bits_, other->num_bits_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BitSamplingHasherConfig::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void PcaHasherConfig::InitAsDefaultInstance() {
}
class PcaHasherConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<PcaHasherConfig>()._has_bits_);
  static void set_has_rotate_projections(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sampling_fraction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sampling_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_sample_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_learn_projections(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_num_iteration(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_iteration_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

PcaHasherConfig::PcaHasherConfig()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:research_scann.PcaHasherConfig)
}
PcaHasherConfig::PcaHasherConfig(const PcaHasherConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&rotate_projections_, &from.rotate_projections_,
    static_cast<size_t>(reinterpret_cast<char*>(&iteration_tolerance_) -
    reinterpret_cast<char*>(&rotate_projections_)) + sizeof(iteration_tolerance_));
  // @@protoc_insertion_point(copy_constructor:research_scann.PcaHasherConfig)
}

void PcaHasherConfig::SharedCtor() {
  ::memset(&rotate_projections_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_sample_size_) -
      reinterpret_cast<char*>(&rotate_projections_)) + sizeof(max_sample_size_));
  sampling_fraction_ = 1;
  sampling_seed_ = 1;
  max_num_iteration_ = 40;
  iteration_tolerance_ = 1e-05f;
}

PcaHasherConfig::~PcaHasherConfig() {
  // @@protoc_insertion_point(destructor:research_scann.PcaHasherConfig)
  SharedDtor();
}

void PcaHasherConfig::SharedDtor() {
}

void PcaHasherConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PcaHasherConfig& PcaHasherConfig::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PcaHasherConfig_scann_2fproto_2fhash_2eproto.base);
  return *internal_default_instance();
}


void PcaHasherConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:research_scann.PcaHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&rotate_projections_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_sample_size_) -
        reinterpret_cast<char*>(&rotate_projections_)) + sizeof(max_sample_size_));
    sampling_fraction_ = 1;
    sampling_seed_ = 1;
    max_num_iteration_ = 40;
    iteration_tolerance_ = 1e-05f;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PcaHasherConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool rotate_projections = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_rotate_projections(&has_bits);
          rotate_projections_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float sampling_fraction = 2 [default = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_sampling_fraction(&has_bits);
          sampling_fraction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 sampling_seed = 3 [default = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_sampling_seed(&has_bits);
          sampling_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_sample_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_max_sample_size(&has_bits);
          max_sample_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool learn_projections = 5 [default = false];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_learn_projections(&has_bits);
          learn_projections_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_num_iteration = 6 [default = 40];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_max_num_iteration(&has_bits);
          max_num_iteration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float iteration_tolerance = 7 [default = 1e-05];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_iteration_tolerance(&has_bits);
          iteration_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PcaHasherConfig::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:research_scann.PcaHasherConfig)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool rotate_projections = 1 [default = false];
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_rotate_projections(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &rotate_projections_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float sampling_fraction = 2 [default = 1];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (21 & 0xFF)) {
          _Internal::set_has_sampling_fraction(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sampling_fraction_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 sampling_seed = 3 [default = 1];
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_sampling_seed(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &sampling_seed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_sample_size = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_max_sample_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_sample_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool learn_projections = 5 [default = false];
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_learn_projections(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &learn_projections_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_num_iteration = 6 [default = 40];
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_max_num_iteration(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_num_iteration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float iteration_tolerance = 7 [default = 1e-05];
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (61 & 0xFF)) {
          _Internal::set_has_iteration_tolerance(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &iteration_tolerance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:research_scann.PcaHasherConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:research_scann.PcaHasherConfig)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PcaHasherConfig::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:research_scann.PcaHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool rotate_projections = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(1, this->rotate_projections(), output);
  }

  // optional float sampling_fraction = 2 [default = 1];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(2, this->sampling_fraction(), output);
  }

  // optional int32 sampling_seed = 3 [default = 1];
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->sampling_seed(), output);
  }

  // optional int32 max_sample_size = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->max_sample_size(), output);
  }

  // optional bool learn_projections = 5 [default = false];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(5, this->learn_projections(), output);
  }

  // optional int32 max_num_iteration = 6 [default = 40];
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->max_num_iteration(), output);
  }

  // optional float iteration_tolerance = 7 [default = 1e-05];
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(7, this->iteration_tolerance(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:research_scann.PcaHasherConfig)
}

::PROTOBUF_NAMESPACE_ID::uint8* PcaHasherConfig::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:research_scann.PcaHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool rotate_projections = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->rotate_projections(), target);
  }

  // optional float sampling_fraction = 2 [default = 1];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->sampling_fraction(), target);
  }

  // optional int32 sampling_seed = 3 [default = 1];
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->sampling_seed(), target);
  }

  // optional int32 max_sample_size = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->max_sample_size(), target);
  }

  // optional bool learn_projections = 5 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->learn_projections(), target);
  }

  // optional int32 max_num_iteration = 6 [default = 40];
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->max_num_iteration(), target);
  }

  // optional float iteration_tolerance = 7 [default = 1e-05];
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->iteration_tolerance(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:research_scann.PcaHasherConfig)
  return target;
}

size_t PcaHasherConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:research_scann.PcaHasherConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bool rotate_projections = 1 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool learn_projections = 5 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional int32 max_sample_size = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->max_sample_size());
    }

    // optional float sampling_fraction = 2 [default = 1];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional int32 sampling_seed = 3 [default = 1];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->sampling_seed());
    }

    // optional int32 max_num_iteration = 6 [default = 40];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->max_num_iteration());
    }

    // optional float iteration_tolerance = 7 [default = 1e-05];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PcaHasherConfig::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:research_scann.PcaHasherConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const PcaHasherConfig* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PcaHasherConfig>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:research_scann.PcaHasherConfig)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:research_scann.PcaHasherConfig)
    MergeFrom(*source);
  }
}

void PcaHasherConfig::MergeFrom(const PcaHasherConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:research_scann.PcaHasherConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      rotate_projections_ = from.rotate_projections_;
    }
    if (cached_has_bits & 0x00000002u) {
      learn_projections_ = from.learn_projections_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_sample_size_ = from.max_sample_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      sampling_fraction_ = from.sampling_fraction_;
    }
    if (cached_has_bits & 0x00000010u) {
      sampling_seed_ = from.sampling_seed_;
    }
    if (cached_has_bits & 0x00000020u) {
      max_num_iteration_ = from.max_num_iteration_;
    }
    if (cached_has_bits & 0x00000040u) {
      iteration_tolerance_ = from.iteration_tolerance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PcaHasherConfig::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:research_scann.PcaHasherConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PcaHasherConfig::CopyFrom(const PcaHasherConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:research_scann.PcaHasherConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PcaHasherConfig::IsInitialized() const {
  return true;
}

void PcaHasherConfig::InternalSwap(PcaHasherConfig* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(rotate_projections_, other->rotate_projections_);
  swap(learn_projections_, other->learn_projections_);
  swap(max_sample_size_, other->max_sample_size_);
  swap(sampling_fraction_, other->sampling_fraction_);
  swap(sampling_seed_, other->sampling_seed_);
  swap(max_num_iteration_, other->max_num_iteration_);
  swap(iteration_tolerance_, other->iteration_tolerance_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PcaHasherConfig::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void BncHasherConfig::InitAsDefaultInstance() {
}
class BncHasherConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<BncHasherConfig>()._has_bits_);
  static void set_has_compression_ratio(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gamma(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_learning_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_batch_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_num_phase1_iterations(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_num_phase2_iterations(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_sampling_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_num_cpus(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BncHasherConfig::BncHasherConfig()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:research_scann.BncHasherConfig)
}
BncHasherConfig::BncHasherConfig(const BncHasherConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&compression_ratio_, &from.compression_ratio_,
    static_cast<size_t>(reinterpret_cast<char*>(&sampling_seed_) -
    reinterpret_cast<char*>(&compression_ratio_)) + sizeof(sampling_seed_));
  // @@protoc_insertion_point(copy_constructor:research_scann.BncHasherConfig)
}

void BncHasherConfig::SharedCtor() {
  compression_ratio_ = 0;
  num_cpus_ = 1;
  gamma_ = 10;
  learning_rate_ = 0.1f;
  batch_size_ = 128;
  num_phase1_iterations_ = 50;
  num_phase2_iterations_ = 100;
  sampling_seed_ = 1;
}

BncHasherConfig::~BncHasherConfig() {
  // @@protoc_insertion_point(destructor:research_scann.BncHasherConfig)
  SharedDtor();
}

void BncHasherConfig::SharedDtor() {
}

void BncHasherConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BncHasherConfig& BncHasherConfig::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BncHasherConfig_scann_2fproto_2fhash_2eproto.base);
  return *internal_default_instance();
}


void BncHasherConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:research_scann.BncHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    compression_ratio_ = 0;
    num_cpus_ = 1;
    gamma_ = 10;
    learning_rate_ = 0.1f;
    batch_size_ = 128;
    num_phase1_iterations_ = 50;
    num_phase2_iterations_ = 100;
    sampling_seed_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* BncHasherConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float compression_ratio = 1 [default = 0];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_compression_ratio(&has_bits);
          compression_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float gamma = 2 [default = 10];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_gamma(&has_bits);
          gamma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float learning_rate = 3 [default = 0.1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_learning_rate(&has_bits);
          learning_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 batch_size = 4 [default = 128];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_batch_size(&has_bits);
          batch_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_phase1_iterations = 5 [default = 50];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_num_phase1_iterations(&has_bits);
          num_phase1_iterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_phase2_iterations = 6 [default = 100];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_num_phase2_iterations(&has_bits);
          num_phase2_iterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 sampling_seed = 7 [default = 1];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_sampling_seed(&has_bits);
          sampling_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_cpus = 8 [default = 1];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_num_cpus(&has_bits);
          num_cpus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool BncHasherConfig::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:research_scann.BncHasherConfig)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float compression_ratio = 1 [default = 0];
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (13 & 0xFF)) {
          _Internal::set_has_compression_ratio(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &compression_ratio_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float gamma = 2 [default = 10];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (21 & 0xFF)) {
          _Internal::set_has_gamma(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gamma_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float learning_rate = 3 [default = 0.1];
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (29 & 0xFF)) {
          _Internal::set_has_learning_rate(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &learning_rate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 batch_size = 4 [default = 128];
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_batch_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &batch_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_phase1_iterations = 5 [default = 50];
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_num_phase1_iterations(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_phase1_iterations_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_phase2_iterations = 6 [default = 100];
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_num_phase2_iterations(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_phase2_iterations_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 sampling_seed = 7 [default = 1];
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          _Internal::set_has_sampling_seed(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &sampling_seed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_cpus = 8 [default = 1];
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          _Internal::set_has_num_cpus(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_cpus_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:research_scann.BncHasherConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:research_scann.BncHasherConfig)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void BncHasherConfig::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:research_scann.BncHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float compression_ratio = 1 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(1, this->compression_ratio(), output);
  }

  // optional float gamma = 2 [default = 10];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(2, this->gamma(), output);
  }

  // optional float learning_rate = 3 [default = 0.1];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(3, this->learning_rate(), output);
  }

  // optional int32 batch_size = 4 [default = 128];
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->batch_size(), output);
  }

  // optional int32 num_phase1_iterations = 5 [default = 50];
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->num_phase1_iterations(), output);
  }

  // optional int32 num_phase2_iterations = 6 [default = 100];
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->num_phase2_iterations(), output);
  }

  // optional int32 sampling_seed = 7 [default = 1];
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(7, this->sampling_seed(), output);
  }

  // optional int32 num_cpus = 8 [default = 1];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(8, this->num_cpus(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:research_scann.BncHasherConfig)
}

::PROTOBUF_NAMESPACE_ID::uint8* BncHasherConfig::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:research_scann.BncHasherConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float compression_ratio = 1 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->compression_ratio(), target);
  }

  // optional float gamma = 2 [default = 10];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->gamma(), target);
  }

  // optional float learning_rate = 3 [default = 0.1];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->learning_rate(), target);
  }

  // optional int32 batch_size = 4 [default = 128];
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->batch_size(), target);
  }

  // optional int32 num_phase1_iterations = 5 [default = 50];
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->num_phase1_iterations(), target);
  }

  // optional int32 num_phase2_iterations = 6 [default = 100];
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->num_phase2_iterations(), target);
  }

  // optional int32 sampling_seed = 7 [default = 1];
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->sampling_seed(), target);
  }

  // optional int32 num_cpus = 8 [default = 1];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->num_cpus(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:research_scann.BncHasherConfig)
  return target;
}

size_t BncHasherConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:research_scann.BncHasherConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float compression_ratio = 1 [default = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional int32 num_cpus = 8 [default = 1];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_cpus());
    }

    // optional float gamma = 2 [default = 10];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float learning_rate = 3 [default = 0.1];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional int32 batch_size = 4 [default = 128];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->batch_size());
    }

    // optional int32 num_phase1_iterations = 5 [default = 50];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_phase1_iterations());
    }

    // optional int32 num_phase2_iterations = 6 [default = 100];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->num_phase2_iterations());
    }

    // optional int32 sampling_seed = 7 [default = 1];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->sampling_seed());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BncHasherConfig::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:research_scann.BncHasherConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const BncHasherConfig* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BncHasherConfig>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:research_scann.BncHasherConfig)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:research_scann.BncHasherConfig)
    MergeFrom(*source);
  }
}

void BncHasherConfig::MergeFrom(const BncHasherConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:research_scann.BncHasherConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      compression_ratio_ = from.compression_ratio_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_cpus_ = from.num_cpus_;
    }
    if (cached_has_bits & 0x00000004u) {
      gamma_ = from.gamma_;
    }
    if (cached_has_bits & 0x00000008u) {
      learning_rate_ = from.learning_rate_;
    }
    if (cached_has_bits & 0x00000010u) {
      batch_size_ = from.batch_size_;
    }
    if (cached_has_bits & 0x00000020u) {
      num_phase1_iterations_ = from.num_phase1_iterations_;
    }
    if (cached_has_bits & 0x00000040u) {
      num_phase2_iterations_ = from.num_phase2_iterations_;
    }
    if (cached_has_bits & 0x00000080u) {
      sampling_seed_ = from.sampling_seed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BncHasherConfig::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:research_scann.BncHasherConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BncHasherConfig::CopyFrom(const BncHasherConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:research_scann.BncHasherConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BncHasherConfig::IsInitialized() const {
  return true;
}

void BncHasherConfig::InternalSwap(BncHasherConfig* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(compression_ratio_, other->compression_ratio_);
  swap(num_cpus_, other->num_cpus_);
  swap(gamma_, other->gamma_);
  swap(learning_rate_, other->learning_rate_);
  swap(batch_size_, other->batch_size_);
  swap(num_phase1_iterations_, other->num_phase1_iterations_);
  swap(num_phase2_iterations_, other->num_phase2_iterations_);
  swap(sampling_seed_, other->sampling_seed_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BncHasherConfig::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StackedQuantizersConfig::InitAsDefaultInstance() {
}
class StackedQuantizersConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<StackedQuantizersConfig>()._has_bits_);
  static void set_has_min_num_iterations(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_num_iterations(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_relative_improvement_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

StackedQuantizersConfig::StackedQuantizersConfig()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:research_scann.StackedQuantizersConfig)
}
StackedQuantizersConfig::StackedQuantizersConfig(const StackedQuantizersConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&relative_improvement_threshold_, &from.relative_improvement_threshold_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_num_iterations_) -
    reinterpret_cast<char*>(&relative_improvement_threshold_)) + sizeof(max_num_iterations_));
  // @@protoc_insertion_point(copy_constructor:research_scann.StackedQuantizersConfig)
}

void StackedQuantizersConfig::SharedCtor() {
  relative_improvement_threshold_ = 0.001f;
  min_num_iterations_ = 3;
  max_num_iterations_ = 10;
}

StackedQuantizersConfig::~StackedQuantizersConfig() {
  // @@protoc_insertion_point(destructor:research_scann.StackedQuantizersConfig)
  SharedDtor();
}

void StackedQuantizersConfig::SharedDtor() {
}

void StackedQuantizersConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StackedQuantizersConfig& StackedQuantizersConfig::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StackedQuantizersConfig_scann_2fproto_2fhash_2eproto.base);
  return *internal_default_instance();
}


void StackedQuantizersConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:research_scann.StackedQuantizersConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    relative_improvement_threshold_ = 0.001f;
    min_num_iterations_ = 3;
    max_num_iterations_ = 10;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* StackedQuantizersConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 min_num_iterations = 1 [default = 3];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_min_num_iterations(&has_bits);
          min_num_iterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_num_iterations = 2 [default = 10];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_max_num_iterations(&has_bits);
          max_num_iterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float relative_improvement_threshold = 3 [default = 0.001];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_relative_improvement_threshold(&has_bits);
          relative_improvement_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool StackedQuantizersConfig::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:research_scann.StackedQuantizersConfig)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 min_num_iterations = 1 [default = 3];
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_min_num_iterations(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &min_num_iterations_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_num_iterations = 2 [default = 10];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_max_num_iterations(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_num_iterations_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float relative_improvement_threshold = 3 [default = 0.001];
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (29 & 0xFF)) {
          _Internal::set_has_relative_improvement_threshold(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &relative_improvement_threshold_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:research_scann.StackedQuantizersConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:research_scann.StackedQuantizersConfig)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void StackedQuantizersConfig::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:research_scann.StackedQuantizersConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 min_num_iterations = 1 [default = 3];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->min_num_iterations(), output);
  }

  // optional int32 max_num_iterations = 2 [default = 10];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->max_num_iterations(), output);
  }

  // optional float relative_improvement_threshold = 3 [default = 0.001];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(3, this->relative_improvement_threshold(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:research_scann.StackedQuantizersConfig)
}

::PROTOBUF_NAMESPACE_ID::uint8* StackedQuantizersConfig::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:research_scann.StackedQuantizersConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 min_num_iterations = 1 [default = 3];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->min_num_iterations(), target);
  }

  // optional int32 max_num_iterations = 2 [default = 10];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->max_num_iterations(), target);
  }

  // optional float relative_improvement_threshold = 3 [default = 0.001];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->relative_improvement_threshold(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:research_scann.StackedQuantizersConfig)
  return target;
}

size_t StackedQuantizersConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:research_scann.StackedQuantizersConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float relative_improvement_threshold = 3 [default = 0.001];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional int32 min_num_iterations = 1 [default = 3];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->min_num_iterations());
    }

    // optional int32 max_num_iterations = 2 [default = 10];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->max_num_iterations());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StackedQuantizersConfig::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:research_scann.StackedQuantizersConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const StackedQuantizersConfig* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StackedQuantizersConfig>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:research_scann.StackedQuantizersConfig)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:research_scann.StackedQuantizersConfig)
    MergeFrom(*source);
  }
}

void StackedQuantizersConfig::MergeFrom(const StackedQuantizersConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:research_scann.StackedQuantizersConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      relative_improvement_threshold_ = from.relative_improvement_threshold_;
    }
    if (cached_has_bits & 0x00000002u) {
      min_num_iterations_ = from.min_num_iterations_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_num_iterations_ = from.max_num_iterations_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StackedQuantizersConfig::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:research_scann.StackedQuantizersConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StackedQuantizersConfig::CopyFrom(const StackedQuantizersConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:research_scann.StackedQuantizersConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StackedQuantizersConfig::IsInitialized() const {
  return true;
}

void StackedQuantizersConfig::InternalSwap(StackedQuantizersConfig* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(relative_improvement_threshold_, other->relative_improvement_threshold_);
  swap(min_num_iterations_, other->min_num_iterations_);
  swap(max_num_iterations_, other->max_num_iterations_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StackedQuantizersConfig::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace research_scann
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::research_scann::HashConfig* Arena::CreateMaybeMessage< ::research_scann::HashConfig >(Arena* arena) {
  return Arena::CreateInternal< ::research_scann::HashConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* Arena::CreateMaybeMessage< ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions >(Arena* arena) {
  return Arena::CreateInternal< ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::research_scann::AsymmetricHasherConfig* Arena::CreateMaybeMessage< ::research_scann::AsymmetricHasherConfig >(Arena* arena) {
  return Arena::CreateInternal< ::research_scann::AsymmetricHasherConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::research_scann::MinHasherConfig* Arena::CreateMaybeMessage< ::research_scann::MinHasherConfig >(Arena* arena) {
  return Arena::CreateInternal< ::research_scann::MinHasherConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::research_scann::BitSamplingHasherConfig* Arena::CreateMaybeMessage< ::research_scann::BitSamplingHasherConfig >(Arena* arena) {
  return Arena::CreateInternal< ::research_scann::BitSamplingHasherConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::research_scann::PcaHasherConfig* Arena::CreateMaybeMessage< ::research_scann::PcaHasherConfig >(Arena* arena) {
  return Arena::CreateInternal< ::research_scann::PcaHasherConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::research_scann::BncHasherConfig* Arena::CreateMaybeMessage< ::research_scann::BncHasherConfig >(Arena* arena) {
  return Arena::CreateInternal< ::research_scann::BncHasherConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::research_scann::StackedQuantizersConfig* Arena::CreateMaybeMessage< ::research_scann::StackedQuantizersConfig >(Arena* arena) {
  return Arena::CreateInternal< ::research_scann::StackedQuantizersConfig >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
