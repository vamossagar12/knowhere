// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scann/proto/hash.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2fhash_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2fhash_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "scann/proto/distance_measure.pb.h"
#include "scann/proto/projection.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_scann_2fproto_2fhash_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_scann_2fproto_2fhash_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scann_2fproto_2fhash_2eproto;
namespace research_scann {
class AsymmetricHasherConfig;
class AsymmetricHasherConfigDefaultTypeInternal;
extern AsymmetricHasherConfigDefaultTypeInternal _AsymmetricHasherConfig_default_instance_;
class AsymmetricHasherConfig_FixedPointLUTConversionOptions;
class AsymmetricHasherConfig_FixedPointLUTConversionOptionsDefaultTypeInternal;
extern AsymmetricHasherConfig_FixedPointLUTConversionOptionsDefaultTypeInternal _AsymmetricHasherConfig_FixedPointLUTConversionOptions_default_instance_;
class BitSamplingHasherConfig;
class BitSamplingHasherConfigDefaultTypeInternal;
extern BitSamplingHasherConfigDefaultTypeInternal _BitSamplingHasherConfig_default_instance_;
class BncHasherConfig;
class BncHasherConfigDefaultTypeInternal;
extern BncHasherConfigDefaultTypeInternal _BncHasherConfig_default_instance_;
class HashConfig;
class HashConfigDefaultTypeInternal;
extern HashConfigDefaultTypeInternal _HashConfig_default_instance_;
class MinHasherConfig;
class MinHasherConfigDefaultTypeInternal;
extern MinHasherConfigDefaultTypeInternal _MinHasherConfig_default_instance_;
class PcaHasherConfig;
class PcaHasherConfigDefaultTypeInternal;
extern PcaHasherConfigDefaultTypeInternal _PcaHasherConfig_default_instance_;
class StackedQuantizersConfig;
class StackedQuantizersConfigDefaultTypeInternal;
extern StackedQuantizersConfigDefaultTypeInternal _StackedQuantizersConfig_default_instance_;
}  // namespace research_scann
PROTOBUF_NAMESPACE_OPEN
template<> ::research_scann::AsymmetricHasherConfig* Arena::CreateMaybeMessage<::research_scann::AsymmetricHasherConfig>(Arena*);
template<> ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* Arena::CreateMaybeMessage<::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions>(Arena*);
template<> ::research_scann::BitSamplingHasherConfig* Arena::CreateMaybeMessage<::research_scann::BitSamplingHasherConfig>(Arena*);
template<> ::research_scann::BncHasherConfig* Arena::CreateMaybeMessage<::research_scann::BncHasherConfig>(Arena*);
template<> ::research_scann::HashConfig* Arena::CreateMaybeMessage<::research_scann::HashConfig>(Arena*);
template<> ::research_scann::MinHasherConfig* Arena::CreateMaybeMessage<::research_scann::MinHasherConfig>(Arena*);
template<> ::research_scann::PcaHasherConfig* Arena::CreateMaybeMessage<::research_scann::PcaHasherConfig>(Arena*);
template<> ::research_scann::StackedQuantizersConfig* Arena::CreateMaybeMessage<::research_scann::StackedQuantizersConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace research_scann {

enum HashConfig_ThresholdType : int {
  HashConfig_ThresholdType_UNKNOWN = 0,
  HashConfig_ThresholdType_SIGN = 1,
  HashConfig_ThresholdType_MEAN = 2,
  HashConfig_ThresholdType_MEDIAN = 3,
  HashConfig_ThresholdType_SINUSOIDAL = 4
};
bool HashConfig_ThresholdType_IsValid(int value);
constexpr HashConfig_ThresholdType HashConfig_ThresholdType_ThresholdType_MIN = HashConfig_ThresholdType_UNKNOWN;
constexpr HashConfig_ThresholdType HashConfig_ThresholdType_ThresholdType_MAX = HashConfig_ThresholdType_SINUSOIDAL;
constexpr int HashConfig_ThresholdType_ThresholdType_ARRAYSIZE = HashConfig_ThresholdType_ThresholdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HashConfig_ThresholdType_descriptor();
template<typename T>
inline const std::string& HashConfig_ThresholdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HashConfig_ThresholdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HashConfig_ThresholdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HashConfig_ThresholdType_descriptor(), enum_t_value);
}
inline bool HashConfig_ThresholdType_Parse(
    const std::string& name, HashConfig_ThresholdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HashConfig_ThresholdType>(
    HashConfig_ThresholdType_descriptor(), name, value);
}
enum AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod : int {
  AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_TRUNCATE = 0,
  AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_ROUND = 1
};
bool AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_IsValid(int value);
constexpr AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_FloatToIntConversionMethod_MIN = AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_TRUNCATE;
constexpr AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_FloatToIntConversionMethod_MAX = AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_ROUND;
constexpr int AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_FloatToIntConversionMethod_ARRAYSIZE = AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_FloatToIntConversionMethod_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_descriptor();
template<typename T>
inline const std::string& AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_descriptor(), enum_t_value);
}
inline bool AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_Parse(
    const std::string& name, AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod>(
    AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_descriptor(), name, value);
}
enum AsymmetricHasherConfig_LookupType : int {
  AsymmetricHasherConfig_LookupType_FLOAT = 0,
  AsymmetricHasherConfig_LookupType_INT8 = 1,
  AsymmetricHasherConfig_LookupType_INT16 = 2,
  AsymmetricHasherConfig_LookupType_INT8_LUT16 = 3
};
bool AsymmetricHasherConfig_LookupType_IsValid(int value);
constexpr AsymmetricHasherConfig_LookupType AsymmetricHasherConfig_LookupType_LookupType_MIN = AsymmetricHasherConfig_LookupType_FLOAT;
constexpr AsymmetricHasherConfig_LookupType AsymmetricHasherConfig_LookupType_LookupType_MAX = AsymmetricHasherConfig_LookupType_INT8_LUT16;
constexpr int AsymmetricHasherConfig_LookupType_LookupType_ARRAYSIZE = AsymmetricHasherConfig_LookupType_LookupType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AsymmetricHasherConfig_LookupType_descriptor();
template<typename T>
inline const std::string& AsymmetricHasherConfig_LookupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AsymmetricHasherConfig_LookupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AsymmetricHasherConfig_LookupType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AsymmetricHasherConfig_LookupType_descriptor(), enum_t_value);
}
inline bool AsymmetricHasherConfig_LookupType_Parse(
    const std::string& name, AsymmetricHasherConfig_LookupType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AsymmetricHasherConfig_LookupType>(
    AsymmetricHasherConfig_LookupType_descriptor(), name, value);
}
enum AsymmetricHasherConfig_QuantizationScheme : int {
  AsymmetricHasherConfig_QuantizationScheme_PRODUCT = 0,
  AsymmetricHasherConfig_QuantizationScheme_STACKED = 1,
  AsymmetricHasherConfig_QuantizationScheme_PRODUCT_AND_BIAS = 2,
  AsymmetricHasherConfig_QuantizationScheme_PRODUCT_AND_PACK = 3
};
bool AsymmetricHasherConfig_QuantizationScheme_IsValid(int value);
constexpr AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig_QuantizationScheme_QuantizationScheme_MIN = AsymmetricHasherConfig_QuantizationScheme_PRODUCT;
constexpr AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig_QuantizationScheme_QuantizationScheme_MAX = AsymmetricHasherConfig_QuantizationScheme_PRODUCT_AND_PACK;
constexpr int AsymmetricHasherConfig_QuantizationScheme_QuantizationScheme_ARRAYSIZE = AsymmetricHasherConfig_QuantizationScheme_QuantizationScheme_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AsymmetricHasherConfig_QuantizationScheme_descriptor();
template<typename T>
inline const std::string& AsymmetricHasherConfig_QuantizationScheme_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AsymmetricHasherConfig_QuantizationScheme>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AsymmetricHasherConfig_QuantizationScheme_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AsymmetricHasherConfig_QuantizationScheme_descriptor(), enum_t_value);
}
inline bool AsymmetricHasherConfig_QuantizationScheme_Parse(
    const std::string& name, AsymmetricHasherConfig_QuantizationScheme* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AsymmetricHasherConfig_QuantizationScheme>(
    AsymmetricHasherConfig_QuantizationScheme_descriptor(), name, value);
}
// ===================================================================

class HashConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.HashConfig) */ {
 public:
  HashConfig();
  virtual ~HashConfig();

  HashConfig(const HashConfig& from);
  HashConfig(HashConfig&& from) noexcept
    : HashConfig() {
    *this = ::std::move(from);
  }

  inline HashConfig& operator=(const HashConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashConfig& operator=(HashConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HashConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HashConfig* internal_default_instance() {
    return reinterpret_cast<const HashConfig*>(
               &_HashConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HashConfig& a, HashConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(HashConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HashConfig* New() const final {
    return CreateMaybeMessage<HashConfig>(nullptr);
  }

  HashConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HashConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HashConfig& from);
  void MergeFrom(const HashConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HashConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.HashConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2fhash_2eproto);
    return ::descriptor_table_scann_2fproto_2fhash_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HashConfig_ThresholdType ThresholdType;
  static constexpr ThresholdType UNKNOWN =
    HashConfig_ThresholdType_UNKNOWN;
  static constexpr ThresholdType SIGN =
    HashConfig_ThresholdType_SIGN;
  static constexpr ThresholdType MEAN =
    HashConfig_ThresholdType_MEAN;
  static constexpr ThresholdType MEDIAN =
    HashConfig_ThresholdType_MEDIAN;
  static constexpr ThresholdType SINUSOIDAL =
    HashConfig_ThresholdType_SINUSOIDAL;
  static inline bool ThresholdType_IsValid(int value) {
    return HashConfig_ThresholdType_IsValid(value);
  }
  static constexpr ThresholdType ThresholdType_MIN =
    HashConfig_ThresholdType_ThresholdType_MIN;
  static constexpr ThresholdType ThresholdType_MAX =
    HashConfig_ThresholdType_ThresholdType_MAX;
  static constexpr int ThresholdType_ARRAYSIZE =
    HashConfig_ThresholdType_ThresholdType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ThresholdType_descriptor() {
    return HashConfig_ThresholdType_descriptor();
  }
  template<typename T>
  static inline const std::string& ThresholdType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ThresholdType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ThresholdType_Name.");
    return HashConfig_ThresholdType_Name(enum_t_value);
  }
  static inline bool ThresholdType_Parse(const std::string& name,
      ThresholdType* value) {
    return HashConfig_ThresholdType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFilenameFieldNumber = 4,
    kProjectionFieldNumber = 2,
    kAsymmetricHashFieldNumber = 5,
    kMinHashFieldNumber = 6,
    kPcaHashFieldNumber = 7,
    kBitSamplingHashFieldNumber = 9,
    kBncHashFieldNumber = 10,
    kNumBitsFieldNumber = 1,
    kThresholdTypeFieldNumber = 3,
  };
  // optional string parameters_filename = 4;
  bool has_parameters_filename() const;
  void clear_parameters_filename();
  const std::string& parameters_filename() const;
  void set_parameters_filename(const std::string& value);
  void set_parameters_filename(std::string&& value);
  void set_parameters_filename(const char* value);
  void set_parameters_filename(const char* value, size_t size);
  std::string* mutable_parameters_filename();
  std::string* release_parameters_filename();
  void set_allocated_parameters_filename(std::string* parameters_filename);

  // optional .research_scann.ProjectionConfig projection = 2;
  bool has_projection() const;
  void clear_projection();
  const ::research_scann::ProjectionConfig& projection() const;
  ::research_scann::ProjectionConfig* release_projection();
  ::research_scann::ProjectionConfig* mutable_projection();
  void set_allocated_projection(::research_scann::ProjectionConfig* projection);

  // optional .research_scann.AsymmetricHasherConfig asymmetric_hash = 5;
  bool has_asymmetric_hash() const;
  void clear_asymmetric_hash();
  const ::research_scann::AsymmetricHasherConfig& asymmetric_hash() const;
  ::research_scann::AsymmetricHasherConfig* release_asymmetric_hash();
  ::research_scann::AsymmetricHasherConfig* mutable_asymmetric_hash();
  void set_allocated_asymmetric_hash(::research_scann::AsymmetricHasherConfig* asymmetric_hash);

  // optional .research_scann.MinHasherConfig min_hash = 6;
  bool has_min_hash() const;
  void clear_min_hash();
  const ::research_scann::MinHasherConfig& min_hash() const;
  ::research_scann::MinHasherConfig* release_min_hash();
  ::research_scann::MinHasherConfig* mutable_min_hash();
  void set_allocated_min_hash(::research_scann::MinHasherConfig* min_hash);

  // optional .research_scann.PcaHasherConfig pca_hash = 7;
  bool has_pca_hash() const;
  void clear_pca_hash();
  const ::research_scann::PcaHasherConfig& pca_hash() const;
  ::research_scann::PcaHasherConfig* release_pca_hash();
  ::research_scann::PcaHasherConfig* mutable_pca_hash();
  void set_allocated_pca_hash(::research_scann::PcaHasherConfig* pca_hash);

  // optional .research_scann.BitSamplingHasherConfig bit_sampling_hash = 9;
  bool has_bit_sampling_hash() const;
  void clear_bit_sampling_hash();
  const ::research_scann::BitSamplingHasherConfig& bit_sampling_hash() const;
  ::research_scann::BitSamplingHasherConfig* release_bit_sampling_hash();
  ::research_scann::BitSamplingHasherConfig* mutable_bit_sampling_hash();
  void set_allocated_bit_sampling_hash(::research_scann::BitSamplingHasherConfig* bit_sampling_hash);

  // optional .research_scann.BncHasherConfig bnc_hash = 10;
  bool has_bnc_hash() const;
  void clear_bnc_hash();
  const ::research_scann::BncHasherConfig& bnc_hash() const;
  ::research_scann::BncHasherConfig* release_bnc_hash();
  ::research_scann::BncHasherConfig* mutable_bnc_hash();
  void set_allocated_bnc_hash(::research_scann::BncHasherConfig* bnc_hash);

  // optional int32 num_bits = 1;
  bool has_num_bits() const;
  void clear_num_bits();
  ::PROTOBUF_NAMESPACE_ID::int32 num_bits() const;
  void set_num_bits(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .research_scann.HashConfig.ThresholdType threshold_type = 3 [default = SIGN];
  bool has_threshold_type() const;
  void clear_threshold_type();
  ::research_scann::HashConfig_ThresholdType threshold_type() const;
  void set_threshold_type(::research_scann::HashConfig_ThresholdType value);

  // @@protoc_insertion_point(class_scope:research_scann.HashConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parameters_filename_;
  ::research_scann::ProjectionConfig* projection_;
  ::research_scann::AsymmetricHasherConfig* asymmetric_hash_;
  ::research_scann::MinHasherConfig* min_hash_;
  ::research_scann::PcaHasherConfig* pca_hash_;
  ::research_scann::BitSamplingHasherConfig* bit_sampling_hash_;
  ::research_scann::BncHasherConfig* bnc_hash_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_bits_;
  int threshold_type_;
  friend struct ::TableStruct_scann_2fproto_2fhash_2eproto;
};
// -------------------------------------------------------------------

class AsymmetricHasherConfig_FixedPointLUTConversionOptions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions) */ {
 public:
  AsymmetricHasherConfig_FixedPointLUTConversionOptions();
  virtual ~AsymmetricHasherConfig_FixedPointLUTConversionOptions();

  AsymmetricHasherConfig_FixedPointLUTConversionOptions(const AsymmetricHasherConfig_FixedPointLUTConversionOptions& from);
  AsymmetricHasherConfig_FixedPointLUTConversionOptions(AsymmetricHasherConfig_FixedPointLUTConversionOptions&& from) noexcept
    : AsymmetricHasherConfig_FixedPointLUTConversionOptions() {
    *this = ::std::move(from);
  }

  inline AsymmetricHasherConfig_FixedPointLUTConversionOptions& operator=(const AsymmetricHasherConfig_FixedPointLUTConversionOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline AsymmetricHasherConfig_FixedPointLUTConversionOptions& operator=(AsymmetricHasherConfig_FixedPointLUTConversionOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AsymmetricHasherConfig_FixedPointLUTConversionOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AsymmetricHasherConfig_FixedPointLUTConversionOptions* internal_default_instance() {
    return reinterpret_cast<const AsymmetricHasherConfig_FixedPointLUTConversionOptions*>(
               &_AsymmetricHasherConfig_FixedPointLUTConversionOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AsymmetricHasherConfig_FixedPointLUTConversionOptions& a, AsymmetricHasherConfig_FixedPointLUTConversionOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(AsymmetricHasherConfig_FixedPointLUTConversionOptions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AsymmetricHasherConfig_FixedPointLUTConversionOptions* New() const final {
    return CreateMaybeMessage<AsymmetricHasherConfig_FixedPointLUTConversionOptions>(nullptr);
  }

  AsymmetricHasherConfig_FixedPointLUTConversionOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AsymmetricHasherConfig_FixedPointLUTConversionOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AsymmetricHasherConfig_FixedPointLUTConversionOptions& from);
  void MergeFrom(const AsymmetricHasherConfig_FixedPointLUTConversionOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AsymmetricHasherConfig_FixedPointLUTConversionOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2fhash_2eproto);
    return ::descriptor_table_scann_2fproto_2fhash_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod FloatToIntConversionMethod;
  static constexpr FloatToIntConversionMethod TRUNCATE =
    AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_TRUNCATE;
  static constexpr FloatToIntConversionMethod ROUND =
    AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_ROUND;
  static inline bool FloatToIntConversionMethod_IsValid(int value) {
    return AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_IsValid(value);
  }
  static constexpr FloatToIntConversionMethod FloatToIntConversionMethod_MIN =
    AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_FloatToIntConversionMethod_MIN;
  static constexpr FloatToIntConversionMethod FloatToIntConversionMethod_MAX =
    AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_FloatToIntConversionMethod_MAX;
  static constexpr int FloatToIntConversionMethod_ARRAYSIZE =
    AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_FloatToIntConversionMethod_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FloatToIntConversionMethod_descriptor() {
    return AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_descriptor();
  }
  template<typename T>
  static inline const std::string& FloatToIntConversionMethod_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FloatToIntConversionMethod>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FloatToIntConversionMethod_Name.");
    return AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_Name(enum_t_value);
  }
  static inline bool FloatToIntConversionMethod_Parse(const std::string& name,
      FloatToIntConversionMethod* value) {
    return AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFloatToIntConversionMethodFieldNumber = 1,
    kMultiplierQuantileFieldNumber = 2,
  };
  // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.FloatToIntConversionMethod float_to_int_conversion_method = 1 [default = TRUNCATE];
  bool has_float_to_int_conversion_method() const;
  void clear_float_to_int_conversion_method();
  ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod float_to_int_conversion_method() const;
  void set_float_to_int_conversion_method(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod value);

  // optional float multiplier_quantile = 2 [default = 1];
  bool has_multiplier_quantile() const;
  void clear_multiplier_quantile();
  float multiplier_quantile() const;
  void set_multiplier_quantile(float value);

  // @@protoc_insertion_point(class_scope:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int float_to_int_conversion_method_;
  float multiplier_quantile_;
  friend struct ::TableStruct_scann_2fproto_2fhash_2eproto;
};
// -------------------------------------------------------------------

class AsymmetricHasherConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.AsymmetricHasherConfig) */ {
 public:
  AsymmetricHasherConfig();
  virtual ~AsymmetricHasherConfig();

  AsymmetricHasherConfig(const AsymmetricHasherConfig& from);
  AsymmetricHasherConfig(AsymmetricHasherConfig&& from) noexcept
    : AsymmetricHasherConfig() {
    *this = ::std::move(from);
  }

  inline AsymmetricHasherConfig& operator=(const AsymmetricHasherConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AsymmetricHasherConfig& operator=(AsymmetricHasherConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AsymmetricHasherConfig& default_instance();

  enum SamplingFractionOrExpectedSizeCase {
    kSamplingFraction = 10,
    kExpectedSampleSize = 29,
    SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AsymmetricHasherConfig* internal_default_instance() {
    return reinterpret_cast<const AsymmetricHasherConfig*>(
               &_AsymmetricHasherConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AsymmetricHasherConfig& a, AsymmetricHasherConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AsymmetricHasherConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AsymmetricHasherConfig* New() const final {
    return CreateMaybeMessage<AsymmetricHasherConfig>(nullptr);
  }

  AsymmetricHasherConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AsymmetricHasherConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AsymmetricHasherConfig& from);
  void MergeFrom(const AsymmetricHasherConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AsymmetricHasherConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.AsymmetricHasherConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2fhash_2eproto);
    return ::descriptor_table_scann_2fproto_2fhash_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AsymmetricHasherConfig_FixedPointLUTConversionOptions FixedPointLUTConversionOptions;

  typedef AsymmetricHasherConfig_LookupType LookupType;
  static constexpr LookupType FLOAT =
    AsymmetricHasherConfig_LookupType_FLOAT;
  static constexpr LookupType INT8 =
    AsymmetricHasherConfig_LookupType_INT8;
  static constexpr LookupType INT16 =
    AsymmetricHasherConfig_LookupType_INT16;
  static constexpr LookupType INT8_LUT16 =
    AsymmetricHasherConfig_LookupType_INT8_LUT16;
  static inline bool LookupType_IsValid(int value) {
    return AsymmetricHasherConfig_LookupType_IsValid(value);
  }
  static constexpr LookupType LookupType_MIN =
    AsymmetricHasherConfig_LookupType_LookupType_MIN;
  static constexpr LookupType LookupType_MAX =
    AsymmetricHasherConfig_LookupType_LookupType_MAX;
  static constexpr int LookupType_ARRAYSIZE =
    AsymmetricHasherConfig_LookupType_LookupType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LookupType_descriptor() {
    return AsymmetricHasherConfig_LookupType_descriptor();
  }
  template<typename T>
  static inline const std::string& LookupType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LookupType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LookupType_Name.");
    return AsymmetricHasherConfig_LookupType_Name(enum_t_value);
  }
  static inline bool LookupType_Parse(const std::string& name,
      LookupType* value) {
    return AsymmetricHasherConfig_LookupType_Parse(name, value);
  }

  typedef AsymmetricHasherConfig_QuantizationScheme QuantizationScheme;
  static constexpr QuantizationScheme PRODUCT =
    AsymmetricHasherConfig_QuantizationScheme_PRODUCT;
  static constexpr QuantizationScheme STACKED =
    AsymmetricHasherConfig_QuantizationScheme_STACKED;
  static constexpr QuantizationScheme PRODUCT_AND_BIAS =
    AsymmetricHasherConfig_QuantizationScheme_PRODUCT_AND_BIAS;
  static constexpr QuantizationScheme PRODUCT_AND_PACK =
    AsymmetricHasherConfig_QuantizationScheme_PRODUCT_AND_PACK;
  static inline bool QuantizationScheme_IsValid(int value) {
    return AsymmetricHasherConfig_QuantizationScheme_IsValid(value);
  }
  static constexpr QuantizationScheme QuantizationScheme_MIN =
    AsymmetricHasherConfig_QuantizationScheme_QuantizationScheme_MIN;
  static constexpr QuantizationScheme QuantizationScheme_MAX =
    AsymmetricHasherConfig_QuantizationScheme_QuantizationScheme_MAX;
  static constexpr int QuantizationScheme_ARRAYSIZE =
    AsymmetricHasherConfig_QuantizationScheme_QuantizationScheme_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  QuantizationScheme_descriptor() {
    return AsymmetricHasherConfig_QuantizationScheme_descriptor();
  }
  template<typename T>
  static inline const std::string& QuantizationScheme_Name(T enum_t_value) {
    static_assert(::std::is_same<T, QuantizationScheme>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function QuantizationScheme_Name.");
    return AsymmetricHasherConfig_QuantizationScheme_Name(enum_t_value);
  }
  static inline bool QuantizationScheme_Parse(const std::string& name,
      QuantizationScheme* value) {
    return AsymmetricHasherConfig_QuantizationScheme_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCentersFilenameFieldNumber = 6,
    kMrJobnamePrefixFieldNumber = 12,
    kCellFieldNumber = 13,
    kProjectionFieldNumber = 1,
    kQuantizationDistanceFieldNumber = 18,
    kStackedQuantizersConfigFieldNumber = 24,
    kFixedPointLutConversionOptionsFieldNumber = 25,
    kMinNumberMachinesFieldNumber = 7,
    kUseNoiseShapedTrainingFieldNumber = 30,
    kUsePerLeafPartitionTrainingFieldNumber = 17,
    kUseSingleMachineTrainerFieldNumber = 8,
    kLookupTypeFieldNumber = 20,
    kQuantizationSchemeFieldNumber = 23,
    kPartitionLevelConfidenceIntervalStdevsFieldNumber = 26,
    kNumMachinesFieldNumber = 27,
    kUseResidualQuantizationFieldNumber = 22,
    kUseNormalizedResidualQuantizationFieldNumber = 32,
    kUseNormBiasingCorrectionFieldNumber = 31,
    kUseGlobalTopnFieldNumber = 33,
    kMinClusterSizeFieldNumber = 19,
    kNumClustersPerBlockFieldNumber = 2,
    kMaxSampleSizeFieldNumber = 3,
    kMaxClusteringIterationsFieldNumber = 4,
    kClusteringConvergenceToleranceFieldNumber = 5,
    kClusteringSeedFieldNumber = 9,
    kSamplingSeedFieldNumber = 11,
    kRamGbFieldNumber = 14,
    kNumCpusFieldNumber = 15,
    kNoiseShapingThresholdFieldNumber = 28,
    kSamplingFractionFieldNumber = 10,
    kExpectedSampleSizeFieldNumber = 29,
  };
  // optional string centers_filename = 6;
  bool has_centers_filename() const;
  void clear_centers_filename();
  const std::string& centers_filename() const;
  void set_centers_filename(const std::string& value);
  void set_centers_filename(std::string&& value);
  void set_centers_filename(const char* value);
  void set_centers_filename(const char* value, size_t size);
  std::string* mutable_centers_filename();
  std::string* release_centers_filename();
  void set_allocated_centers_filename(std::string* centers_filename);

  // optional string mr_jobname_prefix = 12;
  bool has_mr_jobname_prefix() const;
  void clear_mr_jobname_prefix();
  const std::string& mr_jobname_prefix() const;
  void set_mr_jobname_prefix(const std::string& value);
  void set_mr_jobname_prefix(std::string&& value);
  void set_mr_jobname_prefix(const char* value);
  void set_mr_jobname_prefix(const char* value, size_t size);
  std::string* mutable_mr_jobname_prefix();
  std::string* release_mr_jobname_prefix();
  void set_allocated_mr_jobname_prefix(std::string* mr_jobname_prefix);

  // optional string cell = 13;
  bool has_cell() const;
  void clear_cell();
  const std::string& cell() const;
  void set_cell(const std::string& value);
  void set_cell(std::string&& value);
  void set_cell(const char* value);
  void set_cell(const char* value, size_t size);
  std::string* mutable_cell();
  std::string* release_cell();
  void set_allocated_cell(std::string* cell);

  // optional .research_scann.ProjectionConfig projection = 1;
  bool has_projection() const;
  void clear_projection();
  const ::research_scann::ProjectionConfig& projection() const;
  ::research_scann::ProjectionConfig* release_projection();
  ::research_scann::ProjectionConfig* mutable_projection();
  void set_allocated_projection(::research_scann::ProjectionConfig* projection);

  // optional .research_scann.DistanceMeasureConfig quantization_distance = 18;
  bool has_quantization_distance() const;
  void clear_quantization_distance();
  const ::research_scann::DistanceMeasureConfig& quantization_distance() const;
  ::research_scann::DistanceMeasureConfig* release_quantization_distance();
  ::research_scann::DistanceMeasureConfig* mutable_quantization_distance();
  void set_allocated_quantization_distance(::research_scann::DistanceMeasureConfig* quantization_distance);

  // optional .research_scann.StackedQuantizersConfig stacked_quantizers_config = 24;
  bool has_stacked_quantizers_config() const;
  void clear_stacked_quantizers_config();
  const ::research_scann::StackedQuantizersConfig& stacked_quantizers_config() const;
  ::research_scann::StackedQuantizersConfig* release_stacked_quantizers_config();
  ::research_scann::StackedQuantizersConfig* mutable_stacked_quantizers_config();
  void set_allocated_stacked_quantizers_config(::research_scann::StackedQuantizersConfig* stacked_quantizers_config);

  // optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions fixed_point_lut_conversion_options = 25;
  bool has_fixed_point_lut_conversion_options() const;
  void clear_fixed_point_lut_conversion_options();
  const ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions& fixed_point_lut_conversion_options() const;
  ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* release_fixed_point_lut_conversion_options();
  ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* mutable_fixed_point_lut_conversion_options();
  void set_allocated_fixed_point_lut_conversion_options(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* fixed_point_lut_conversion_options);

  // optional int32 min_number_machines = 7 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_min_number_machines() const;
  PROTOBUF_DEPRECATED void clear_min_number_machines();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 min_number_machines() const;
  PROTOBUF_DEPRECATED void set_min_number_machines(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional bool use_noise_shaped_training = 30 [default = false];
  bool has_use_noise_shaped_training() const;
  void clear_use_noise_shaped_training();
  bool use_noise_shaped_training() const;
  void set_use_noise_shaped_training(bool value);

  // optional bool use_per_leaf_partition_training = 17 [default = false];
  bool has_use_per_leaf_partition_training() const;
  void clear_use_per_leaf_partition_training();
  bool use_per_leaf_partition_training() const;
  void set_use_per_leaf_partition_training(bool value);

  // optional bool use_single_machine_trainer = 8 [default = false, deprecated = true];
  PROTOBUF_DEPRECATED bool has_use_single_machine_trainer() const;
  PROTOBUF_DEPRECATED void clear_use_single_machine_trainer();
  PROTOBUF_DEPRECATED bool use_single_machine_trainer() const;
  PROTOBUF_DEPRECATED void set_use_single_machine_trainer(bool value);

  // optional .research_scann.AsymmetricHasherConfig.LookupType lookup_type = 20 [default = FLOAT];
  bool has_lookup_type() const;
  void clear_lookup_type();
  ::research_scann::AsymmetricHasherConfig_LookupType lookup_type() const;
  void set_lookup_type(::research_scann::AsymmetricHasherConfig_LookupType value);

  // optional .research_scann.AsymmetricHasherConfig.QuantizationScheme quantization_scheme = 23 [default = PRODUCT];
  bool has_quantization_scheme() const;
  void clear_quantization_scheme();
  ::research_scann::AsymmetricHasherConfig_QuantizationScheme quantization_scheme() const;
  void set_quantization_scheme(::research_scann::AsymmetricHasherConfig_QuantizationScheme value);

  // optional float partition_level_confidence_interval_stdevs = 26 [default = 0, deprecated = true];
  PROTOBUF_DEPRECATED bool has_partition_level_confidence_interval_stdevs() const;
  PROTOBUF_DEPRECATED void clear_partition_level_confidence_interval_stdevs();
  PROTOBUF_DEPRECATED float partition_level_confidence_interval_stdevs() const;
  PROTOBUF_DEPRECATED void set_partition_level_confidence_interval_stdevs(float value);

  // optional int32 num_machines = 27;
  bool has_num_machines() const;
  void clear_num_machines();
  ::PROTOBUF_NAMESPACE_ID::int32 num_machines() const;
  void set_num_machines(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional bool use_residual_quantization = 22 [default = false];
  bool has_use_residual_quantization() const;
  void clear_use_residual_quantization();
  bool use_residual_quantization() const;
  void set_use_residual_quantization(bool value);

  // optional bool use_normalized_residual_quantization = 32 [default = false];
  bool has_use_normalized_residual_quantization() const;
  void clear_use_normalized_residual_quantization();
  bool use_normalized_residual_quantization() const;
  void set_use_normalized_residual_quantization(bool value);

  // optional bool use_norm_biasing_correction = 31 [default = false];
  bool has_use_norm_biasing_correction() const;
  void clear_use_norm_biasing_correction();
  bool use_norm_biasing_correction() const;
  void set_use_norm_biasing_correction(bool value);

  // optional bool use_global_topn = 33 [default = false];
  bool has_use_global_topn() const;
  void clear_use_global_topn();
  bool use_global_topn() const;
  void set_use_global_topn(bool value);

  // optional float min_cluster_size = 19 [default = 1];
  bool has_min_cluster_size() const;
  void clear_min_cluster_size();
  float min_cluster_size() const;
  void set_min_cluster_size(float value);

  // optional int32 num_clusters_per_block = 2 [default = 256];
  bool has_num_clusters_per_block() const;
  void clear_num_clusters_per_block();
  ::PROTOBUF_NAMESPACE_ID::int32 num_clusters_per_block() const;
  void set_num_clusters_per_block(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 max_sample_size = 3 [default = 2147483647];
  bool has_max_sample_size() const;
  void clear_max_sample_size();
  ::PROTOBUF_NAMESPACE_ID::int32 max_sample_size() const;
  void set_max_sample_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 max_clustering_iterations = 4 [default = 10];
  bool has_max_clustering_iterations() const;
  void clear_max_clustering_iterations();
  ::PROTOBUF_NAMESPACE_ID::int32 max_clustering_iterations() const;
  void set_max_clustering_iterations(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional float clustering_convergence_tolerance = 5 [default = 1e-05];
  bool has_clustering_convergence_tolerance() const;
  void clear_clustering_convergence_tolerance();
  float clustering_convergence_tolerance() const;
  void set_clustering_convergence_tolerance(float value);

  // optional int32 clustering_seed = 9 [default = 1];
  bool has_clustering_seed() const;
  void clear_clustering_seed();
  ::PROTOBUF_NAMESPACE_ID::int32 clustering_seed() const;
  void set_clustering_seed(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 sampling_seed = 11 [default = 1];
  bool has_sampling_seed() const;
  void clear_sampling_seed();
  ::PROTOBUF_NAMESPACE_ID::int32 sampling_seed() const;
  void set_sampling_seed(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 ram_gb = 14 [default = 4];
  bool has_ram_gb() const;
  void clear_ram_gb();
  ::PROTOBUF_NAMESPACE_ID::int32 ram_gb() const;
  void set_ram_gb(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_cpus = 15 [default = 1];
  bool has_num_cpus() const;
  void clear_num_cpus();
  ::PROTOBUF_NAMESPACE_ID::int32 num_cpus() const;
  void set_num_cpus(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional double noise_shaping_threshold = 28 [default = nan];
  bool has_noise_shaping_threshold() const;
  void clear_noise_shaping_threshold();
  double noise_shaping_threshold() const;
  void set_noise_shaping_threshold(double value);

  // optional float sampling_fraction = 10 [default = 1];
  bool has_sampling_fraction() const;
  void clear_sampling_fraction();
  float sampling_fraction() const;
  void set_sampling_fraction(float value);

  // optional int32 expected_sample_size = 29;
  bool has_expected_sample_size() const;
  void clear_expected_sample_size();
  ::PROTOBUF_NAMESPACE_ID::int32 expected_sample_size() const;
  void set_expected_sample_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  void clear_SamplingFractionOrExpectedSize();
  SamplingFractionOrExpectedSizeCase SamplingFractionOrExpectedSize_case() const;
  // @@protoc_insertion_point(class_scope:research_scann.AsymmetricHasherConfig)
 private:
  class _Internal;
  void set_has_sampling_fraction();
  void set_has_expected_sample_size();

  inline bool has_SamplingFractionOrExpectedSize() const;
  inline void clear_has_SamplingFractionOrExpectedSize();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr centers_filename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mr_jobname_prefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cell_;
  ::research_scann::ProjectionConfig* projection_;
  ::research_scann::DistanceMeasureConfig* quantization_distance_;
  ::research_scann::StackedQuantizersConfig* stacked_quantizers_config_;
  ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* fixed_point_lut_conversion_options_;
  ::PROTOBUF_NAMESPACE_ID::int32 min_number_machines_;
  bool use_noise_shaped_training_;
  bool use_per_leaf_partition_training_;
  bool use_single_machine_trainer_;
  int lookup_type_;
  int quantization_scheme_;
  float partition_level_confidence_interval_stdevs_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_machines_;
  bool use_residual_quantization_;
  bool use_normalized_residual_quantization_;
  bool use_norm_biasing_correction_;
  bool use_global_topn_;
  float min_cluster_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_clusters_per_block_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_sample_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_clustering_iterations_;
  float clustering_convergence_tolerance_;
  ::PROTOBUF_NAMESPACE_ID::int32 clustering_seed_;
  ::PROTOBUF_NAMESPACE_ID::int32 sampling_seed_;
  ::PROTOBUF_NAMESPACE_ID::int32 ram_gb_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_cpus_;
  double noise_shaping_threshold_;
  union SamplingFractionOrExpectedSizeUnion {
    SamplingFractionOrExpectedSizeUnion() {}
    float sampling_fraction_;
    ::PROTOBUF_NAMESPACE_ID::int32 expected_sample_size_;
  } SamplingFractionOrExpectedSize_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_scann_2fproto_2fhash_2eproto;
};
// -------------------------------------------------------------------

class MinHasherConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.MinHasherConfig) */ {
 public:
  MinHasherConfig();
  virtual ~MinHasherConfig();

  MinHasherConfig(const MinHasherConfig& from);
  MinHasherConfig(MinHasherConfig&& from) noexcept
    : MinHasherConfig() {
    *this = ::std::move(from);
  }

  inline MinHasherConfig& operator=(const MinHasherConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MinHasherConfig& operator=(MinHasherConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MinHasherConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MinHasherConfig* internal_default_instance() {
    return reinterpret_cast<const MinHasherConfig*>(
               &_MinHasherConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MinHasherConfig& a, MinHasherConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MinHasherConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MinHasherConfig* New() const final {
    return CreateMaybeMessage<MinHasherConfig>(nullptr);
  }

  MinHasherConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MinHasherConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MinHasherConfig& from);
  void MergeFrom(const MinHasherConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MinHasherConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.MinHasherConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2fhash_2eproto);
    return ::descriptor_table_scann_2fproto_2fhash_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeedsFieldNumber = 4,
    kConfigIdFieldNumber = 1,
    kNumSketchesFieldNumber = 2,
    kNumHashesFieldNumber = 3,
    kNumBitsPerHashFieldNumber = 5,
  };
  // repeated int64 seeds = 4;
  int seeds_size() const;
  void clear_seeds();
  ::PROTOBUF_NAMESPACE_ID::int64 seeds(int index) const;
  void set_seeds(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_seeds(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      seeds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_seeds();

  // optional int32 config_id = 1;
  bool has_config_id() const;
  void clear_config_id();
  ::PROTOBUF_NAMESPACE_ID::int32 config_id() const;
  void set_config_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_sketches = 2;
  bool has_num_sketches() const;
  void clear_num_sketches();
  ::PROTOBUF_NAMESPACE_ID::int32 num_sketches() const;
  void set_num_sketches(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_hashes = 3;
  bool has_num_hashes() const;
  void clear_num_hashes();
  ::PROTOBUF_NAMESPACE_ID::int32 num_hashes() const;
  void set_num_hashes(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_bits_per_hash = 5;
  bool has_num_bits_per_hash() const;
  void clear_num_bits_per_hash();
  ::PROTOBUF_NAMESPACE_ID::int32 num_bits_per_hash() const;
  void set_num_bits_per_hash(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:research_scann.MinHasherConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > seeds_;
  ::PROTOBUF_NAMESPACE_ID::int32 config_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_sketches_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_hashes_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_bits_per_hash_;
  friend struct ::TableStruct_scann_2fproto_2fhash_2eproto;
};
// -------------------------------------------------------------------

class BitSamplingHasherConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.BitSamplingHasherConfig) */ {
 public:
  BitSamplingHasherConfig();
  virtual ~BitSamplingHasherConfig();

  BitSamplingHasherConfig(const BitSamplingHasherConfig& from);
  BitSamplingHasherConfig(BitSamplingHasherConfig&& from) noexcept
    : BitSamplingHasherConfig() {
    *this = ::std::move(from);
  }

  inline BitSamplingHasherConfig& operator=(const BitSamplingHasherConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitSamplingHasherConfig& operator=(BitSamplingHasherConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BitSamplingHasherConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BitSamplingHasherConfig* internal_default_instance() {
    return reinterpret_cast<const BitSamplingHasherConfig*>(
               &_BitSamplingHasherConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BitSamplingHasherConfig& a, BitSamplingHasherConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(BitSamplingHasherConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BitSamplingHasherConfig* New() const final {
    return CreateMaybeMessage<BitSamplingHasherConfig>(nullptr);
  }

  BitSamplingHasherConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BitSamplingHasherConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BitSamplingHasherConfig& from);
  void MergeFrom(const BitSamplingHasherConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitSamplingHasherConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.BitSamplingHasherConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2fhash_2eproto);
    return ::descriptor_table_scann_2fproto_2fhash_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseEntropyFieldNumber = 2,
    kNumBitsFieldNumber = 1,
  };
  // optional bool use_entropy = 2 [default = false];
  bool has_use_entropy() const;
  void clear_use_entropy();
  bool use_entropy() const;
  void set_use_entropy(bool value);

  // optional int32 num_bits = 1 [default = 3];
  bool has_num_bits() const;
  void clear_num_bits();
  ::PROTOBUF_NAMESPACE_ID::int32 num_bits() const;
  void set_num_bits(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:research_scann.BitSamplingHasherConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool use_entropy_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_bits_;
  friend struct ::TableStruct_scann_2fproto_2fhash_2eproto;
};
// -------------------------------------------------------------------

class PcaHasherConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.PcaHasherConfig) */ {
 public:
  PcaHasherConfig();
  virtual ~PcaHasherConfig();

  PcaHasherConfig(const PcaHasherConfig& from);
  PcaHasherConfig(PcaHasherConfig&& from) noexcept
    : PcaHasherConfig() {
    *this = ::std::move(from);
  }

  inline PcaHasherConfig& operator=(const PcaHasherConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PcaHasherConfig& operator=(PcaHasherConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PcaHasherConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PcaHasherConfig* internal_default_instance() {
    return reinterpret_cast<const PcaHasherConfig*>(
               &_PcaHasherConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PcaHasherConfig& a, PcaHasherConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PcaHasherConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PcaHasherConfig* New() const final {
    return CreateMaybeMessage<PcaHasherConfig>(nullptr);
  }

  PcaHasherConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PcaHasherConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PcaHasherConfig& from);
  void MergeFrom(const PcaHasherConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PcaHasherConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.PcaHasherConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2fhash_2eproto);
    return ::descriptor_table_scann_2fproto_2fhash_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRotateProjectionsFieldNumber = 1,
    kLearnProjectionsFieldNumber = 5,
    kMaxSampleSizeFieldNumber = 4,
    kSamplingFractionFieldNumber = 2,
    kSamplingSeedFieldNumber = 3,
    kMaxNumIterationFieldNumber = 6,
    kIterationToleranceFieldNumber = 7,
  };
  // optional bool rotate_projections = 1 [default = false];
  bool has_rotate_projections() const;
  void clear_rotate_projections();
  bool rotate_projections() const;
  void set_rotate_projections(bool value);

  // optional bool learn_projections = 5 [default = false];
  bool has_learn_projections() const;
  void clear_learn_projections();
  bool learn_projections() const;
  void set_learn_projections(bool value);

  // optional int32 max_sample_size = 4;
  bool has_max_sample_size() const;
  void clear_max_sample_size();
  ::PROTOBUF_NAMESPACE_ID::int32 max_sample_size() const;
  void set_max_sample_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional float sampling_fraction = 2 [default = 1];
  bool has_sampling_fraction() const;
  void clear_sampling_fraction();
  float sampling_fraction() const;
  void set_sampling_fraction(float value);

  // optional int32 sampling_seed = 3 [default = 1];
  bool has_sampling_seed() const;
  void clear_sampling_seed();
  ::PROTOBUF_NAMESPACE_ID::int32 sampling_seed() const;
  void set_sampling_seed(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 max_num_iteration = 6 [default = 40];
  bool has_max_num_iteration() const;
  void clear_max_num_iteration();
  ::PROTOBUF_NAMESPACE_ID::int32 max_num_iteration() const;
  void set_max_num_iteration(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional float iteration_tolerance = 7 [default = 1e-05];
  bool has_iteration_tolerance() const;
  void clear_iteration_tolerance();
  float iteration_tolerance() const;
  void set_iteration_tolerance(float value);

  // @@protoc_insertion_point(class_scope:research_scann.PcaHasherConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool rotate_projections_;
  bool learn_projections_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_sample_size_;
  float sampling_fraction_;
  ::PROTOBUF_NAMESPACE_ID::int32 sampling_seed_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_num_iteration_;
  float iteration_tolerance_;
  friend struct ::TableStruct_scann_2fproto_2fhash_2eproto;
};
// -------------------------------------------------------------------

class BncHasherConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.BncHasherConfig) */ {
 public:
  BncHasherConfig();
  virtual ~BncHasherConfig();

  BncHasherConfig(const BncHasherConfig& from);
  BncHasherConfig(BncHasherConfig&& from) noexcept
    : BncHasherConfig() {
    *this = ::std::move(from);
  }

  inline BncHasherConfig& operator=(const BncHasherConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline BncHasherConfig& operator=(BncHasherConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BncHasherConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BncHasherConfig* internal_default_instance() {
    return reinterpret_cast<const BncHasherConfig*>(
               &_BncHasherConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BncHasherConfig& a, BncHasherConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(BncHasherConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BncHasherConfig* New() const final {
    return CreateMaybeMessage<BncHasherConfig>(nullptr);
  }

  BncHasherConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BncHasherConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BncHasherConfig& from);
  void MergeFrom(const BncHasherConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BncHasherConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.BncHasherConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2fhash_2eproto);
    return ::descriptor_table_scann_2fproto_2fhash_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompressionRatioFieldNumber = 1,
    kNumCpusFieldNumber = 8,
    kGammaFieldNumber = 2,
    kLearningRateFieldNumber = 3,
    kBatchSizeFieldNumber = 4,
    kNumPhase1IterationsFieldNumber = 5,
    kNumPhase2IterationsFieldNumber = 6,
    kSamplingSeedFieldNumber = 7,
  };
  // optional float compression_ratio = 1 [default = 0];
  bool has_compression_ratio() const;
  void clear_compression_ratio();
  float compression_ratio() const;
  void set_compression_ratio(float value);

  // optional int32 num_cpus = 8 [default = 1];
  bool has_num_cpus() const;
  void clear_num_cpus();
  ::PROTOBUF_NAMESPACE_ID::int32 num_cpus() const;
  void set_num_cpus(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional float gamma = 2 [default = 10];
  bool has_gamma() const;
  void clear_gamma();
  float gamma() const;
  void set_gamma(float value);

  // optional float learning_rate = 3 [default = 0.1];
  bool has_learning_rate() const;
  void clear_learning_rate();
  float learning_rate() const;
  void set_learning_rate(float value);

  // optional int32 batch_size = 4 [default = 128];
  bool has_batch_size() const;
  void clear_batch_size();
  ::PROTOBUF_NAMESPACE_ID::int32 batch_size() const;
  void set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_phase1_iterations = 5 [default = 50];
  bool has_num_phase1_iterations() const;
  void clear_num_phase1_iterations();
  ::PROTOBUF_NAMESPACE_ID::int32 num_phase1_iterations() const;
  void set_num_phase1_iterations(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_phase2_iterations = 6 [default = 100];
  bool has_num_phase2_iterations() const;
  void clear_num_phase2_iterations();
  ::PROTOBUF_NAMESPACE_ID::int32 num_phase2_iterations() const;
  void set_num_phase2_iterations(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 sampling_seed = 7 [default = 1];
  bool has_sampling_seed() const;
  void clear_sampling_seed();
  ::PROTOBUF_NAMESPACE_ID::int32 sampling_seed() const;
  void set_sampling_seed(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:research_scann.BncHasherConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float compression_ratio_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_cpus_;
  float gamma_;
  float learning_rate_;
  ::PROTOBUF_NAMESPACE_ID::int32 batch_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_phase1_iterations_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_phase2_iterations_;
  ::PROTOBUF_NAMESPACE_ID::int32 sampling_seed_;
  friend struct ::TableStruct_scann_2fproto_2fhash_2eproto;
};
// -------------------------------------------------------------------

class StackedQuantizersConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.StackedQuantizersConfig) */ {
 public:
  StackedQuantizersConfig();
  virtual ~StackedQuantizersConfig();

  StackedQuantizersConfig(const StackedQuantizersConfig& from);
  StackedQuantizersConfig(StackedQuantizersConfig&& from) noexcept
    : StackedQuantizersConfig() {
    *this = ::std::move(from);
  }

  inline StackedQuantizersConfig& operator=(const StackedQuantizersConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StackedQuantizersConfig& operator=(StackedQuantizersConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StackedQuantizersConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StackedQuantizersConfig* internal_default_instance() {
    return reinterpret_cast<const StackedQuantizersConfig*>(
               &_StackedQuantizersConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StackedQuantizersConfig& a, StackedQuantizersConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(StackedQuantizersConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StackedQuantizersConfig* New() const final {
    return CreateMaybeMessage<StackedQuantizersConfig>(nullptr);
  }

  StackedQuantizersConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StackedQuantizersConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StackedQuantizersConfig& from);
  void MergeFrom(const StackedQuantizersConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StackedQuantizersConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.StackedQuantizersConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2fhash_2eproto);
    return ::descriptor_table_scann_2fproto_2fhash_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelativeImprovementThresholdFieldNumber = 3,
    kMinNumIterationsFieldNumber = 1,
    kMaxNumIterationsFieldNumber = 2,
  };
  // optional float relative_improvement_threshold = 3 [default = 0.001];
  bool has_relative_improvement_threshold() const;
  void clear_relative_improvement_threshold();
  float relative_improvement_threshold() const;
  void set_relative_improvement_threshold(float value);

  // optional int32 min_num_iterations = 1 [default = 3];
  bool has_min_num_iterations() const;
  void clear_min_num_iterations();
  ::PROTOBUF_NAMESPACE_ID::int32 min_num_iterations() const;
  void set_min_num_iterations(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 max_num_iterations = 2 [default = 10];
  bool has_max_num_iterations() const;
  void clear_max_num_iterations();
  ::PROTOBUF_NAMESPACE_ID::int32 max_num_iterations() const;
  void set_max_num_iterations(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:research_scann.StackedQuantizersConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float relative_improvement_threshold_;
  ::PROTOBUF_NAMESPACE_ID::int32 min_num_iterations_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_num_iterations_;
  friend struct ::TableStruct_scann_2fproto_2fhash_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HashConfig

// optional int32 num_bits = 1;
inline bool HashConfig::has_num_bits() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HashConfig::clear_num_bits() {
  num_bits_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HashConfig::num_bits() const {
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.num_bits)
  return num_bits_;
}
inline void HashConfig::set_num_bits(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  num_bits_ = value;
  // @@protoc_insertion_point(field_set:research_scann.HashConfig.num_bits)
}

// optional .research_scann.ProjectionConfig projection = 2;
inline bool HashConfig::has_projection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::research_scann::ProjectionConfig& HashConfig::projection() const {
  const ::research_scann::ProjectionConfig* p = projection_;
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.projection)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::ProjectionConfig*>(
      &::research_scann::_ProjectionConfig_default_instance_);
}
inline ::research_scann::ProjectionConfig* HashConfig::release_projection() {
  // @@protoc_insertion_point(field_release:research_scann.HashConfig.projection)
  _has_bits_[0] &= ~0x00000002u;
  ::research_scann::ProjectionConfig* temp = projection_;
  projection_ = nullptr;
  return temp;
}
inline ::research_scann::ProjectionConfig* HashConfig::mutable_projection() {
  _has_bits_[0] |= 0x00000002u;
  if (projection_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::ProjectionConfig>(GetArenaNoVirtual());
    projection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.HashConfig.projection)
  return projection_;
}
inline void HashConfig::set_allocated_projection(::research_scann::ProjectionConfig* projection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(projection_);
  }
  if (projection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      projection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, projection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  projection_ = projection;
  // @@protoc_insertion_point(field_set_allocated:research_scann.HashConfig.projection)
}

// optional .research_scann.HashConfig.ThresholdType threshold_type = 3 [default = SIGN];
inline bool HashConfig::has_threshold_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HashConfig::clear_threshold_type() {
  threshold_type_ = 1;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::research_scann::HashConfig_ThresholdType HashConfig::threshold_type() const {
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.threshold_type)
  return static_cast< ::research_scann::HashConfig_ThresholdType >(threshold_type_);
}
inline void HashConfig::set_threshold_type(::research_scann::HashConfig_ThresholdType value) {
  assert(::research_scann::HashConfig_ThresholdType_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  threshold_type_ = value;
  // @@protoc_insertion_point(field_set:research_scann.HashConfig.threshold_type)
}

// optional string parameters_filename = 4;
inline bool HashConfig::has_parameters_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HashConfig::clear_parameters_filename() {
  parameters_filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HashConfig::parameters_filename() const {
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.parameters_filename)
  return parameters_filename_.GetNoArena();
}
inline void HashConfig::set_parameters_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  parameters_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.HashConfig.parameters_filename)
}
inline void HashConfig::set_parameters_filename(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  parameters_filename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.HashConfig.parameters_filename)
}
inline void HashConfig::set_parameters_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  parameters_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.HashConfig.parameters_filename)
}
inline void HashConfig::set_parameters_filename(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  parameters_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.HashConfig.parameters_filename)
}
inline std::string* HashConfig::mutable_parameters_filename() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:research_scann.HashConfig.parameters_filename)
  return parameters_filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HashConfig::release_parameters_filename() {
  // @@protoc_insertion_point(field_release:research_scann.HashConfig.parameters_filename)
  if (!has_parameters_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return parameters_filename_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HashConfig::set_allocated_parameters_filename(std::string* parameters_filename) {
  if (parameters_filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  parameters_filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parameters_filename);
  // @@protoc_insertion_point(field_set_allocated:research_scann.HashConfig.parameters_filename)
}

// optional .research_scann.AsymmetricHasherConfig asymmetric_hash = 5;
inline bool HashConfig::has_asymmetric_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HashConfig::clear_asymmetric_hash() {
  if (asymmetric_hash_ != nullptr) asymmetric_hash_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::research_scann::AsymmetricHasherConfig& HashConfig::asymmetric_hash() const {
  const ::research_scann::AsymmetricHasherConfig* p = asymmetric_hash_;
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.asymmetric_hash)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::AsymmetricHasherConfig*>(
      &::research_scann::_AsymmetricHasherConfig_default_instance_);
}
inline ::research_scann::AsymmetricHasherConfig* HashConfig::release_asymmetric_hash() {
  // @@protoc_insertion_point(field_release:research_scann.HashConfig.asymmetric_hash)
  _has_bits_[0] &= ~0x00000004u;
  ::research_scann::AsymmetricHasherConfig* temp = asymmetric_hash_;
  asymmetric_hash_ = nullptr;
  return temp;
}
inline ::research_scann::AsymmetricHasherConfig* HashConfig::mutable_asymmetric_hash() {
  _has_bits_[0] |= 0x00000004u;
  if (asymmetric_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::AsymmetricHasherConfig>(GetArenaNoVirtual());
    asymmetric_hash_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.HashConfig.asymmetric_hash)
  return asymmetric_hash_;
}
inline void HashConfig::set_allocated_asymmetric_hash(::research_scann::AsymmetricHasherConfig* asymmetric_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete asymmetric_hash_;
  }
  if (asymmetric_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      asymmetric_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asymmetric_hash, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  asymmetric_hash_ = asymmetric_hash;
  // @@protoc_insertion_point(field_set_allocated:research_scann.HashConfig.asymmetric_hash)
}

// optional .research_scann.MinHasherConfig min_hash = 6;
inline bool HashConfig::has_min_hash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HashConfig::clear_min_hash() {
  if (min_hash_ != nullptr) min_hash_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::research_scann::MinHasherConfig& HashConfig::min_hash() const {
  const ::research_scann::MinHasherConfig* p = min_hash_;
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.min_hash)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::MinHasherConfig*>(
      &::research_scann::_MinHasherConfig_default_instance_);
}
inline ::research_scann::MinHasherConfig* HashConfig::release_min_hash() {
  // @@protoc_insertion_point(field_release:research_scann.HashConfig.min_hash)
  _has_bits_[0] &= ~0x00000008u;
  ::research_scann::MinHasherConfig* temp = min_hash_;
  min_hash_ = nullptr;
  return temp;
}
inline ::research_scann::MinHasherConfig* HashConfig::mutable_min_hash() {
  _has_bits_[0] |= 0x00000008u;
  if (min_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::MinHasherConfig>(GetArenaNoVirtual());
    min_hash_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.HashConfig.min_hash)
  return min_hash_;
}
inline void HashConfig::set_allocated_min_hash(::research_scann::MinHasherConfig* min_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete min_hash_;
  }
  if (min_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      min_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min_hash, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  min_hash_ = min_hash;
  // @@protoc_insertion_point(field_set_allocated:research_scann.HashConfig.min_hash)
}

// optional .research_scann.PcaHasherConfig pca_hash = 7;
inline bool HashConfig::has_pca_hash() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HashConfig::clear_pca_hash() {
  if (pca_hash_ != nullptr) pca_hash_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::research_scann::PcaHasherConfig& HashConfig::pca_hash() const {
  const ::research_scann::PcaHasherConfig* p = pca_hash_;
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.pca_hash)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::PcaHasherConfig*>(
      &::research_scann::_PcaHasherConfig_default_instance_);
}
inline ::research_scann::PcaHasherConfig* HashConfig::release_pca_hash() {
  // @@protoc_insertion_point(field_release:research_scann.HashConfig.pca_hash)
  _has_bits_[0] &= ~0x00000010u;
  ::research_scann::PcaHasherConfig* temp = pca_hash_;
  pca_hash_ = nullptr;
  return temp;
}
inline ::research_scann::PcaHasherConfig* HashConfig::mutable_pca_hash() {
  _has_bits_[0] |= 0x00000010u;
  if (pca_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::PcaHasherConfig>(GetArenaNoVirtual());
    pca_hash_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.HashConfig.pca_hash)
  return pca_hash_;
}
inline void HashConfig::set_allocated_pca_hash(::research_scann::PcaHasherConfig* pca_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pca_hash_;
  }
  if (pca_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pca_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pca_hash, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  pca_hash_ = pca_hash;
  // @@protoc_insertion_point(field_set_allocated:research_scann.HashConfig.pca_hash)
}

// optional .research_scann.BitSamplingHasherConfig bit_sampling_hash = 9;
inline bool HashConfig::has_bit_sampling_hash() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HashConfig::clear_bit_sampling_hash() {
  if (bit_sampling_hash_ != nullptr) bit_sampling_hash_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::research_scann::BitSamplingHasherConfig& HashConfig::bit_sampling_hash() const {
  const ::research_scann::BitSamplingHasherConfig* p = bit_sampling_hash_;
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.bit_sampling_hash)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::BitSamplingHasherConfig*>(
      &::research_scann::_BitSamplingHasherConfig_default_instance_);
}
inline ::research_scann::BitSamplingHasherConfig* HashConfig::release_bit_sampling_hash() {
  // @@protoc_insertion_point(field_release:research_scann.HashConfig.bit_sampling_hash)
  _has_bits_[0] &= ~0x00000020u;
  ::research_scann::BitSamplingHasherConfig* temp = bit_sampling_hash_;
  bit_sampling_hash_ = nullptr;
  return temp;
}
inline ::research_scann::BitSamplingHasherConfig* HashConfig::mutable_bit_sampling_hash() {
  _has_bits_[0] |= 0x00000020u;
  if (bit_sampling_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::BitSamplingHasherConfig>(GetArenaNoVirtual());
    bit_sampling_hash_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.HashConfig.bit_sampling_hash)
  return bit_sampling_hash_;
}
inline void HashConfig::set_allocated_bit_sampling_hash(::research_scann::BitSamplingHasherConfig* bit_sampling_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete bit_sampling_hash_;
  }
  if (bit_sampling_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bit_sampling_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bit_sampling_hash, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  bit_sampling_hash_ = bit_sampling_hash;
  // @@protoc_insertion_point(field_set_allocated:research_scann.HashConfig.bit_sampling_hash)
}

// optional .research_scann.BncHasherConfig bnc_hash = 10;
inline bool HashConfig::has_bnc_hash() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HashConfig::clear_bnc_hash() {
  if (bnc_hash_ != nullptr) bnc_hash_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::research_scann::BncHasherConfig& HashConfig::bnc_hash() const {
  const ::research_scann::BncHasherConfig* p = bnc_hash_;
  // @@protoc_insertion_point(field_get:research_scann.HashConfig.bnc_hash)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::BncHasherConfig*>(
      &::research_scann::_BncHasherConfig_default_instance_);
}
inline ::research_scann::BncHasherConfig* HashConfig::release_bnc_hash() {
  // @@protoc_insertion_point(field_release:research_scann.HashConfig.bnc_hash)
  _has_bits_[0] &= ~0x00000040u;
  ::research_scann::BncHasherConfig* temp = bnc_hash_;
  bnc_hash_ = nullptr;
  return temp;
}
inline ::research_scann::BncHasherConfig* HashConfig::mutable_bnc_hash() {
  _has_bits_[0] |= 0x00000040u;
  if (bnc_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::BncHasherConfig>(GetArenaNoVirtual());
    bnc_hash_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.HashConfig.bnc_hash)
  return bnc_hash_;
}
inline void HashConfig::set_allocated_bnc_hash(::research_scann::BncHasherConfig* bnc_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete bnc_hash_;
  }
  if (bnc_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bnc_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bnc_hash, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  bnc_hash_ = bnc_hash;
  // @@protoc_insertion_point(field_set_allocated:research_scann.HashConfig.bnc_hash)
}

// -------------------------------------------------------------------

// AsymmetricHasherConfig_FixedPointLUTConversionOptions

// optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.FloatToIntConversionMethod float_to_int_conversion_method = 1 [default = TRUNCATE];
inline bool AsymmetricHasherConfig_FixedPointLUTConversionOptions::has_float_to_int_conversion_method() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AsymmetricHasherConfig_FixedPointLUTConversionOptions::clear_float_to_int_conversion_method() {
  float_to_int_conversion_method_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod AsymmetricHasherConfig_FixedPointLUTConversionOptions::float_to_int_conversion_method() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.float_to_int_conversion_method)
  return static_cast< ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod >(float_to_int_conversion_method_);
}
inline void AsymmetricHasherConfig_FixedPointLUTConversionOptions::set_float_to_int_conversion_method(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod value) {
  assert(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  float_to_int_conversion_method_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.float_to_int_conversion_method)
}

// optional float multiplier_quantile = 2 [default = 1];
inline bool AsymmetricHasherConfig_FixedPointLUTConversionOptions::has_multiplier_quantile() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AsymmetricHasherConfig_FixedPointLUTConversionOptions::clear_multiplier_quantile() {
  multiplier_quantile_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline float AsymmetricHasherConfig_FixedPointLUTConversionOptions::multiplier_quantile() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.multiplier_quantile)
  return multiplier_quantile_;
}
inline void AsymmetricHasherConfig_FixedPointLUTConversionOptions::set_multiplier_quantile(float value) {
  _has_bits_[0] |= 0x00000002u;
  multiplier_quantile_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions.multiplier_quantile)
}

// -------------------------------------------------------------------

// AsymmetricHasherConfig

// optional .research_scann.ProjectionConfig projection = 1;
inline bool AsymmetricHasherConfig::has_projection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline const ::research_scann::ProjectionConfig& AsymmetricHasherConfig::projection() const {
  const ::research_scann::ProjectionConfig* p = projection_;
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.projection)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::ProjectionConfig*>(
      &::research_scann::_ProjectionConfig_default_instance_);
}
inline ::research_scann::ProjectionConfig* AsymmetricHasherConfig::release_projection() {
  // @@protoc_insertion_point(field_release:research_scann.AsymmetricHasherConfig.projection)
  _has_bits_[0] &= ~0x00000008u;
  ::research_scann::ProjectionConfig* temp = projection_;
  projection_ = nullptr;
  return temp;
}
inline ::research_scann::ProjectionConfig* AsymmetricHasherConfig::mutable_projection() {
  _has_bits_[0] |= 0x00000008u;
  if (projection_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::ProjectionConfig>(GetArenaNoVirtual());
    projection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.AsymmetricHasherConfig.projection)
  return projection_;
}
inline void AsymmetricHasherConfig::set_allocated_projection(::research_scann::ProjectionConfig* projection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(projection_);
  }
  if (projection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      projection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, projection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  projection_ = projection;
  // @@protoc_insertion_point(field_set_allocated:research_scann.AsymmetricHasherConfig.projection)
}

// optional int32 num_clusters_per_block = 2 [default = 256];
inline bool AsymmetricHasherConfig::has_num_clusters_per_block() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void AsymmetricHasherConfig::clear_num_clusters_per_block() {
  num_clusters_per_block_ = 256;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AsymmetricHasherConfig::num_clusters_per_block() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.num_clusters_per_block)
  return num_clusters_per_block_;
}
inline void AsymmetricHasherConfig::set_num_clusters_per_block(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00100000u;
  num_clusters_per_block_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.num_clusters_per_block)
}

// optional .research_scann.AsymmetricHasherConfig.LookupType lookup_type = 20 [default = FLOAT];
inline bool AsymmetricHasherConfig::has_lookup_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AsymmetricHasherConfig::clear_lookup_type() {
  lookup_type_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::research_scann::AsymmetricHasherConfig_LookupType AsymmetricHasherConfig::lookup_type() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.lookup_type)
  return static_cast< ::research_scann::AsymmetricHasherConfig_LookupType >(lookup_type_);
}
inline void AsymmetricHasherConfig::set_lookup_type(::research_scann::AsymmetricHasherConfig_LookupType value) {
  assert(::research_scann::AsymmetricHasherConfig_LookupType_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  lookup_type_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.lookup_type)
}

// optional int32 clustering_seed = 9 [default = 1];
inline bool AsymmetricHasherConfig::has_clustering_seed() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void AsymmetricHasherConfig::clear_clustering_seed() {
  clustering_seed_ = 1;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AsymmetricHasherConfig::clustering_seed() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.clustering_seed)
  return clustering_seed_;
}
inline void AsymmetricHasherConfig::set_clustering_seed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x01000000u;
  clustering_seed_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.clustering_seed)
}

// optional bool use_residual_quantization = 22 [default = false];
inline bool AsymmetricHasherConfig::has_use_residual_quantization() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AsymmetricHasherConfig::clear_use_residual_quantization() {
  use_residual_quantization_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool AsymmetricHasherConfig::use_residual_quantization() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.use_residual_quantization)
  return use_residual_quantization_;
}
inline void AsymmetricHasherConfig::set_use_residual_quantization(bool value) {
  _has_bits_[0] |= 0x00008000u;
  use_residual_quantization_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.use_residual_quantization)
}

// optional bool use_normalized_residual_quantization = 32 [default = false];
inline bool AsymmetricHasherConfig::has_use_normalized_residual_quantization() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void AsymmetricHasherConfig::clear_use_normalized_residual_quantization() {
  use_normalized_residual_quantization_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool AsymmetricHasherConfig::use_normalized_residual_quantization() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.use_normalized_residual_quantization)
  return use_normalized_residual_quantization_;
}
inline void AsymmetricHasherConfig::set_use_normalized_residual_quantization(bool value) {
  _has_bits_[0] |= 0x00010000u;
  use_normalized_residual_quantization_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.use_normalized_residual_quantization)
}

// optional double noise_shaping_threshold = 28 [default = nan];
inline bool AsymmetricHasherConfig::has_noise_shaping_threshold() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void AsymmetricHasherConfig::clear_noise_shaping_threshold() {
  noise_shaping_threshold_ = std::numeric_limits<double>::quiet_NaN();
  _has_bits_[0] &= ~0x10000000u;
}
inline double AsymmetricHasherConfig::noise_shaping_threshold() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.noise_shaping_threshold)
  return noise_shaping_threshold_;
}
inline void AsymmetricHasherConfig::set_noise_shaping_threshold(double value) {
  _has_bits_[0] |= 0x10000000u;
  noise_shaping_threshold_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.noise_shaping_threshold)
}

// optional bool use_norm_biasing_correction = 31 [default = false];
inline bool AsymmetricHasherConfig::has_use_norm_biasing_correction() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void AsymmetricHasherConfig::clear_use_norm_biasing_correction() {
  use_norm_biasing_correction_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool AsymmetricHasherConfig::use_norm_biasing_correction() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.use_norm_biasing_correction)
  return use_norm_biasing_correction_;
}
inline void AsymmetricHasherConfig::set_use_norm_biasing_correction(bool value) {
  _has_bits_[0] |= 0x00020000u;
  use_norm_biasing_correction_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.use_norm_biasing_correction)
}

// optional bool use_global_topn = 33 [default = false];
inline bool AsymmetricHasherConfig::has_use_global_topn() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AsymmetricHasherConfig::clear_use_global_topn() {
  use_global_topn_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool AsymmetricHasherConfig::use_global_topn() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.use_global_topn)
  return use_global_topn_;
}
inline void AsymmetricHasherConfig::set_use_global_topn(bool value) {
  _has_bits_[0] |= 0x00040000u;
  use_global_topn_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.use_global_topn)
}

// optional bool use_noise_shaped_training = 30 [default = false];
inline bool AsymmetricHasherConfig::has_use_noise_shaped_training() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AsymmetricHasherConfig::clear_use_noise_shaped_training() {
  use_noise_shaped_training_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool AsymmetricHasherConfig::use_noise_shaped_training() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.use_noise_shaped_training)
  return use_noise_shaped_training_;
}
inline void AsymmetricHasherConfig::set_use_noise_shaped_training(bool value) {
  _has_bits_[0] |= 0x00000100u;
  use_noise_shaped_training_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.use_noise_shaped_training)
}

// optional .research_scann.AsymmetricHasherConfig.FixedPointLUTConversionOptions fixed_point_lut_conversion_options = 25;
inline bool AsymmetricHasherConfig::has_fixed_point_lut_conversion_options() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AsymmetricHasherConfig::clear_fixed_point_lut_conversion_options() {
  if (fixed_point_lut_conversion_options_ != nullptr) fixed_point_lut_conversion_options_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions& AsymmetricHasherConfig::fixed_point_lut_conversion_options() const {
  const ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* p = fixed_point_lut_conversion_options_;
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.fixed_point_lut_conversion_options)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions*>(
      &::research_scann::_AsymmetricHasherConfig_FixedPointLUTConversionOptions_default_instance_);
}
inline ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* AsymmetricHasherConfig::release_fixed_point_lut_conversion_options() {
  // @@protoc_insertion_point(field_release:research_scann.AsymmetricHasherConfig.fixed_point_lut_conversion_options)
  _has_bits_[0] &= ~0x00000040u;
  ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* temp = fixed_point_lut_conversion_options_;
  fixed_point_lut_conversion_options_ = nullptr;
  return temp;
}
inline ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* AsymmetricHasherConfig::mutable_fixed_point_lut_conversion_options() {
  _has_bits_[0] |= 0x00000040u;
  if (fixed_point_lut_conversion_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions>(GetArenaNoVirtual());
    fixed_point_lut_conversion_options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.AsymmetricHasherConfig.fixed_point_lut_conversion_options)
  return fixed_point_lut_conversion_options_;
}
inline void AsymmetricHasherConfig::set_allocated_fixed_point_lut_conversion_options(::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions* fixed_point_lut_conversion_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete fixed_point_lut_conversion_options_;
  }
  if (fixed_point_lut_conversion_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fixed_point_lut_conversion_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fixed_point_lut_conversion_options, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  fixed_point_lut_conversion_options_ = fixed_point_lut_conversion_options;
  // @@protoc_insertion_point(field_set_allocated:research_scann.AsymmetricHasherConfig.fixed_point_lut_conversion_options)
}

// optional float sampling_fraction = 10 [default = 1];
inline bool AsymmetricHasherConfig::has_sampling_fraction() const {
  return SamplingFractionOrExpectedSize_case() == kSamplingFraction;
}
inline void AsymmetricHasherConfig::set_has_sampling_fraction() {
  _oneof_case_[0] = kSamplingFraction;
}
inline void AsymmetricHasherConfig::clear_sampling_fraction() {
  if (has_sampling_fraction()) {
    SamplingFractionOrExpectedSize_.sampling_fraction_ = 1;
    clear_has_SamplingFractionOrExpectedSize();
  }
}
inline float AsymmetricHasherConfig::sampling_fraction() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.sampling_fraction)
  if (has_sampling_fraction()) {
    return SamplingFractionOrExpectedSize_.sampling_fraction_;
  }
  return 1;
}
inline void AsymmetricHasherConfig::set_sampling_fraction(float value) {
  if (!has_sampling_fraction()) {
    clear_SamplingFractionOrExpectedSize();
    set_has_sampling_fraction();
  }
  SamplingFractionOrExpectedSize_.sampling_fraction_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.sampling_fraction)
}

// optional int32 expected_sample_size = 29;
inline bool AsymmetricHasherConfig::has_expected_sample_size() const {
  return SamplingFractionOrExpectedSize_case() == kExpectedSampleSize;
}
inline void AsymmetricHasherConfig::set_has_expected_sample_size() {
  _oneof_case_[0] = kExpectedSampleSize;
}
inline void AsymmetricHasherConfig::clear_expected_sample_size() {
  if (has_expected_sample_size()) {
    SamplingFractionOrExpectedSize_.expected_sample_size_ = 0;
    clear_has_SamplingFractionOrExpectedSize();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AsymmetricHasherConfig::expected_sample_size() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.expected_sample_size)
  if (has_expected_sample_size()) {
    return SamplingFractionOrExpectedSize_.expected_sample_size_;
  }
  return 0;
}
inline void AsymmetricHasherConfig::set_expected_sample_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  if (!has_expected_sample_size()) {
    clear_SamplingFractionOrExpectedSize();
    set_has_expected_sample_size();
  }
  SamplingFractionOrExpectedSize_.expected_sample_size_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.expected_sample_size)
}

// optional int32 sampling_seed = 11 [default = 1];
inline bool AsymmetricHasherConfig::has_sampling_seed() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void AsymmetricHasherConfig::clear_sampling_seed() {
  sampling_seed_ = 1;
  _has_bits_[0] &= ~0x02000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AsymmetricHasherConfig::sampling_seed() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.sampling_seed)
  return sampling_seed_;
}
inline void AsymmetricHasherConfig::set_sampling_seed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x02000000u;
  sampling_seed_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.sampling_seed)
}

// optional .research_scann.DistanceMeasureConfig quantization_distance = 18;
inline bool AsymmetricHasherConfig::has_quantization_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline const ::research_scann::DistanceMeasureConfig& AsymmetricHasherConfig::quantization_distance() const {
  const ::research_scann::DistanceMeasureConfig* p = quantization_distance_;
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.quantization_distance)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::DistanceMeasureConfig*>(
      &::research_scann::_DistanceMeasureConfig_default_instance_);
}
inline ::research_scann::DistanceMeasureConfig* AsymmetricHasherConfig::release_quantization_distance() {
  // @@protoc_insertion_point(field_release:research_scann.AsymmetricHasherConfig.quantization_distance)
  _has_bits_[0] &= ~0x00000010u;
  ::research_scann::DistanceMeasureConfig* temp = quantization_distance_;
  quantization_distance_ = nullptr;
  return temp;
}
inline ::research_scann::DistanceMeasureConfig* AsymmetricHasherConfig::mutable_quantization_distance() {
  _has_bits_[0] |= 0x00000010u;
  if (quantization_distance_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::DistanceMeasureConfig>(GetArenaNoVirtual());
    quantization_distance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.AsymmetricHasherConfig.quantization_distance)
  return quantization_distance_;
}
inline void AsymmetricHasherConfig::set_allocated_quantization_distance(::research_scann::DistanceMeasureConfig* quantization_distance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(quantization_distance_);
  }
  if (quantization_distance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      quantization_distance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quantization_distance, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  quantization_distance_ = quantization_distance;
  // @@protoc_insertion_point(field_set_allocated:research_scann.AsymmetricHasherConfig.quantization_distance)
}

// optional int32 max_clustering_iterations = 4 [default = 10];
inline bool AsymmetricHasherConfig::has_max_clustering_iterations() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void AsymmetricHasherConfig::clear_max_clustering_iterations() {
  max_clustering_iterations_ = 10;
  _has_bits_[0] &= ~0x00400000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AsymmetricHasherConfig::max_clustering_iterations() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.max_clustering_iterations)
  return max_clustering_iterations_;
}
inline void AsymmetricHasherConfig::set_max_clustering_iterations(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00400000u;
  max_clustering_iterations_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.max_clustering_iterations)
}

// optional float clustering_convergence_tolerance = 5 [default = 1e-05];
inline bool AsymmetricHasherConfig::has_clustering_convergence_tolerance() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void AsymmetricHasherConfig::clear_clustering_convergence_tolerance() {
  clustering_convergence_tolerance_ = 1e-05f;
  _has_bits_[0] &= ~0x00800000u;
}
inline float AsymmetricHasherConfig::clustering_convergence_tolerance() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.clustering_convergence_tolerance)
  return clustering_convergence_tolerance_;
}
inline void AsymmetricHasherConfig::set_clustering_convergence_tolerance(float value) {
  _has_bits_[0] |= 0x00800000u;
  clustering_convergence_tolerance_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.clustering_convergence_tolerance)
}

// optional float min_cluster_size = 19 [default = 1];
inline bool AsymmetricHasherConfig::has_min_cluster_size() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void AsymmetricHasherConfig::clear_min_cluster_size() {
  min_cluster_size_ = 1;
  _has_bits_[0] &= ~0x00080000u;
}
inline float AsymmetricHasherConfig::min_cluster_size() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.min_cluster_size)
  return min_cluster_size_;
}
inline void AsymmetricHasherConfig::set_min_cluster_size(float value) {
  _has_bits_[0] |= 0x00080000u;
  min_cluster_size_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.min_cluster_size)
}

// optional string centers_filename = 6;
inline bool AsymmetricHasherConfig::has_centers_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AsymmetricHasherConfig::clear_centers_filename() {
  centers_filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AsymmetricHasherConfig::centers_filename() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.centers_filename)
  return centers_filename_.GetNoArena();
}
inline void AsymmetricHasherConfig::set_centers_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  centers_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.centers_filename)
}
inline void AsymmetricHasherConfig::set_centers_filename(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  centers_filename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.AsymmetricHasherConfig.centers_filename)
}
inline void AsymmetricHasherConfig::set_centers_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  centers_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.AsymmetricHasherConfig.centers_filename)
}
inline void AsymmetricHasherConfig::set_centers_filename(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  centers_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.AsymmetricHasherConfig.centers_filename)
}
inline std::string* AsymmetricHasherConfig::mutable_centers_filename() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:research_scann.AsymmetricHasherConfig.centers_filename)
  return centers_filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AsymmetricHasherConfig::release_centers_filename() {
  // @@protoc_insertion_point(field_release:research_scann.AsymmetricHasherConfig.centers_filename)
  if (!has_centers_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return centers_filename_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AsymmetricHasherConfig::set_allocated_centers_filename(std::string* centers_filename) {
  if (centers_filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  centers_filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), centers_filename);
  // @@protoc_insertion_point(field_set_allocated:research_scann.AsymmetricHasherConfig.centers_filename)
}

// optional int32 num_machines = 27;
inline bool AsymmetricHasherConfig::has_num_machines() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AsymmetricHasherConfig::clear_num_machines() {
  num_machines_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AsymmetricHasherConfig::num_machines() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.num_machines)
  return num_machines_;
}
inline void AsymmetricHasherConfig::set_num_machines(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00004000u;
  num_machines_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.num_machines)
}

// optional bool use_per_leaf_partition_training = 17 [default = false];
inline bool AsymmetricHasherConfig::has_use_per_leaf_partition_training() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AsymmetricHasherConfig::clear_use_per_leaf_partition_training() {
  use_per_leaf_partition_training_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool AsymmetricHasherConfig::use_per_leaf_partition_training() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.use_per_leaf_partition_training)
  return use_per_leaf_partition_training_;
}
inline void AsymmetricHasherConfig::set_use_per_leaf_partition_training(bool value) {
  _has_bits_[0] |= 0x00000200u;
  use_per_leaf_partition_training_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.use_per_leaf_partition_training)
}

// optional string mr_jobname_prefix = 12;
inline bool AsymmetricHasherConfig::has_mr_jobname_prefix() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AsymmetricHasherConfig::clear_mr_jobname_prefix() {
  mr_jobname_prefix_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AsymmetricHasherConfig::mr_jobname_prefix() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.mr_jobname_prefix)
  return mr_jobname_prefix_.GetNoArena();
}
inline void AsymmetricHasherConfig::set_mr_jobname_prefix(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  mr_jobname_prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.mr_jobname_prefix)
}
inline void AsymmetricHasherConfig::set_mr_jobname_prefix(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  mr_jobname_prefix_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.AsymmetricHasherConfig.mr_jobname_prefix)
}
inline void AsymmetricHasherConfig::set_mr_jobname_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  mr_jobname_prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.AsymmetricHasherConfig.mr_jobname_prefix)
}
inline void AsymmetricHasherConfig::set_mr_jobname_prefix(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  mr_jobname_prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.AsymmetricHasherConfig.mr_jobname_prefix)
}
inline std::string* AsymmetricHasherConfig::mutable_mr_jobname_prefix() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:research_scann.AsymmetricHasherConfig.mr_jobname_prefix)
  return mr_jobname_prefix_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AsymmetricHasherConfig::release_mr_jobname_prefix() {
  // @@protoc_insertion_point(field_release:research_scann.AsymmetricHasherConfig.mr_jobname_prefix)
  if (!has_mr_jobname_prefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return mr_jobname_prefix_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AsymmetricHasherConfig::set_allocated_mr_jobname_prefix(std::string* mr_jobname_prefix) {
  if (mr_jobname_prefix != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mr_jobname_prefix_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mr_jobname_prefix);
  // @@protoc_insertion_point(field_set_allocated:research_scann.AsymmetricHasherConfig.mr_jobname_prefix)
}

// optional string cell = 13;
inline bool AsymmetricHasherConfig::has_cell() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AsymmetricHasherConfig::clear_cell() {
  cell_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AsymmetricHasherConfig::cell() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.cell)
  return cell_.GetNoArena();
}
inline void AsymmetricHasherConfig::set_cell(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  cell_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.cell)
}
inline void AsymmetricHasherConfig::set_cell(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  cell_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.AsymmetricHasherConfig.cell)
}
inline void AsymmetricHasherConfig::set_cell(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  cell_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.AsymmetricHasherConfig.cell)
}
inline void AsymmetricHasherConfig::set_cell(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  cell_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.AsymmetricHasherConfig.cell)
}
inline std::string* AsymmetricHasherConfig::mutable_cell() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:research_scann.AsymmetricHasherConfig.cell)
  return cell_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AsymmetricHasherConfig::release_cell() {
  // @@protoc_insertion_point(field_release:research_scann.AsymmetricHasherConfig.cell)
  if (!has_cell()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return cell_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AsymmetricHasherConfig::set_allocated_cell(std::string* cell) {
  if (cell != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  cell_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cell);
  // @@protoc_insertion_point(field_set_allocated:research_scann.AsymmetricHasherConfig.cell)
}

// optional int32 ram_gb = 14 [default = 4];
inline bool AsymmetricHasherConfig::has_ram_gb() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void AsymmetricHasherConfig::clear_ram_gb() {
  ram_gb_ = 4;
  _has_bits_[0] &= ~0x04000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AsymmetricHasherConfig::ram_gb() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.ram_gb)
  return ram_gb_;
}
inline void AsymmetricHasherConfig::set_ram_gb(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x04000000u;
  ram_gb_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.ram_gb)
}

// optional int32 num_cpus = 15 [default = 1];
inline bool AsymmetricHasherConfig::has_num_cpus() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void AsymmetricHasherConfig::clear_num_cpus() {
  num_cpus_ = 1;
  _has_bits_[0] &= ~0x08000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AsymmetricHasherConfig::num_cpus() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.num_cpus)
  return num_cpus_;
}
inline void AsymmetricHasherConfig::set_num_cpus(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x08000000u;
  num_cpus_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.num_cpus)
}

// optional .research_scann.AsymmetricHasherConfig.QuantizationScheme quantization_scheme = 23 [default = PRODUCT];
inline bool AsymmetricHasherConfig::has_quantization_scheme() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AsymmetricHasherConfig::clear_quantization_scheme() {
  quantization_scheme_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::research_scann::AsymmetricHasherConfig_QuantizationScheme AsymmetricHasherConfig::quantization_scheme() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.quantization_scheme)
  return static_cast< ::research_scann::AsymmetricHasherConfig_QuantizationScheme >(quantization_scheme_);
}
inline void AsymmetricHasherConfig::set_quantization_scheme(::research_scann::AsymmetricHasherConfig_QuantizationScheme value) {
  assert(::research_scann::AsymmetricHasherConfig_QuantizationScheme_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  quantization_scheme_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.quantization_scheme)
}

// optional .research_scann.StackedQuantizersConfig stacked_quantizers_config = 24;
inline bool AsymmetricHasherConfig::has_stacked_quantizers_config() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AsymmetricHasherConfig::clear_stacked_quantizers_config() {
  if (stacked_quantizers_config_ != nullptr) stacked_quantizers_config_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::research_scann::StackedQuantizersConfig& AsymmetricHasherConfig::stacked_quantizers_config() const {
  const ::research_scann::StackedQuantizersConfig* p = stacked_quantizers_config_;
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.stacked_quantizers_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::StackedQuantizersConfig*>(
      &::research_scann::_StackedQuantizersConfig_default_instance_);
}
inline ::research_scann::StackedQuantizersConfig* AsymmetricHasherConfig::release_stacked_quantizers_config() {
  // @@protoc_insertion_point(field_release:research_scann.AsymmetricHasherConfig.stacked_quantizers_config)
  _has_bits_[0] &= ~0x00000020u;
  ::research_scann::StackedQuantizersConfig* temp = stacked_quantizers_config_;
  stacked_quantizers_config_ = nullptr;
  return temp;
}
inline ::research_scann::StackedQuantizersConfig* AsymmetricHasherConfig::mutable_stacked_quantizers_config() {
  _has_bits_[0] |= 0x00000020u;
  if (stacked_quantizers_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::StackedQuantizersConfig>(GetArenaNoVirtual());
    stacked_quantizers_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.AsymmetricHasherConfig.stacked_quantizers_config)
  return stacked_quantizers_config_;
}
inline void AsymmetricHasherConfig::set_allocated_stacked_quantizers_config(::research_scann::StackedQuantizersConfig* stacked_quantizers_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete stacked_quantizers_config_;
  }
  if (stacked_quantizers_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stacked_quantizers_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stacked_quantizers_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  stacked_quantizers_config_ = stacked_quantizers_config;
  // @@protoc_insertion_point(field_set_allocated:research_scann.AsymmetricHasherConfig.stacked_quantizers_config)
}

// optional float partition_level_confidence_interval_stdevs = 26 [default = 0, deprecated = true];
inline bool AsymmetricHasherConfig::has_partition_level_confidence_interval_stdevs() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AsymmetricHasherConfig::clear_partition_level_confidence_interval_stdevs() {
  partition_level_confidence_interval_stdevs_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline float AsymmetricHasherConfig::partition_level_confidence_interval_stdevs() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.partition_level_confidence_interval_stdevs)
  return partition_level_confidence_interval_stdevs_;
}
inline void AsymmetricHasherConfig::set_partition_level_confidence_interval_stdevs(float value) {
  _has_bits_[0] |= 0x00002000u;
  partition_level_confidence_interval_stdevs_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.partition_level_confidence_interval_stdevs)
}

// optional bool use_single_machine_trainer = 8 [default = false, deprecated = true];
inline bool AsymmetricHasherConfig::has_use_single_machine_trainer() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AsymmetricHasherConfig::clear_use_single_machine_trainer() {
  use_single_machine_trainer_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool AsymmetricHasherConfig::use_single_machine_trainer() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.use_single_machine_trainer)
  return use_single_machine_trainer_;
}
inline void AsymmetricHasherConfig::set_use_single_machine_trainer(bool value) {
  _has_bits_[0] |= 0x00000400u;
  use_single_machine_trainer_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.use_single_machine_trainer)
}

// optional int32 min_number_machines = 7 [deprecated = true];
inline bool AsymmetricHasherConfig::has_min_number_machines() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AsymmetricHasherConfig::clear_min_number_machines() {
  min_number_machines_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AsymmetricHasherConfig::min_number_machines() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.min_number_machines)
  return min_number_machines_;
}
inline void AsymmetricHasherConfig::set_min_number_machines(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  min_number_machines_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.min_number_machines)
}

// optional int32 max_sample_size = 3 [default = 2147483647];
inline bool AsymmetricHasherConfig::has_max_sample_size() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void AsymmetricHasherConfig::clear_max_sample_size() {
  max_sample_size_ = 2147483647;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AsymmetricHasherConfig::max_sample_size() const {
  // @@protoc_insertion_point(field_get:research_scann.AsymmetricHasherConfig.max_sample_size)
  return max_sample_size_;
}
inline void AsymmetricHasherConfig::set_max_sample_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00200000u;
  max_sample_size_ = value;
  // @@protoc_insertion_point(field_set:research_scann.AsymmetricHasherConfig.max_sample_size)
}

inline bool AsymmetricHasherConfig::has_SamplingFractionOrExpectedSize() const {
  return SamplingFractionOrExpectedSize_case() != SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET;
}
inline void AsymmetricHasherConfig::clear_has_SamplingFractionOrExpectedSize() {
  _oneof_case_[0] = SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET;
}
inline AsymmetricHasherConfig::SamplingFractionOrExpectedSizeCase AsymmetricHasherConfig::SamplingFractionOrExpectedSize_case() const {
  return AsymmetricHasherConfig::SamplingFractionOrExpectedSizeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MinHasherConfig

// optional int32 config_id = 1;
inline bool MinHasherConfig::has_config_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MinHasherConfig::clear_config_id() {
  config_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MinHasherConfig::config_id() const {
  // @@protoc_insertion_point(field_get:research_scann.MinHasherConfig.config_id)
  return config_id_;
}
inline void MinHasherConfig::set_config_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  config_id_ = value;
  // @@protoc_insertion_point(field_set:research_scann.MinHasherConfig.config_id)
}

// optional int32 num_sketches = 2;
inline bool MinHasherConfig::has_num_sketches() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MinHasherConfig::clear_num_sketches() {
  num_sketches_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MinHasherConfig::num_sketches() const {
  // @@protoc_insertion_point(field_get:research_scann.MinHasherConfig.num_sketches)
  return num_sketches_;
}
inline void MinHasherConfig::set_num_sketches(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_sketches_ = value;
  // @@protoc_insertion_point(field_set:research_scann.MinHasherConfig.num_sketches)
}

// optional int32 num_hashes = 3;
inline bool MinHasherConfig::has_num_hashes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MinHasherConfig::clear_num_hashes() {
  num_hashes_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MinHasherConfig::num_hashes() const {
  // @@protoc_insertion_point(field_get:research_scann.MinHasherConfig.num_hashes)
  return num_hashes_;
}
inline void MinHasherConfig::set_num_hashes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  num_hashes_ = value;
  // @@protoc_insertion_point(field_set:research_scann.MinHasherConfig.num_hashes)
}

// repeated int64 seeds = 4;
inline int MinHasherConfig::seeds_size() const {
  return seeds_.size();
}
inline void MinHasherConfig::clear_seeds() {
  seeds_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MinHasherConfig::seeds(int index) const {
  // @@protoc_insertion_point(field_get:research_scann.MinHasherConfig.seeds)
  return seeds_.Get(index);
}
inline void MinHasherConfig::set_seeds(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  seeds_.Set(index, value);
  // @@protoc_insertion_point(field_set:research_scann.MinHasherConfig.seeds)
}
inline void MinHasherConfig::add_seeds(::PROTOBUF_NAMESPACE_ID::int64 value) {
  seeds_.Add(value);
  // @@protoc_insertion_point(field_add:research_scann.MinHasherConfig.seeds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
MinHasherConfig::seeds() const {
  // @@protoc_insertion_point(field_list:research_scann.MinHasherConfig.seeds)
  return seeds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
MinHasherConfig::mutable_seeds() {
  // @@protoc_insertion_point(field_mutable_list:research_scann.MinHasherConfig.seeds)
  return &seeds_;
}

// optional int32 num_bits_per_hash = 5;
inline bool MinHasherConfig::has_num_bits_per_hash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MinHasherConfig::clear_num_bits_per_hash() {
  num_bits_per_hash_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MinHasherConfig::num_bits_per_hash() const {
  // @@protoc_insertion_point(field_get:research_scann.MinHasherConfig.num_bits_per_hash)
  return num_bits_per_hash_;
}
inline void MinHasherConfig::set_num_bits_per_hash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  num_bits_per_hash_ = value;
  // @@protoc_insertion_point(field_set:research_scann.MinHasherConfig.num_bits_per_hash)
}

// -------------------------------------------------------------------

// BitSamplingHasherConfig

// optional int32 num_bits = 1 [default = 3];
inline bool BitSamplingHasherConfig::has_num_bits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BitSamplingHasherConfig::clear_num_bits() {
  num_bits_ = 3;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BitSamplingHasherConfig::num_bits() const {
  // @@protoc_insertion_point(field_get:research_scann.BitSamplingHasherConfig.num_bits)
  return num_bits_;
}
inline void BitSamplingHasherConfig::set_num_bits(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_bits_ = value;
  // @@protoc_insertion_point(field_set:research_scann.BitSamplingHasherConfig.num_bits)
}

// optional bool use_entropy = 2 [default = false];
inline bool BitSamplingHasherConfig::has_use_entropy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BitSamplingHasherConfig::clear_use_entropy() {
  use_entropy_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool BitSamplingHasherConfig::use_entropy() const {
  // @@protoc_insertion_point(field_get:research_scann.BitSamplingHasherConfig.use_entropy)
  return use_entropy_;
}
inline void BitSamplingHasherConfig::set_use_entropy(bool value) {
  _has_bits_[0] |= 0x00000001u;
  use_entropy_ = value;
  // @@protoc_insertion_point(field_set:research_scann.BitSamplingHasherConfig.use_entropy)
}

// -------------------------------------------------------------------

// PcaHasherConfig

// optional bool rotate_projections = 1 [default = false];
inline bool PcaHasherConfig::has_rotate_projections() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PcaHasherConfig::clear_rotate_projections() {
  rotate_projections_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool PcaHasherConfig::rotate_projections() const {
  // @@protoc_insertion_point(field_get:research_scann.PcaHasherConfig.rotate_projections)
  return rotate_projections_;
}
inline void PcaHasherConfig::set_rotate_projections(bool value) {
  _has_bits_[0] |= 0x00000001u;
  rotate_projections_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PcaHasherConfig.rotate_projections)
}

// optional float sampling_fraction = 2 [default = 1];
inline bool PcaHasherConfig::has_sampling_fraction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PcaHasherConfig::clear_sampling_fraction() {
  sampling_fraction_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline float PcaHasherConfig::sampling_fraction() const {
  // @@protoc_insertion_point(field_get:research_scann.PcaHasherConfig.sampling_fraction)
  return sampling_fraction_;
}
inline void PcaHasherConfig::set_sampling_fraction(float value) {
  _has_bits_[0] |= 0x00000008u;
  sampling_fraction_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PcaHasherConfig.sampling_fraction)
}

// optional int32 sampling_seed = 3 [default = 1];
inline bool PcaHasherConfig::has_sampling_seed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PcaHasherConfig::clear_sampling_seed() {
  sampling_seed_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PcaHasherConfig::sampling_seed() const {
  // @@protoc_insertion_point(field_get:research_scann.PcaHasherConfig.sampling_seed)
  return sampling_seed_;
}
inline void PcaHasherConfig::set_sampling_seed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  sampling_seed_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PcaHasherConfig.sampling_seed)
}

// optional int32 max_sample_size = 4;
inline bool PcaHasherConfig::has_max_sample_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PcaHasherConfig::clear_max_sample_size() {
  max_sample_size_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PcaHasherConfig::max_sample_size() const {
  // @@protoc_insertion_point(field_get:research_scann.PcaHasherConfig.max_sample_size)
  return max_sample_size_;
}
inline void PcaHasherConfig::set_max_sample_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  max_sample_size_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PcaHasherConfig.max_sample_size)
}

// optional bool learn_projections = 5 [default = false];
inline bool PcaHasherConfig::has_learn_projections() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PcaHasherConfig::clear_learn_projections() {
  learn_projections_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool PcaHasherConfig::learn_projections() const {
  // @@protoc_insertion_point(field_get:research_scann.PcaHasherConfig.learn_projections)
  return learn_projections_;
}
inline void PcaHasherConfig::set_learn_projections(bool value) {
  _has_bits_[0] |= 0x00000002u;
  learn_projections_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PcaHasherConfig.learn_projections)
}

// optional int32 max_num_iteration = 6 [default = 40];
inline bool PcaHasherConfig::has_max_num_iteration() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PcaHasherConfig::clear_max_num_iteration() {
  max_num_iteration_ = 40;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PcaHasherConfig::max_num_iteration() const {
  // @@protoc_insertion_point(field_get:research_scann.PcaHasherConfig.max_num_iteration)
  return max_num_iteration_;
}
inline void PcaHasherConfig::set_max_num_iteration(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  max_num_iteration_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PcaHasherConfig.max_num_iteration)
}

// optional float iteration_tolerance = 7 [default = 1e-05];
inline bool PcaHasherConfig::has_iteration_tolerance() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PcaHasherConfig::clear_iteration_tolerance() {
  iteration_tolerance_ = 1e-05f;
  _has_bits_[0] &= ~0x00000040u;
}
inline float PcaHasherConfig::iteration_tolerance() const {
  // @@protoc_insertion_point(field_get:research_scann.PcaHasherConfig.iteration_tolerance)
  return iteration_tolerance_;
}
inline void PcaHasherConfig::set_iteration_tolerance(float value) {
  _has_bits_[0] |= 0x00000040u;
  iteration_tolerance_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PcaHasherConfig.iteration_tolerance)
}

// -------------------------------------------------------------------

// BncHasherConfig

// optional float compression_ratio = 1 [default = 0];
inline bool BncHasherConfig::has_compression_ratio() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BncHasherConfig::clear_compression_ratio() {
  compression_ratio_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float BncHasherConfig::compression_ratio() const {
  // @@protoc_insertion_point(field_get:research_scann.BncHasherConfig.compression_ratio)
  return compression_ratio_;
}
inline void BncHasherConfig::set_compression_ratio(float value) {
  _has_bits_[0] |= 0x00000001u;
  compression_ratio_ = value;
  // @@protoc_insertion_point(field_set:research_scann.BncHasherConfig.compression_ratio)
}

// optional float gamma = 2 [default = 10];
inline bool BncHasherConfig::has_gamma() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BncHasherConfig::clear_gamma() {
  gamma_ = 10;
  _has_bits_[0] &= ~0x00000004u;
}
inline float BncHasherConfig::gamma() const {
  // @@protoc_insertion_point(field_get:research_scann.BncHasherConfig.gamma)
  return gamma_;
}
inline void BncHasherConfig::set_gamma(float value) {
  _has_bits_[0] |= 0x00000004u;
  gamma_ = value;
  // @@protoc_insertion_point(field_set:research_scann.BncHasherConfig.gamma)
}

// optional float learning_rate = 3 [default = 0.1];
inline bool BncHasherConfig::has_learning_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BncHasherConfig::clear_learning_rate() {
  learning_rate_ = 0.1f;
  _has_bits_[0] &= ~0x00000008u;
}
inline float BncHasherConfig::learning_rate() const {
  // @@protoc_insertion_point(field_get:research_scann.BncHasherConfig.learning_rate)
  return learning_rate_;
}
inline void BncHasherConfig::set_learning_rate(float value) {
  _has_bits_[0] |= 0x00000008u;
  learning_rate_ = value;
  // @@protoc_insertion_point(field_set:research_scann.BncHasherConfig.learning_rate)
}

// optional int32 batch_size = 4 [default = 128];
inline bool BncHasherConfig::has_batch_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BncHasherConfig::clear_batch_size() {
  batch_size_ = 128;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BncHasherConfig::batch_size() const {
  // @@protoc_insertion_point(field_get:research_scann.BncHasherConfig.batch_size)
  return batch_size_;
}
inline void BncHasherConfig::set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  batch_size_ = value;
  // @@protoc_insertion_point(field_set:research_scann.BncHasherConfig.batch_size)
}

// optional int32 num_phase1_iterations = 5 [default = 50];
inline bool BncHasherConfig::has_num_phase1_iterations() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BncHasherConfig::clear_num_phase1_iterations() {
  num_phase1_iterations_ = 50;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BncHasherConfig::num_phase1_iterations() const {
  // @@protoc_insertion_point(field_get:research_scann.BncHasherConfig.num_phase1_iterations)
  return num_phase1_iterations_;
}
inline void BncHasherConfig::set_num_phase1_iterations(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  num_phase1_iterations_ = value;
  // @@protoc_insertion_point(field_set:research_scann.BncHasherConfig.num_phase1_iterations)
}

// optional int32 num_phase2_iterations = 6 [default = 100];
inline bool BncHasherConfig::has_num_phase2_iterations() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BncHasherConfig::clear_num_phase2_iterations() {
  num_phase2_iterations_ = 100;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BncHasherConfig::num_phase2_iterations() const {
  // @@protoc_insertion_point(field_get:research_scann.BncHasherConfig.num_phase2_iterations)
  return num_phase2_iterations_;
}
inline void BncHasherConfig::set_num_phase2_iterations(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  num_phase2_iterations_ = value;
  // @@protoc_insertion_point(field_set:research_scann.BncHasherConfig.num_phase2_iterations)
}

// optional int32 sampling_seed = 7 [default = 1];
inline bool BncHasherConfig::has_sampling_seed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BncHasherConfig::clear_sampling_seed() {
  sampling_seed_ = 1;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BncHasherConfig::sampling_seed() const {
  // @@protoc_insertion_point(field_get:research_scann.BncHasherConfig.sampling_seed)
  return sampling_seed_;
}
inline void BncHasherConfig::set_sampling_seed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  sampling_seed_ = value;
  // @@protoc_insertion_point(field_set:research_scann.BncHasherConfig.sampling_seed)
}

// optional int32 num_cpus = 8 [default = 1];
inline bool BncHasherConfig::has_num_cpus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BncHasherConfig::clear_num_cpus() {
  num_cpus_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BncHasherConfig::num_cpus() const {
  // @@protoc_insertion_point(field_get:research_scann.BncHasherConfig.num_cpus)
  return num_cpus_;
}
inline void BncHasherConfig::set_num_cpus(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_cpus_ = value;
  // @@protoc_insertion_point(field_set:research_scann.BncHasherConfig.num_cpus)
}

// -------------------------------------------------------------------

// StackedQuantizersConfig

// optional int32 min_num_iterations = 1 [default = 3];
inline bool StackedQuantizersConfig::has_min_num_iterations() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StackedQuantizersConfig::clear_min_num_iterations() {
  min_num_iterations_ = 3;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StackedQuantizersConfig::min_num_iterations() const {
  // @@protoc_insertion_point(field_get:research_scann.StackedQuantizersConfig.min_num_iterations)
  return min_num_iterations_;
}
inline void StackedQuantizersConfig::set_min_num_iterations(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  min_num_iterations_ = value;
  // @@protoc_insertion_point(field_set:research_scann.StackedQuantizersConfig.min_num_iterations)
}

// optional int32 max_num_iterations = 2 [default = 10];
inline bool StackedQuantizersConfig::has_max_num_iterations() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StackedQuantizersConfig::clear_max_num_iterations() {
  max_num_iterations_ = 10;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StackedQuantizersConfig::max_num_iterations() const {
  // @@protoc_insertion_point(field_get:research_scann.StackedQuantizersConfig.max_num_iterations)
  return max_num_iterations_;
}
inline void StackedQuantizersConfig::set_max_num_iterations(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  max_num_iterations_ = value;
  // @@protoc_insertion_point(field_set:research_scann.StackedQuantizersConfig.max_num_iterations)
}

// optional float relative_improvement_threshold = 3 [default = 0.001];
inline bool StackedQuantizersConfig::has_relative_improvement_threshold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StackedQuantizersConfig::clear_relative_improvement_threshold() {
  relative_improvement_threshold_ = 0.001f;
  _has_bits_[0] &= ~0x00000001u;
}
inline float StackedQuantizersConfig::relative_improvement_threshold() const {
  // @@protoc_insertion_point(field_get:research_scann.StackedQuantizersConfig.relative_improvement_threshold)
  return relative_improvement_threshold_;
}
inline void StackedQuantizersConfig::set_relative_improvement_threshold(float value) {
  _has_bits_[0] |= 0x00000001u;
  relative_improvement_threshold_ = value;
  // @@protoc_insertion_point(field_set:research_scann.StackedQuantizersConfig.relative_improvement_threshold)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace research_scann

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::research_scann::HashConfig_ThresholdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::HashConfig_ThresholdType>() {
  return ::research_scann::HashConfig_ThresholdType_descriptor();
}
template <> struct is_proto_enum< ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod>() {
  return ::research_scann::AsymmetricHasherConfig_FixedPointLUTConversionOptions_FloatToIntConversionMethod_descriptor();
}
template <> struct is_proto_enum< ::research_scann::AsymmetricHasherConfig_LookupType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::AsymmetricHasherConfig_LookupType>() {
  return ::research_scann::AsymmetricHasherConfig_LookupType_descriptor();
}
template <> struct is_proto_enum< ::research_scann::AsymmetricHasherConfig_QuantizationScheme> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::AsymmetricHasherConfig_QuantizationScheme>() {
  return ::research_scann::AsymmetricHasherConfig_QuantizationScheme_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2fhash_2eproto
