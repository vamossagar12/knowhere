// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scann/proto/input_output.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2finput_5foutput_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2finput_5foutput_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "scann/proto/incremental_updates.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_scann_2fproto_2finput_5foutput_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_scann_2fproto_2finput_5foutput_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scann_2fproto_2finput_5foutput_2eproto;
namespace research_scann {
class InputOutputConfig;
class InputOutputConfigDefaultTypeInternal;
extern InputOutputConfigDefaultTypeInternal _InputOutputConfig_default_instance_;
class InputOutputConfig_PreprocessingFunction;
class InputOutputConfig_PreprocessingFunctionDefaultTypeInternal;
extern InputOutputConfig_PreprocessingFunctionDefaultTypeInternal _InputOutputConfig_PreprocessingFunction_default_instance_;
class InputOutputConfig_PureDynamicConfig;
class InputOutputConfig_PureDynamicConfigDefaultTypeInternal;
extern InputOutputConfig_PureDynamicConfigDefaultTypeInternal _InputOutputConfig_PureDynamicConfig_default_instance_;
class InputOutputConfig_TeamsterConfig;
class InputOutputConfig_TeamsterConfigDefaultTypeInternal;
extern InputOutputConfig_TeamsterConfigDefaultTypeInternal _InputOutputConfig_TeamsterConfig_default_instance_;
}  // namespace research_scann
PROTOBUF_NAMESPACE_OPEN
template<> ::research_scann::InputOutputConfig* Arena::CreateMaybeMessage<::research_scann::InputOutputConfig>(Arena*);
template<> ::research_scann::InputOutputConfig_PreprocessingFunction* Arena::CreateMaybeMessage<::research_scann::InputOutputConfig_PreprocessingFunction>(Arena*);
template<> ::research_scann::InputOutputConfig_PureDynamicConfig* Arena::CreateMaybeMessage<::research_scann::InputOutputConfig_PureDynamicConfig>(Arena*);
template<> ::research_scann::InputOutputConfig_TeamsterConfig* Arena::CreateMaybeMessage<::research_scann::InputOutputConfig_TeamsterConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace research_scann {

enum InputOutputConfig_PureDynamicConfig_VectorType : int {
  InputOutputConfig_PureDynamicConfig_VectorType_UNSPECIFIED_VECTOR_TYPE = 0,
  InputOutputConfig_PureDynamicConfig_VectorType_SPARSE = 1,
  InputOutputConfig_PureDynamicConfig_VectorType_DENSE = 2
};
bool InputOutputConfig_PureDynamicConfig_VectorType_IsValid(int value);
constexpr InputOutputConfig_PureDynamicConfig_VectorType InputOutputConfig_PureDynamicConfig_VectorType_VectorType_MIN = InputOutputConfig_PureDynamicConfig_VectorType_UNSPECIFIED_VECTOR_TYPE;
constexpr InputOutputConfig_PureDynamicConfig_VectorType InputOutputConfig_PureDynamicConfig_VectorType_VectorType_MAX = InputOutputConfig_PureDynamicConfig_VectorType_DENSE;
constexpr int InputOutputConfig_PureDynamicConfig_VectorType_VectorType_ARRAYSIZE = InputOutputConfig_PureDynamicConfig_VectorType_VectorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InputOutputConfig_PureDynamicConfig_VectorType_descriptor();
template<typename T>
inline const std::string& InputOutputConfig_PureDynamicConfig_VectorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InputOutputConfig_PureDynamicConfig_VectorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InputOutputConfig_PureDynamicConfig_VectorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InputOutputConfig_PureDynamicConfig_VectorType_descriptor(), enum_t_value);
}
inline bool InputOutputConfig_PureDynamicConfig_VectorType_Parse(
    const std::string& name, InputOutputConfig_PureDynamicConfig_VectorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InputOutputConfig_PureDynamicConfig_VectorType>(
    InputOutputConfig_PureDynamicConfig_VectorType_descriptor(), name, value);
}
enum InputOutputConfig_InMemoryTypes : int {
  InputOutputConfig_InMemoryTypes_INT8 = 0,
  InputOutputConfig_InMemoryTypes_UINT8 = 1,
  InputOutputConfig_InMemoryTypes_INT16 = 2,
  InputOutputConfig_InMemoryTypes_UINT16 = 3,
  InputOutputConfig_InMemoryTypes_INT32 = 4,
  InputOutputConfig_InMemoryTypes_UINT32 = 5,
  InputOutputConfig_InMemoryTypes_INT64 = 6,
  InputOutputConfig_InMemoryTypes_UINT64 = 7,
  InputOutputConfig_InMemoryTypes_FLOAT = 8,
  InputOutputConfig_InMemoryTypes_DOUBLE = 9,
  InputOutputConfig_InMemoryTypes_IN_MEMORY_DATA_TYPE_NOT_SPECIFIED = 255
};
bool InputOutputConfig_InMemoryTypes_IsValid(int value);
constexpr InputOutputConfig_InMemoryTypes InputOutputConfig_InMemoryTypes_InMemoryTypes_MIN = InputOutputConfig_InMemoryTypes_INT8;
constexpr InputOutputConfig_InMemoryTypes InputOutputConfig_InMemoryTypes_InMemoryTypes_MAX = InputOutputConfig_InMemoryTypes_IN_MEMORY_DATA_TYPE_NOT_SPECIFIED;
constexpr int InputOutputConfig_InMemoryTypes_InMemoryTypes_ARRAYSIZE = InputOutputConfig_InMemoryTypes_InMemoryTypes_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InputOutputConfig_InMemoryTypes_descriptor();
template<typename T>
inline const std::string& InputOutputConfig_InMemoryTypes_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InputOutputConfig_InMemoryTypes>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InputOutputConfig_InMemoryTypes_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InputOutputConfig_InMemoryTypes_descriptor(), enum_t_value);
}
inline bool InputOutputConfig_InMemoryTypes_Parse(
    const std::string& name, InputOutputConfig_InMemoryTypes* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InputOutputConfig_InMemoryTypes>(
    InputOutputConfig_InMemoryTypes_descriptor(), name, value);
}
enum InputOutputConfig_ArtifactsNamingOption : int {
  InputOutputConfig_ArtifactsNamingOption_HASHED = 0,
  InputOutputConfig_ArtifactsNamingOption_NO_HASH = 1
};
bool InputOutputConfig_ArtifactsNamingOption_IsValid(int value);
constexpr InputOutputConfig_ArtifactsNamingOption InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_MIN = InputOutputConfig_ArtifactsNamingOption_HASHED;
constexpr InputOutputConfig_ArtifactsNamingOption InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_MAX = InputOutputConfig_ArtifactsNamingOption_NO_HASH;
constexpr int InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_ARRAYSIZE = InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InputOutputConfig_ArtifactsNamingOption_descriptor();
template<typename T>
inline const std::string& InputOutputConfig_ArtifactsNamingOption_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InputOutputConfig_ArtifactsNamingOption>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InputOutputConfig_ArtifactsNamingOption_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InputOutputConfig_ArtifactsNamingOption_descriptor(), enum_t_value);
}
inline bool InputOutputConfig_ArtifactsNamingOption_Parse(
    const std::string& name, InputOutputConfig_ArtifactsNamingOption* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InputOutputConfig_ArtifactsNamingOption>(
    InputOutputConfig_ArtifactsNamingOption_descriptor(), name, value);
}
enum InputOutputConfig_FeatureNorm : int {
  InputOutputConfig_FeatureNorm_NONE = 0,
  InputOutputConfig_FeatureNorm_UNITL2NORM = 1,
  InputOutputConfig_FeatureNorm_STDGAUSSNORM = 2,
  InputOutputConfig_FeatureNorm_UNITL1NORM = 3
};
bool InputOutputConfig_FeatureNorm_IsValid(int value);
constexpr InputOutputConfig_FeatureNorm InputOutputConfig_FeatureNorm_FeatureNorm_MIN = InputOutputConfig_FeatureNorm_NONE;
constexpr InputOutputConfig_FeatureNorm InputOutputConfig_FeatureNorm_FeatureNorm_MAX = InputOutputConfig_FeatureNorm_UNITL1NORM;
constexpr int InputOutputConfig_FeatureNorm_FeatureNorm_ARRAYSIZE = InputOutputConfig_FeatureNorm_FeatureNorm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InputOutputConfig_FeatureNorm_descriptor();
template<typename T>
inline const std::string& InputOutputConfig_FeatureNorm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InputOutputConfig_FeatureNorm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InputOutputConfig_FeatureNorm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InputOutputConfig_FeatureNorm_descriptor(), enum_t_value);
}
inline bool InputOutputConfig_FeatureNorm_Parse(
    const std::string& name, InputOutputConfig_FeatureNorm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InputOutputConfig_FeatureNorm>(
    InputOutputConfig_FeatureNorm_descriptor(), name, value);
}
// ===================================================================

class InputOutputConfig_PureDynamicConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.InputOutputConfig.PureDynamicConfig) */ {
 public:
  InputOutputConfig_PureDynamicConfig();
  virtual ~InputOutputConfig_PureDynamicConfig();

  InputOutputConfig_PureDynamicConfig(const InputOutputConfig_PureDynamicConfig& from);
  InputOutputConfig_PureDynamicConfig(InputOutputConfig_PureDynamicConfig&& from) noexcept
    : InputOutputConfig_PureDynamicConfig() {
    *this = ::std::move(from);
  }

  inline InputOutputConfig_PureDynamicConfig& operator=(const InputOutputConfig_PureDynamicConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputOutputConfig_PureDynamicConfig& operator=(InputOutputConfig_PureDynamicConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InputOutputConfig_PureDynamicConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputOutputConfig_PureDynamicConfig* internal_default_instance() {
    return reinterpret_cast<const InputOutputConfig_PureDynamicConfig*>(
               &_InputOutputConfig_PureDynamicConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InputOutputConfig_PureDynamicConfig& a, InputOutputConfig_PureDynamicConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(InputOutputConfig_PureDynamicConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InputOutputConfig_PureDynamicConfig* New() const final {
    return CreateMaybeMessage<InputOutputConfig_PureDynamicConfig>(nullptr);
  }

  InputOutputConfig_PureDynamicConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InputOutputConfig_PureDynamicConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InputOutputConfig_PureDynamicConfig& from);
  void MergeFrom(const InputOutputConfig_PureDynamicConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputOutputConfig_PureDynamicConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.InputOutputConfig.PureDynamicConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2finput_5foutput_2eproto);
    return ::descriptor_table_scann_2fproto_2finput_5foutput_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef InputOutputConfig_PureDynamicConfig_VectorType VectorType;
  static constexpr VectorType UNSPECIFIED_VECTOR_TYPE =
    InputOutputConfig_PureDynamicConfig_VectorType_UNSPECIFIED_VECTOR_TYPE;
  static constexpr VectorType SPARSE =
    InputOutputConfig_PureDynamicConfig_VectorType_SPARSE;
  static constexpr VectorType DENSE =
    InputOutputConfig_PureDynamicConfig_VectorType_DENSE;
  static inline bool VectorType_IsValid(int value) {
    return InputOutputConfig_PureDynamicConfig_VectorType_IsValid(value);
  }
  static constexpr VectorType VectorType_MIN =
    InputOutputConfig_PureDynamicConfig_VectorType_VectorType_MIN;
  static constexpr VectorType VectorType_MAX =
    InputOutputConfig_PureDynamicConfig_VectorType_VectorType_MAX;
  static constexpr int VectorType_ARRAYSIZE =
    InputOutputConfig_PureDynamicConfig_VectorType_VectorType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VectorType_descriptor() {
    return InputOutputConfig_PureDynamicConfig_VectorType_descriptor();
  }
  template<typename T>
  static inline const std::string& VectorType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VectorType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VectorType_Name.");
    return InputOutputConfig_PureDynamicConfig_VectorType_Name(enum_t_value);
  }
  static inline bool VectorType_Parse(const std::string& name,
      VectorType* value) {
    return InputOutputConfig_PureDynamicConfig_VectorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionalityFieldNumber = 3,
    kVectorTypeFieldNumber = 2,
    kNumShardsFieldNumber = 1,
  };
  // optional uint64 dimensionality = 3;
  bool has_dimensionality() const;
  void clear_dimensionality();
  ::PROTOBUF_NAMESPACE_ID::uint64 dimensionality() const;
  void set_dimensionality(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional .research_scann.InputOutputConfig.PureDynamicConfig.VectorType vector_type = 2 [default = UNSPECIFIED_VECTOR_TYPE];
  bool has_vector_type() const;
  void clear_vector_type();
  ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType vector_type() const;
  void set_vector_type(::research_scann::InputOutputConfig_PureDynamicConfig_VectorType value);

  // optional int32 num_shards = 1 [default = 1];
  bool has_num_shards() const;
  void clear_num_shards();
  ::PROTOBUF_NAMESPACE_ID::int32 num_shards() const;
  void set_num_shards(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:research_scann.InputOutputConfig.PureDynamicConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 dimensionality_;
  int vector_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_shards_;
  friend struct ::TableStruct_scann_2fproto_2finput_5foutput_2eproto;
};
// -------------------------------------------------------------------

class InputOutputConfig_TeamsterConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.InputOutputConfig.TeamsterConfig) */ {
 public:
  InputOutputConfig_TeamsterConfig();
  virtual ~InputOutputConfig_TeamsterConfig();

  InputOutputConfig_TeamsterConfig(const InputOutputConfig_TeamsterConfig& from);
  InputOutputConfig_TeamsterConfig(InputOutputConfig_TeamsterConfig&& from) noexcept
    : InputOutputConfig_TeamsterConfig() {
    *this = ::std::move(from);
  }

  inline InputOutputConfig_TeamsterConfig& operator=(const InputOutputConfig_TeamsterConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputOutputConfig_TeamsterConfig& operator=(InputOutputConfig_TeamsterConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InputOutputConfig_TeamsterConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputOutputConfig_TeamsterConfig* internal_default_instance() {
    return reinterpret_cast<const InputOutputConfig_TeamsterConfig*>(
               &_InputOutputConfig_TeamsterConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InputOutputConfig_TeamsterConfig& a, InputOutputConfig_TeamsterConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(InputOutputConfig_TeamsterConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InputOutputConfig_TeamsterConfig* New() const final {
    return CreateMaybeMessage<InputOutputConfig_TeamsterConfig>(nullptr);
  }

  InputOutputConfig_TeamsterConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InputOutputConfig_TeamsterConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InputOutputConfig_TeamsterConfig& from);
  void MergeFrom(const InputOutputConfig_TeamsterConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputOutputConfig_TeamsterConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.InputOutputConfig.TeamsterConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2finput_5foutput_2eproto);
    return ::descriptor_table_scann_2fproto_2finput_5foutput_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamsterLoaderBnsFieldNumber = 4,
    kDataFamilyNameFieldNumber = 5,
    kDataStreamNameFieldNumber = 6,
    kDbPrefixOverrideFieldNumber = 7,
    kEnabledFieldNumber = 1,
    kNumShardsFieldNumber = 2,
    kShardNumFieldNumber = 3,
  };
  // optional string teamster_loader_bns = 4;
  bool has_teamster_loader_bns() const;
  void clear_teamster_loader_bns();
  const std::string& teamster_loader_bns() const;
  void set_teamster_loader_bns(const std::string& value);
  void set_teamster_loader_bns(std::string&& value);
  void set_teamster_loader_bns(const char* value);
  void set_teamster_loader_bns(const char* value, size_t size);
  std::string* mutable_teamster_loader_bns();
  std::string* release_teamster_loader_bns();
  void set_allocated_teamster_loader_bns(std::string* teamster_loader_bns);

  // optional string data_family_name = 5;
  bool has_data_family_name() const;
  void clear_data_family_name();
  const std::string& data_family_name() const;
  void set_data_family_name(const std::string& value);
  void set_data_family_name(std::string&& value);
  void set_data_family_name(const char* value);
  void set_data_family_name(const char* value, size_t size);
  std::string* mutable_data_family_name();
  std::string* release_data_family_name();
  void set_allocated_data_family_name(std::string* data_family_name);

  // optional string data_stream_name = 6;
  bool has_data_stream_name() const;
  void clear_data_stream_name();
  const std::string& data_stream_name() const;
  void set_data_stream_name(const std::string& value);
  void set_data_stream_name(std::string&& value);
  void set_data_stream_name(const char* value);
  void set_data_stream_name(const char* value, size_t size);
  std::string* mutable_data_stream_name();
  std::string* release_data_stream_name();
  void set_allocated_data_stream_name(std::string* data_stream_name);

  // optional string db_prefix_override = 7 [default = "database"];
  bool has_db_prefix_override() const;
  void clear_db_prefix_override();
  const std::string& db_prefix_override() const;
  void set_db_prefix_override(const std::string& value);
  void set_db_prefix_override(std::string&& value);
  void set_db_prefix_override(const char* value);
  void set_db_prefix_override(const char* value, size_t size);
  std::string* mutable_db_prefix_override();
  std::string* release_db_prefix_override();
  void set_allocated_db_prefix_override(std::string* db_prefix_override);

  // optional bool enabled = 1 [default = false];
  bool has_enabled() const;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);

  // optional int32 num_shards = 2 [default = 1];
  bool has_num_shards() const;
  void clear_num_shards();
  ::PROTOBUF_NAMESPACE_ID::int32 num_shards() const;
  void set_num_shards(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 shard_num = 3 [default = -1];
  bool has_shard_num() const;
  void clear_shard_num();
  ::PROTOBUF_NAMESPACE_ID::int32 shard_num() const;
  void set_shard_num(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:research_scann.InputOutputConfig.TeamsterConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr teamster_loader_bns_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_family_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_stream_name_;
  public:
  static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> _i_give_permission_to_break_this_code_default_db_prefix_override_;
  private:
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_prefix_override_;
  bool enabled_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_shards_;
  ::PROTOBUF_NAMESPACE_ID::int32 shard_num_;
  friend struct ::TableStruct_scann_2fproto_2finput_5foutput_2eproto;
};
// -------------------------------------------------------------------

class InputOutputConfig_PreprocessingFunction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.InputOutputConfig.PreprocessingFunction) */ {
 public:
  InputOutputConfig_PreprocessingFunction();
  virtual ~InputOutputConfig_PreprocessingFunction();

  InputOutputConfig_PreprocessingFunction(const InputOutputConfig_PreprocessingFunction& from);
  InputOutputConfig_PreprocessingFunction(InputOutputConfig_PreprocessingFunction&& from) noexcept
    : InputOutputConfig_PreprocessingFunction() {
    *this = ::std::move(from);
  }

  inline InputOutputConfig_PreprocessingFunction& operator=(const InputOutputConfig_PreprocessingFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputOutputConfig_PreprocessingFunction& operator=(InputOutputConfig_PreprocessingFunction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InputOutputConfig_PreprocessingFunction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputOutputConfig_PreprocessingFunction* internal_default_instance() {
    return reinterpret_cast<const InputOutputConfig_PreprocessingFunction*>(
               &_InputOutputConfig_PreprocessingFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InputOutputConfig_PreprocessingFunction& a, InputOutputConfig_PreprocessingFunction& b) {
    a.Swap(&b);
  }
  inline void Swap(InputOutputConfig_PreprocessingFunction* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InputOutputConfig_PreprocessingFunction* New() const final {
    return CreateMaybeMessage<InputOutputConfig_PreprocessingFunction>(nullptr);
  }

  InputOutputConfig_PreprocessingFunction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InputOutputConfig_PreprocessingFunction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InputOutputConfig_PreprocessingFunction& from);
  void MergeFrom(const InputOutputConfig_PreprocessingFunction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputOutputConfig_PreprocessingFunction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.InputOutputConfig.PreprocessingFunction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2finput_5foutput_2eproto);
    return ::descriptor_table_scann_2fproto_2finput_5foutput_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kConfigAsciiFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional string config_ascii = 2;
  bool has_config_ascii() const;
  void clear_config_ascii();
  const std::string& config_ascii() const;
  void set_config_ascii(const std::string& value);
  void set_config_ascii(std::string&& value);
  void set_config_ascii(const char* value);
  void set_config_ascii(const char* value, size_t size);
  std::string* mutable_config_ascii();
  std::string* release_config_ascii();
  void set_allocated_config_ascii(std::string* config_ascii);

  // @@protoc_insertion_point(class_scope:research_scann.InputOutputConfig.PreprocessingFunction)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_ascii_;
  friend struct ::TableStruct_scann_2fproto_2finput_5foutput_2eproto;
};
// -------------------------------------------------------------------

class InputOutputConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.InputOutputConfig) */ {
 public:
  InputOutputConfig();
  virtual ~InputOutputConfig();

  InputOutputConfig(const InputOutputConfig& from);
  InputOutputConfig(InputOutputConfig&& from) noexcept
    : InputOutputConfig() {
    *this = ::std::move(from);
  }

  inline InputOutputConfig& operator=(const InputOutputConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputOutputConfig& operator=(InputOutputConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InputOutputConfig& default_instance();

  enum IncrementalUpdateMetadataOneofCase {
    kIncrementalUpdateMetadataLocation = 19,
    kIncrementalUpdateMetadata = 22,
    INCREMENTALUPDATEMETADATAONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputOutputConfig* internal_default_instance() {
    return reinterpret_cast<const InputOutputConfig*>(
               &_InputOutputConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InputOutputConfig& a, InputOutputConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(InputOutputConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InputOutputConfig* New() const final {
    return CreateMaybeMessage<InputOutputConfig>(nullptr);
  }

  InputOutputConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InputOutputConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InputOutputConfig& from);
  void MergeFrom(const InputOutputConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputOutputConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.InputOutputConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2finput_5foutput_2eproto);
    return ::descriptor_table_scann_2fproto_2finput_5foutput_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef InputOutputConfig_PureDynamicConfig PureDynamicConfig;
  typedef InputOutputConfig_TeamsterConfig TeamsterConfig;
  typedef InputOutputConfig_PreprocessingFunction PreprocessingFunction;

  typedef InputOutputConfig_InMemoryTypes InMemoryTypes;
  static constexpr InMemoryTypes INT8 =
    InputOutputConfig_InMemoryTypes_INT8;
  static constexpr InMemoryTypes UINT8 =
    InputOutputConfig_InMemoryTypes_UINT8;
  static constexpr InMemoryTypes INT16 =
    InputOutputConfig_InMemoryTypes_INT16;
  static constexpr InMemoryTypes UINT16 =
    InputOutputConfig_InMemoryTypes_UINT16;
  static constexpr InMemoryTypes INT32 =
    InputOutputConfig_InMemoryTypes_INT32;
  static constexpr InMemoryTypes UINT32 =
    InputOutputConfig_InMemoryTypes_UINT32;
  static constexpr InMemoryTypes INT64 =
    InputOutputConfig_InMemoryTypes_INT64;
  static constexpr InMemoryTypes UINT64 =
    InputOutputConfig_InMemoryTypes_UINT64;
  static constexpr InMemoryTypes FLOAT =
    InputOutputConfig_InMemoryTypes_FLOAT;
  static constexpr InMemoryTypes DOUBLE =
    InputOutputConfig_InMemoryTypes_DOUBLE;
  static constexpr InMemoryTypes IN_MEMORY_DATA_TYPE_NOT_SPECIFIED =
    InputOutputConfig_InMemoryTypes_IN_MEMORY_DATA_TYPE_NOT_SPECIFIED;
  static inline bool InMemoryTypes_IsValid(int value) {
    return InputOutputConfig_InMemoryTypes_IsValid(value);
  }
  static constexpr InMemoryTypes InMemoryTypes_MIN =
    InputOutputConfig_InMemoryTypes_InMemoryTypes_MIN;
  static constexpr InMemoryTypes InMemoryTypes_MAX =
    InputOutputConfig_InMemoryTypes_InMemoryTypes_MAX;
  static constexpr int InMemoryTypes_ARRAYSIZE =
    InputOutputConfig_InMemoryTypes_InMemoryTypes_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InMemoryTypes_descriptor() {
    return InputOutputConfig_InMemoryTypes_descriptor();
  }
  template<typename T>
  static inline const std::string& InMemoryTypes_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InMemoryTypes>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InMemoryTypes_Name.");
    return InputOutputConfig_InMemoryTypes_Name(enum_t_value);
  }
  static inline bool InMemoryTypes_Parse(const std::string& name,
      InMemoryTypes* value) {
    return InputOutputConfig_InMemoryTypes_Parse(name, value);
  }

  typedef InputOutputConfig_ArtifactsNamingOption ArtifactsNamingOption;
  static constexpr ArtifactsNamingOption HASHED =
    InputOutputConfig_ArtifactsNamingOption_HASHED;
  static constexpr ArtifactsNamingOption NO_HASH =
    InputOutputConfig_ArtifactsNamingOption_NO_HASH;
  static inline bool ArtifactsNamingOption_IsValid(int value) {
    return InputOutputConfig_ArtifactsNamingOption_IsValid(value);
  }
  static constexpr ArtifactsNamingOption ArtifactsNamingOption_MIN =
    InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_MIN;
  static constexpr ArtifactsNamingOption ArtifactsNamingOption_MAX =
    InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_MAX;
  static constexpr int ArtifactsNamingOption_ARRAYSIZE =
    InputOutputConfig_ArtifactsNamingOption_ArtifactsNamingOption_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ArtifactsNamingOption_descriptor() {
    return InputOutputConfig_ArtifactsNamingOption_descriptor();
  }
  template<typename T>
  static inline const std::string& ArtifactsNamingOption_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ArtifactsNamingOption>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ArtifactsNamingOption_Name.");
    return InputOutputConfig_ArtifactsNamingOption_Name(enum_t_value);
  }
  static inline bool ArtifactsNamingOption_Parse(const std::string& name,
      ArtifactsNamingOption* value) {
    return InputOutputConfig_ArtifactsNamingOption_Parse(name, value);
  }

  typedef InputOutputConfig_FeatureNorm FeatureNorm;
  static constexpr FeatureNorm NONE =
    InputOutputConfig_FeatureNorm_NONE;
  static constexpr FeatureNorm UNITL2NORM =
    InputOutputConfig_FeatureNorm_UNITL2NORM;
  static constexpr FeatureNorm STDGAUSSNORM =
    InputOutputConfig_FeatureNorm_STDGAUSSNORM;
  static constexpr FeatureNorm UNITL1NORM =
    InputOutputConfig_FeatureNorm_UNITL1NORM;
  static inline bool FeatureNorm_IsValid(int value) {
    return InputOutputConfig_FeatureNorm_IsValid(value);
  }
  static constexpr FeatureNorm FeatureNorm_MIN =
    InputOutputConfig_FeatureNorm_FeatureNorm_MIN;
  static constexpr FeatureNorm FeatureNorm_MAX =
    InputOutputConfig_FeatureNorm_FeatureNorm_MAX;
  static constexpr int FeatureNorm_ARRAYSIZE =
    InputOutputConfig_FeatureNorm_FeatureNorm_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FeatureNorm_descriptor() {
    return InputOutputConfig_FeatureNorm_descriptor();
  }
  template<typename T>
  static inline const std::string& FeatureNorm_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FeatureNorm>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FeatureNorm_Name.");
    return InputOutputConfig_FeatureNorm_Name(enum_t_value);
  }
  static inline bool FeatureNorm_Parse(const std::string& name,
      FeatureNorm* value) {
    return InputOutputConfig_FeatureNorm_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseWildcardFieldNumber = 3,
    kQueryWildcardFieldNumber = 8,
    kOutputSstableWildcardFieldNumber = 11,
    kHashedDatabaseWildcardFieldNumber = 12,
    kTokenizedDatabaseWildcardFieldNumber = 14,
    kFixedPointDatabaseWildcardFieldNumber = 17,
    kPreprocessedArtifactsDirFieldNumber = 18,
    kMemoryConsumptionEstimateFilenameFieldNumber = 24,
    kQueryPreprocessingFunctionFieldNumber = 16,
    kTeamsterFieldNumber = 20,
    kPureDynamicConfigFieldNumber = 21,
    kDimensionalityFieldNumber = 4,
    kNormTypeFieldNumber = 5,
    kAllowTwoPassReadFieldNumber = 15,
    kNonNegativeFieldNumber = 6,
    kIsDenseFieldNumber = 7,
    kSaturateFieldNumber = 10,
    kArtifactsNamingOptionFieldNumber = 23,
    kInMemoryDataTypeFieldNumber = 2,
    kIncrementalUpdateMetadataLocationFieldNumber = 19,
    kIncrementalUpdateMetadataFieldNumber = 22,
  };
  // optional string database_wildcard = 3;
  bool has_database_wildcard() const;
  void clear_database_wildcard();
  const std::string& database_wildcard() const;
  void set_database_wildcard(const std::string& value);
  void set_database_wildcard(std::string&& value);
  void set_database_wildcard(const char* value);
  void set_database_wildcard(const char* value, size_t size);
  std::string* mutable_database_wildcard();
  std::string* release_database_wildcard();
  void set_allocated_database_wildcard(std::string* database_wildcard);

  // optional string query_wildcard = 8;
  bool has_query_wildcard() const;
  void clear_query_wildcard();
  const std::string& query_wildcard() const;
  void set_query_wildcard(const std::string& value);
  void set_query_wildcard(std::string&& value);
  void set_query_wildcard(const char* value);
  void set_query_wildcard(const char* value, size_t size);
  std::string* mutable_query_wildcard();
  std::string* release_query_wildcard();
  void set_allocated_query_wildcard(std::string* query_wildcard);

  // optional string output_sstable_wildcard = 11;
  bool has_output_sstable_wildcard() const;
  void clear_output_sstable_wildcard();
  const std::string& output_sstable_wildcard() const;
  void set_output_sstable_wildcard(const std::string& value);
  void set_output_sstable_wildcard(std::string&& value);
  void set_output_sstable_wildcard(const char* value);
  void set_output_sstable_wildcard(const char* value, size_t size);
  std::string* mutable_output_sstable_wildcard();
  std::string* release_output_sstable_wildcard();
  void set_allocated_output_sstable_wildcard(std::string* output_sstable_wildcard);

  // optional string hashed_database_wildcard = 12;
  bool has_hashed_database_wildcard() const;
  void clear_hashed_database_wildcard();
  const std::string& hashed_database_wildcard() const;
  void set_hashed_database_wildcard(const std::string& value);
  void set_hashed_database_wildcard(std::string&& value);
  void set_hashed_database_wildcard(const char* value);
  void set_hashed_database_wildcard(const char* value, size_t size);
  std::string* mutable_hashed_database_wildcard();
  std::string* release_hashed_database_wildcard();
  void set_allocated_hashed_database_wildcard(std::string* hashed_database_wildcard);

  // optional string tokenized_database_wildcard = 14;
  bool has_tokenized_database_wildcard() const;
  void clear_tokenized_database_wildcard();
  const std::string& tokenized_database_wildcard() const;
  void set_tokenized_database_wildcard(const std::string& value);
  void set_tokenized_database_wildcard(std::string&& value);
  void set_tokenized_database_wildcard(const char* value);
  void set_tokenized_database_wildcard(const char* value, size_t size);
  std::string* mutable_tokenized_database_wildcard();
  std::string* release_tokenized_database_wildcard();
  void set_allocated_tokenized_database_wildcard(std::string* tokenized_database_wildcard);

  // optional string fixed_point_database_wildcard = 17;
  bool has_fixed_point_database_wildcard() const;
  void clear_fixed_point_database_wildcard();
  const std::string& fixed_point_database_wildcard() const;
  void set_fixed_point_database_wildcard(const std::string& value);
  void set_fixed_point_database_wildcard(std::string&& value);
  void set_fixed_point_database_wildcard(const char* value);
  void set_fixed_point_database_wildcard(const char* value, size_t size);
  std::string* mutable_fixed_point_database_wildcard();
  std::string* release_fixed_point_database_wildcard();
  void set_allocated_fixed_point_database_wildcard(std::string* fixed_point_database_wildcard);

  // optional string preprocessed_artifacts_dir = 18;
  bool has_preprocessed_artifacts_dir() const;
  void clear_preprocessed_artifacts_dir();
  const std::string& preprocessed_artifacts_dir() const;
  void set_preprocessed_artifacts_dir(const std::string& value);
  void set_preprocessed_artifacts_dir(std::string&& value);
  void set_preprocessed_artifacts_dir(const char* value);
  void set_preprocessed_artifacts_dir(const char* value, size_t size);
  std::string* mutable_preprocessed_artifacts_dir();
  std::string* release_preprocessed_artifacts_dir();
  void set_allocated_preprocessed_artifacts_dir(std::string* preprocessed_artifacts_dir);

  // optional string memory_consumption_estimate_filename = 24;
  bool has_memory_consumption_estimate_filename() const;
  void clear_memory_consumption_estimate_filename();
  const std::string& memory_consumption_estimate_filename() const;
  void set_memory_consumption_estimate_filename(const std::string& value);
  void set_memory_consumption_estimate_filename(std::string&& value);
  void set_memory_consumption_estimate_filename(const char* value);
  void set_memory_consumption_estimate_filename(const char* value, size_t size);
  std::string* mutable_memory_consumption_estimate_filename();
  std::string* release_memory_consumption_estimate_filename();
  void set_allocated_memory_consumption_estimate_filename(std::string* memory_consumption_estimate_filename);

  // optional .research_scann.InputOutputConfig.PreprocessingFunction query_preprocessing_function = 16;
  bool has_query_preprocessing_function() const;
  void clear_query_preprocessing_function();
  const ::research_scann::InputOutputConfig_PreprocessingFunction& query_preprocessing_function() const;
  ::research_scann::InputOutputConfig_PreprocessingFunction* release_query_preprocessing_function();
  ::research_scann::InputOutputConfig_PreprocessingFunction* mutable_query_preprocessing_function();
  void set_allocated_query_preprocessing_function(::research_scann::InputOutputConfig_PreprocessingFunction* query_preprocessing_function);

  // optional .research_scann.InputOutputConfig.TeamsterConfig teamster = 20;
  bool has_teamster() const;
  void clear_teamster();
  const ::research_scann::InputOutputConfig_TeamsterConfig& teamster() const;
  ::research_scann::InputOutputConfig_TeamsterConfig* release_teamster();
  ::research_scann::InputOutputConfig_TeamsterConfig* mutable_teamster();
  void set_allocated_teamster(::research_scann::InputOutputConfig_TeamsterConfig* teamster);

  // optional .research_scann.InputOutputConfig.PureDynamicConfig pure_dynamic_config = 21;
  bool has_pure_dynamic_config() const;
  void clear_pure_dynamic_config();
  const ::research_scann::InputOutputConfig_PureDynamicConfig& pure_dynamic_config() const;
  ::research_scann::InputOutputConfig_PureDynamicConfig* release_pure_dynamic_config();
  ::research_scann::InputOutputConfig_PureDynamicConfig* mutable_pure_dynamic_config();
  void set_allocated_pure_dynamic_config(::research_scann::InputOutputConfig_PureDynamicConfig* pure_dynamic_config);

  // optional uint64 dimensionality = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_dimensionality() const;
  PROTOBUF_DEPRECATED void clear_dimensionality();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::uint64 dimensionality() const;
  PROTOBUF_DEPRECATED void set_dimensionality(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional .research_scann.InputOutputConfig.FeatureNorm norm_type = 5 [default = NONE];
  bool has_norm_type() const;
  void clear_norm_type();
  ::research_scann::InputOutputConfig_FeatureNorm norm_type() const;
  void set_norm_type(::research_scann::InputOutputConfig_FeatureNorm value);

  // optional bool allow_two_pass_read = 15 [default = false];
  bool has_allow_two_pass_read() const;
  void clear_allow_two_pass_read();
  bool allow_two_pass_read() const;
  void set_allow_two_pass_read(bool value);

  // optional bool non_negative = 6 [default = false];
  bool has_non_negative() const;
  void clear_non_negative();
  bool non_negative() const;
  void set_non_negative(bool value);

  // optional bool is_dense = 7;
  bool has_is_dense() const;
  void clear_is_dense();
  bool is_dense() const;
  void set_is_dense(bool value);

  // optional bool saturate = 10 [default = false, deprecated = true];
  PROTOBUF_DEPRECATED bool has_saturate() const;
  PROTOBUF_DEPRECATED void clear_saturate();
  PROTOBUF_DEPRECATED bool saturate() const;
  PROTOBUF_DEPRECATED void set_saturate(bool value);

  // optional .research_scann.InputOutputConfig.ArtifactsNamingOption artifacts_naming_option = 23 [default = HASHED];
  bool has_artifacts_naming_option() const;
  void clear_artifacts_naming_option();
  ::research_scann::InputOutputConfig_ArtifactsNamingOption artifacts_naming_option() const;
  void set_artifacts_naming_option(::research_scann::InputOutputConfig_ArtifactsNamingOption value);

  // optional .research_scann.InputOutputConfig.InMemoryTypes in_memory_data_type = 2 [default = IN_MEMORY_DATA_TYPE_NOT_SPECIFIED];
  bool has_in_memory_data_type() const;
  void clear_in_memory_data_type();
  ::research_scann::InputOutputConfig_InMemoryTypes in_memory_data_type() const;
  void set_in_memory_data_type(::research_scann::InputOutputConfig_InMemoryTypes value);

  // optional string incremental_update_metadata_location = 19;
  bool has_incremental_update_metadata_location() const;
  void clear_incremental_update_metadata_location();
  const std::string& incremental_update_metadata_location() const;
  void set_incremental_update_metadata_location(const std::string& value);
  void set_incremental_update_metadata_location(std::string&& value);
  void set_incremental_update_metadata_location(const char* value);
  void set_incremental_update_metadata_location(const char* value, size_t size);
  std::string* mutable_incremental_update_metadata_location();
  std::string* release_incremental_update_metadata_location();
  void set_allocated_incremental_update_metadata_location(std::string* incremental_update_metadata_location);

  // optional .research_scann.IncrementalUpdateMetadata incremental_update_metadata = 22;
  bool has_incremental_update_metadata() const;
  void clear_incremental_update_metadata();
  const ::research_scann::IncrementalUpdateMetadata& incremental_update_metadata() const;
  ::research_scann::IncrementalUpdateMetadata* release_incremental_update_metadata();
  ::research_scann::IncrementalUpdateMetadata* mutable_incremental_update_metadata();
  void set_allocated_incremental_update_metadata(::research_scann::IncrementalUpdateMetadata* incremental_update_metadata);

  void clear_IncrementalUpdateMetadataOneof();
  IncrementalUpdateMetadataOneofCase IncrementalUpdateMetadataOneof_case() const;
  // @@protoc_insertion_point(class_scope:research_scann.InputOutputConfig)
 private:
  class _Internal;
  void set_has_incremental_update_metadata_location();
  void set_has_incremental_update_metadata();

  inline bool has_IncrementalUpdateMetadataOneof() const;
  inline void clear_has_IncrementalUpdateMetadataOneof();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_wildcard_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_wildcard_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_sstable_wildcard_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hashed_database_wildcard_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tokenized_database_wildcard_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fixed_point_database_wildcard_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preprocessed_artifacts_dir_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memory_consumption_estimate_filename_;
  ::research_scann::InputOutputConfig_PreprocessingFunction* query_preprocessing_function_;
  ::research_scann::InputOutputConfig_TeamsterConfig* teamster_;
  ::research_scann::InputOutputConfig_PureDynamicConfig* pure_dynamic_config_;
  ::PROTOBUF_NAMESPACE_ID::uint64 dimensionality_;
  int norm_type_;
  bool allow_two_pass_read_;
  bool non_negative_;
  bool is_dense_;
  bool saturate_;
  int artifacts_naming_option_;
  int in_memory_data_type_;
  union IncrementalUpdateMetadataOneofUnion {
    IncrementalUpdateMetadataOneofUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr incremental_update_metadata_location_;
    ::research_scann::IncrementalUpdateMetadata* incremental_update_metadata_;
  } IncrementalUpdateMetadataOneof_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_scann_2fproto_2finput_5foutput_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InputOutputConfig_PureDynamicConfig

// optional int32 num_shards = 1 [default = 1];
inline bool InputOutputConfig_PureDynamicConfig::has_num_shards() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InputOutputConfig_PureDynamicConfig::clear_num_shards() {
  num_shards_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InputOutputConfig_PureDynamicConfig::num_shards() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.PureDynamicConfig.num_shards)
  return num_shards_;
}
inline void InputOutputConfig_PureDynamicConfig::set_num_shards(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  num_shards_ = value;
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.PureDynamicConfig.num_shards)
}

// optional .research_scann.InputOutputConfig.PureDynamicConfig.VectorType vector_type = 2 [default = UNSPECIFIED_VECTOR_TYPE];
inline bool InputOutputConfig_PureDynamicConfig::has_vector_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputOutputConfig_PureDynamicConfig::clear_vector_type() {
  vector_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType InputOutputConfig_PureDynamicConfig::vector_type() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.PureDynamicConfig.vector_type)
  return static_cast< ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType >(vector_type_);
}
inline void InputOutputConfig_PureDynamicConfig::set_vector_type(::research_scann::InputOutputConfig_PureDynamicConfig_VectorType value) {
  assert(::research_scann::InputOutputConfig_PureDynamicConfig_VectorType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  vector_type_ = value;
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.PureDynamicConfig.vector_type)
}

// optional uint64 dimensionality = 3;
inline bool InputOutputConfig_PureDynamicConfig::has_dimensionality() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputOutputConfig_PureDynamicConfig::clear_dimensionality() {
  dimensionality_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InputOutputConfig_PureDynamicConfig::dimensionality() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.PureDynamicConfig.dimensionality)
  return dimensionality_;
}
inline void InputOutputConfig_PureDynamicConfig::set_dimensionality(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  dimensionality_ = value;
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.PureDynamicConfig.dimensionality)
}

// -------------------------------------------------------------------

// InputOutputConfig_TeamsterConfig

// optional bool enabled = 1 [default = false];
inline bool InputOutputConfig_TeamsterConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InputOutputConfig_TeamsterConfig::clear_enabled() {
  enabled_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool InputOutputConfig_TeamsterConfig::enabled() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.TeamsterConfig.enabled)
  return enabled_;
}
inline void InputOutputConfig_TeamsterConfig::set_enabled(bool value) {
  _has_bits_[0] |= 0x00000010u;
  enabled_ = value;
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.TeamsterConfig.enabled)
}

// optional int32 num_shards = 2 [default = 1];
inline bool InputOutputConfig_TeamsterConfig::has_num_shards() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InputOutputConfig_TeamsterConfig::clear_num_shards() {
  num_shards_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InputOutputConfig_TeamsterConfig::num_shards() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.TeamsterConfig.num_shards)
  return num_shards_;
}
inline void InputOutputConfig_TeamsterConfig::set_num_shards(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  num_shards_ = value;
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.TeamsterConfig.num_shards)
}

// optional int32 shard_num = 3 [default = -1];
inline bool InputOutputConfig_TeamsterConfig::has_shard_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InputOutputConfig_TeamsterConfig::clear_shard_num() {
  shard_num_ = -1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InputOutputConfig_TeamsterConfig::shard_num() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.TeamsterConfig.shard_num)
  return shard_num_;
}
inline void InputOutputConfig_TeamsterConfig::set_shard_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  shard_num_ = value;
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.TeamsterConfig.shard_num)
}

// optional string teamster_loader_bns = 4;
inline bool InputOutputConfig_TeamsterConfig::has_teamster_loader_bns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputOutputConfig_TeamsterConfig::clear_teamster_loader_bns() {
  teamster_loader_bns_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InputOutputConfig_TeamsterConfig::teamster_loader_bns() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.TeamsterConfig.teamster_loader_bns)
  return teamster_loader_bns_.GetNoArena();
}
inline void InputOutputConfig_TeamsterConfig::set_teamster_loader_bns(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  teamster_loader_bns_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.TeamsterConfig.teamster_loader_bns)
}
inline void InputOutputConfig_TeamsterConfig::set_teamster_loader_bns(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  teamster_loader_bns_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.InputOutputConfig.TeamsterConfig.teamster_loader_bns)
}
inline void InputOutputConfig_TeamsterConfig::set_teamster_loader_bns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  teamster_loader_bns_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.InputOutputConfig.TeamsterConfig.teamster_loader_bns)
}
inline void InputOutputConfig_TeamsterConfig::set_teamster_loader_bns(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  teamster_loader_bns_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.InputOutputConfig.TeamsterConfig.teamster_loader_bns)
}
inline std::string* InputOutputConfig_TeamsterConfig::mutable_teamster_loader_bns() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.TeamsterConfig.teamster_loader_bns)
  return teamster_loader_bns_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InputOutputConfig_TeamsterConfig::release_teamster_loader_bns() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.TeamsterConfig.teamster_loader_bns)
  if (!has_teamster_loader_bns()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return teamster_loader_bns_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InputOutputConfig_TeamsterConfig::set_allocated_teamster_loader_bns(std::string* teamster_loader_bns) {
  if (teamster_loader_bns != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  teamster_loader_bns_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), teamster_loader_bns);
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.TeamsterConfig.teamster_loader_bns)
}

// optional string data_family_name = 5;
inline bool InputOutputConfig_TeamsterConfig::has_data_family_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputOutputConfig_TeamsterConfig::clear_data_family_name() {
  data_family_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InputOutputConfig_TeamsterConfig::data_family_name() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.TeamsterConfig.data_family_name)
  return data_family_name_.GetNoArena();
}
inline void InputOutputConfig_TeamsterConfig::set_data_family_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  data_family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.TeamsterConfig.data_family_name)
}
inline void InputOutputConfig_TeamsterConfig::set_data_family_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  data_family_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.InputOutputConfig.TeamsterConfig.data_family_name)
}
inline void InputOutputConfig_TeamsterConfig::set_data_family_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  data_family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.InputOutputConfig.TeamsterConfig.data_family_name)
}
inline void InputOutputConfig_TeamsterConfig::set_data_family_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  data_family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.InputOutputConfig.TeamsterConfig.data_family_name)
}
inline std::string* InputOutputConfig_TeamsterConfig::mutable_data_family_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.TeamsterConfig.data_family_name)
  return data_family_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InputOutputConfig_TeamsterConfig::release_data_family_name() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.TeamsterConfig.data_family_name)
  if (!has_data_family_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return data_family_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InputOutputConfig_TeamsterConfig::set_allocated_data_family_name(std::string* data_family_name) {
  if (data_family_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_family_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_family_name);
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.TeamsterConfig.data_family_name)
}

// optional string data_stream_name = 6;
inline bool InputOutputConfig_TeamsterConfig::has_data_stream_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InputOutputConfig_TeamsterConfig::clear_data_stream_name() {
  data_stream_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& InputOutputConfig_TeamsterConfig::data_stream_name() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.TeamsterConfig.data_stream_name)
  return data_stream_name_.GetNoArena();
}
inline void InputOutputConfig_TeamsterConfig::set_data_stream_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  data_stream_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.TeamsterConfig.data_stream_name)
}
inline void InputOutputConfig_TeamsterConfig::set_data_stream_name(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  data_stream_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.InputOutputConfig.TeamsterConfig.data_stream_name)
}
inline void InputOutputConfig_TeamsterConfig::set_data_stream_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  data_stream_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.InputOutputConfig.TeamsterConfig.data_stream_name)
}
inline void InputOutputConfig_TeamsterConfig::set_data_stream_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  data_stream_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.InputOutputConfig.TeamsterConfig.data_stream_name)
}
inline std::string* InputOutputConfig_TeamsterConfig::mutable_data_stream_name() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.TeamsterConfig.data_stream_name)
  return data_stream_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InputOutputConfig_TeamsterConfig::release_data_stream_name() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.TeamsterConfig.data_stream_name)
  if (!has_data_stream_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return data_stream_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InputOutputConfig_TeamsterConfig::set_allocated_data_stream_name(std::string* data_stream_name) {
  if (data_stream_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  data_stream_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_stream_name);
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.TeamsterConfig.data_stream_name)
}

// optional string db_prefix_override = 7 [default = "database"];
inline bool InputOutputConfig_TeamsterConfig::has_db_prefix_override() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InputOutputConfig_TeamsterConfig::clear_db_prefix_override() {
  db_prefix_override_.ClearToDefaultNoArena(&::research_scann::InputOutputConfig_TeamsterConfig::_i_give_permission_to_break_this_code_default_db_prefix_override_.get());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& InputOutputConfig_TeamsterConfig::db_prefix_override() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.TeamsterConfig.db_prefix_override)
  return db_prefix_override_.GetNoArena();
}
inline void InputOutputConfig_TeamsterConfig::set_db_prefix_override(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  db_prefix_override_.SetNoArena(&::research_scann::InputOutputConfig_TeamsterConfig::_i_give_permission_to_break_this_code_default_db_prefix_override_.get(), value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.TeamsterConfig.db_prefix_override)
}
inline void InputOutputConfig_TeamsterConfig::set_db_prefix_override(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  db_prefix_override_.SetNoArena(
    &::research_scann::InputOutputConfig_TeamsterConfig::_i_give_permission_to_break_this_code_default_db_prefix_override_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.InputOutputConfig.TeamsterConfig.db_prefix_override)
}
inline void InputOutputConfig_TeamsterConfig::set_db_prefix_override(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  db_prefix_override_.SetNoArena(&::research_scann::InputOutputConfig_TeamsterConfig::_i_give_permission_to_break_this_code_default_db_prefix_override_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.InputOutputConfig.TeamsterConfig.db_prefix_override)
}
inline void InputOutputConfig_TeamsterConfig::set_db_prefix_override(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  db_prefix_override_.SetNoArena(&::research_scann::InputOutputConfig_TeamsterConfig::_i_give_permission_to_break_this_code_default_db_prefix_override_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.InputOutputConfig.TeamsterConfig.db_prefix_override)
}
inline std::string* InputOutputConfig_TeamsterConfig::mutable_db_prefix_override() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.TeamsterConfig.db_prefix_override)
  return db_prefix_override_.MutableNoArena(&::research_scann::InputOutputConfig_TeamsterConfig::_i_give_permission_to_break_this_code_default_db_prefix_override_.get());
}
inline std::string* InputOutputConfig_TeamsterConfig::release_db_prefix_override() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.TeamsterConfig.db_prefix_override)
  if (!has_db_prefix_override()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return db_prefix_override_.ReleaseNonDefaultNoArena(&::research_scann::InputOutputConfig_TeamsterConfig::_i_give_permission_to_break_this_code_default_db_prefix_override_.get());
}
inline void InputOutputConfig_TeamsterConfig::set_allocated_db_prefix_override(std::string* db_prefix_override) {
  if (db_prefix_override != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  db_prefix_override_.SetAllocatedNoArena(&::research_scann::InputOutputConfig_TeamsterConfig::_i_give_permission_to_break_this_code_default_db_prefix_override_.get(), db_prefix_override);
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.TeamsterConfig.db_prefix_override)
}

// -------------------------------------------------------------------

// InputOutputConfig_PreprocessingFunction

// optional string name = 1;
inline bool InputOutputConfig_PreprocessingFunction::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputOutputConfig_PreprocessingFunction::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InputOutputConfig_PreprocessingFunction::name() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.PreprocessingFunction.name)
  return name_.GetNoArena();
}
inline void InputOutputConfig_PreprocessingFunction::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.PreprocessingFunction.name)
}
inline void InputOutputConfig_PreprocessingFunction::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.InputOutputConfig.PreprocessingFunction.name)
}
inline void InputOutputConfig_PreprocessingFunction::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.InputOutputConfig.PreprocessingFunction.name)
}
inline void InputOutputConfig_PreprocessingFunction::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.InputOutputConfig.PreprocessingFunction.name)
}
inline std::string* InputOutputConfig_PreprocessingFunction::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.PreprocessingFunction.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InputOutputConfig_PreprocessingFunction::release_name() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.PreprocessingFunction.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InputOutputConfig_PreprocessingFunction::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.PreprocessingFunction.name)
}

// optional string config_ascii = 2;
inline bool InputOutputConfig_PreprocessingFunction::has_config_ascii() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputOutputConfig_PreprocessingFunction::clear_config_ascii() {
  config_ascii_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InputOutputConfig_PreprocessingFunction::config_ascii() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
  return config_ascii_.GetNoArena();
}
inline void InputOutputConfig_PreprocessingFunction::set_config_ascii(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  config_ascii_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
}
inline void InputOutputConfig_PreprocessingFunction::set_config_ascii(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  config_ascii_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
}
inline void InputOutputConfig_PreprocessingFunction::set_config_ascii(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  config_ascii_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
}
inline void InputOutputConfig_PreprocessingFunction::set_config_ascii(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  config_ascii_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
}
inline std::string* InputOutputConfig_PreprocessingFunction::mutable_config_ascii() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
  return config_ascii_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InputOutputConfig_PreprocessingFunction::release_config_ascii() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
  if (!has_config_ascii()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return config_ascii_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InputOutputConfig_PreprocessingFunction::set_allocated_config_ascii(std::string* config_ascii) {
  if (config_ascii != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  config_ascii_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), config_ascii);
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.PreprocessingFunction.config_ascii)
}

// -------------------------------------------------------------------

// InputOutputConfig

// optional .research_scann.InputOutputConfig.InMemoryTypes in_memory_data_type = 2 [default = IN_MEMORY_DATA_TYPE_NOT_SPECIFIED];
inline bool InputOutputConfig::has_in_memory_data_type() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void InputOutputConfig::clear_in_memory_data_type() {
  in_memory_data_type_ = 255;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::research_scann::InputOutputConfig_InMemoryTypes InputOutputConfig::in_memory_data_type() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.in_memory_data_type)
  return static_cast< ::research_scann::InputOutputConfig_InMemoryTypes >(in_memory_data_type_);
}
inline void InputOutputConfig::set_in_memory_data_type(::research_scann::InputOutputConfig_InMemoryTypes value) {
  assert(::research_scann::InputOutputConfig_InMemoryTypes_IsValid(value));
  _has_bits_[0] |= 0x00040000u;
  in_memory_data_type_ = value;
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.in_memory_data_type)
}

// optional string database_wildcard = 3;
inline bool InputOutputConfig::has_database_wildcard() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputOutputConfig::clear_database_wildcard() {
  database_wildcard_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InputOutputConfig::database_wildcard() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.database_wildcard)
  return database_wildcard_.GetNoArena();
}
inline void InputOutputConfig::set_database_wildcard(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  database_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.database_wildcard)
}
inline void InputOutputConfig::set_database_wildcard(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  database_wildcard_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.InputOutputConfig.database_wildcard)
}
inline void InputOutputConfig::set_database_wildcard(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  database_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.InputOutputConfig.database_wildcard)
}
inline void InputOutputConfig::set_database_wildcard(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  database_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.InputOutputConfig.database_wildcard)
}
inline std::string* InputOutputConfig::mutable_database_wildcard() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.database_wildcard)
  return database_wildcard_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InputOutputConfig::release_database_wildcard() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.database_wildcard)
  if (!has_database_wildcard()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return database_wildcard_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InputOutputConfig::set_allocated_database_wildcard(std::string* database_wildcard) {
  if (database_wildcard != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  database_wildcard_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database_wildcard);
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.database_wildcard)
}

// optional bool allow_two_pass_read = 15 [default = false];
inline bool InputOutputConfig::has_allow_two_pass_read() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void InputOutputConfig::clear_allow_two_pass_read() {
  allow_two_pass_read_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool InputOutputConfig::allow_two_pass_read() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.allow_two_pass_read)
  return allow_two_pass_read_;
}
inline void InputOutputConfig::set_allow_two_pass_read(bool value) {
  _has_bits_[0] |= 0x00002000u;
  allow_two_pass_read_ = value;
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.allow_two_pass_read)
}

// optional string query_wildcard = 8;
inline bool InputOutputConfig::has_query_wildcard() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputOutputConfig::clear_query_wildcard() {
  query_wildcard_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InputOutputConfig::query_wildcard() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.query_wildcard)
  return query_wildcard_.GetNoArena();
}
inline void InputOutputConfig::set_query_wildcard(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  query_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.query_wildcard)
}
inline void InputOutputConfig::set_query_wildcard(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  query_wildcard_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.InputOutputConfig.query_wildcard)
}
inline void InputOutputConfig::set_query_wildcard(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  query_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.InputOutputConfig.query_wildcard)
}
inline void InputOutputConfig::set_query_wildcard(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  query_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.InputOutputConfig.query_wildcard)
}
inline std::string* InputOutputConfig::mutable_query_wildcard() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.query_wildcard)
  return query_wildcard_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InputOutputConfig::release_query_wildcard() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.query_wildcard)
  if (!has_query_wildcard()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return query_wildcard_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InputOutputConfig::set_allocated_query_wildcard(std::string* query_wildcard) {
  if (query_wildcard != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  query_wildcard_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), query_wildcard);
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.query_wildcard)
}

// optional string incremental_update_metadata_location = 19;
inline bool InputOutputConfig::has_incremental_update_metadata_location() const {
  return IncrementalUpdateMetadataOneof_case() == kIncrementalUpdateMetadataLocation;
}
inline void InputOutputConfig::set_has_incremental_update_metadata_location() {
  _oneof_case_[0] = kIncrementalUpdateMetadataLocation;
}
inline void InputOutputConfig::clear_incremental_update_metadata_location() {
  if (has_incremental_update_metadata_location()) {
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_IncrementalUpdateMetadataOneof();
  }
}
inline const std::string& InputOutputConfig::incremental_update_metadata_location() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.incremental_update_metadata_location)
  if (has_incremental_update_metadata_location()) {
    return IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void InputOutputConfig::set_incremental_update_metadata_location(const std::string& value) {
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.incremental_update_metadata_location)
  if (!has_incremental_update_metadata_location()) {
    clear_IncrementalUpdateMetadataOneof();
    set_has_incremental_update_metadata_location();
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.incremental_update_metadata_location)
}
inline void InputOutputConfig::set_incremental_update_metadata_location(std::string&& value) {
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.incremental_update_metadata_location)
  if (!has_incremental_update_metadata_location()) {
    clear_IncrementalUpdateMetadataOneof();
    set_has_incremental_update_metadata_location();
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.InputOutputConfig.incremental_update_metadata_location)
}
inline void InputOutputConfig::set_incremental_update_metadata_location(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_incremental_update_metadata_location()) {
    clear_IncrementalUpdateMetadataOneof();
    set_has_incremental_update_metadata_location();
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.InputOutputConfig.incremental_update_metadata_location)
}
inline void InputOutputConfig::set_incremental_update_metadata_location(const char* value, size_t size) {
  if (!has_incremental_update_metadata_location()) {
    clear_IncrementalUpdateMetadataOneof();
    set_has_incremental_update_metadata_location();
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.InputOutputConfig.incremental_update_metadata_location)
}
inline std::string* InputOutputConfig::mutable_incremental_update_metadata_location() {
  if (!has_incremental_update_metadata_location()) {
    clear_IncrementalUpdateMetadataOneof();
    set_has_incremental_update_metadata_location();
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.incremental_update_metadata_location)
  return IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InputOutputConfig::release_incremental_update_metadata_location() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.incremental_update_metadata_location)
  if (has_incremental_update_metadata_location()) {
    clear_has_IncrementalUpdateMetadataOneof();
    return IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void InputOutputConfig::set_allocated_incremental_update_metadata_location(std::string* incremental_update_metadata_location) {
  if (has_IncrementalUpdateMetadataOneof()) {
    clear_IncrementalUpdateMetadataOneof();
  }
  if (incremental_update_metadata_location != nullptr) {
    set_has_incremental_update_metadata_location();
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_location_.UnsafeSetDefault(incremental_update_metadata_location);
  }
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.incremental_update_metadata_location)
}

// optional .research_scann.IncrementalUpdateMetadata incremental_update_metadata = 22;
inline bool InputOutputConfig::has_incremental_update_metadata() const {
  return IncrementalUpdateMetadataOneof_case() == kIncrementalUpdateMetadata;
}
inline void InputOutputConfig::set_has_incremental_update_metadata() {
  _oneof_case_[0] = kIncrementalUpdateMetadata;
}
inline ::research_scann::IncrementalUpdateMetadata* InputOutputConfig::release_incremental_update_metadata() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.incremental_update_metadata)
  if (has_incremental_update_metadata()) {
    clear_has_IncrementalUpdateMetadataOneof();
      ::research_scann::IncrementalUpdateMetadata* temp = IncrementalUpdateMetadataOneof_.incremental_update_metadata_;
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::research_scann::IncrementalUpdateMetadata& InputOutputConfig::incremental_update_metadata() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.incremental_update_metadata)
  return has_incremental_update_metadata()
      ? *IncrementalUpdateMetadataOneof_.incremental_update_metadata_
      : *reinterpret_cast< ::research_scann::IncrementalUpdateMetadata*>(&::research_scann::_IncrementalUpdateMetadata_default_instance_);
}
inline ::research_scann::IncrementalUpdateMetadata* InputOutputConfig::mutable_incremental_update_metadata() {
  if (!has_incremental_update_metadata()) {
    clear_IncrementalUpdateMetadataOneof();
    set_has_incremental_update_metadata();
    IncrementalUpdateMetadataOneof_.incremental_update_metadata_ = CreateMaybeMessage< ::research_scann::IncrementalUpdateMetadata >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.incremental_update_metadata)
  return IncrementalUpdateMetadataOneof_.incremental_update_metadata_;
}

// optional string output_sstable_wildcard = 11;
inline bool InputOutputConfig::has_output_sstable_wildcard() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InputOutputConfig::clear_output_sstable_wildcard() {
  output_sstable_wildcard_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& InputOutputConfig::output_sstable_wildcard() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.output_sstable_wildcard)
  return output_sstable_wildcard_.GetNoArena();
}
inline void InputOutputConfig::set_output_sstable_wildcard(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  output_sstable_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.output_sstable_wildcard)
}
inline void InputOutputConfig::set_output_sstable_wildcard(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  output_sstable_wildcard_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.InputOutputConfig.output_sstable_wildcard)
}
inline void InputOutputConfig::set_output_sstable_wildcard(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  output_sstable_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.InputOutputConfig.output_sstable_wildcard)
}
inline void InputOutputConfig::set_output_sstable_wildcard(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  output_sstable_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.InputOutputConfig.output_sstable_wildcard)
}
inline std::string* InputOutputConfig::mutable_output_sstable_wildcard() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.output_sstable_wildcard)
  return output_sstable_wildcard_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InputOutputConfig::release_output_sstable_wildcard() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.output_sstable_wildcard)
  if (!has_output_sstable_wildcard()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return output_sstable_wildcard_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InputOutputConfig::set_allocated_output_sstable_wildcard(std::string* output_sstable_wildcard) {
  if (output_sstable_wildcard != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  output_sstable_wildcard_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), output_sstable_wildcard);
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.output_sstable_wildcard)
}

// optional string preprocessed_artifacts_dir = 18;
inline bool InputOutputConfig::has_preprocessed_artifacts_dir() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InputOutputConfig::clear_preprocessed_artifacts_dir() {
  preprocessed_artifacts_dir_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& InputOutputConfig::preprocessed_artifacts_dir() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
  return preprocessed_artifacts_dir_.GetNoArena();
}
inline void InputOutputConfig::set_preprocessed_artifacts_dir(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  preprocessed_artifacts_dir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
}
inline void InputOutputConfig::set_preprocessed_artifacts_dir(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  preprocessed_artifacts_dir_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
}
inline void InputOutputConfig::set_preprocessed_artifacts_dir(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  preprocessed_artifacts_dir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
}
inline void InputOutputConfig::set_preprocessed_artifacts_dir(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000040u;
  preprocessed_artifacts_dir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
}
inline std::string* InputOutputConfig::mutable_preprocessed_artifacts_dir() {
  _has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
  return preprocessed_artifacts_dir_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InputOutputConfig::release_preprocessed_artifacts_dir() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
  if (!has_preprocessed_artifacts_dir()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return preprocessed_artifacts_dir_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InputOutputConfig::set_allocated_preprocessed_artifacts_dir(std::string* preprocessed_artifacts_dir) {
  if (preprocessed_artifacts_dir != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  preprocessed_artifacts_dir_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), preprocessed_artifacts_dir);
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.preprocessed_artifacts_dir)
}

// optional .research_scann.InputOutputConfig.ArtifactsNamingOption artifacts_naming_option = 23 [default = HASHED];
inline bool InputOutputConfig::has_artifacts_naming_option() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void InputOutputConfig::clear_artifacts_naming_option() {
  artifacts_naming_option_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::research_scann::InputOutputConfig_ArtifactsNamingOption InputOutputConfig::artifacts_naming_option() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.artifacts_naming_option)
  return static_cast< ::research_scann::InputOutputConfig_ArtifactsNamingOption >(artifacts_naming_option_);
}
inline void InputOutputConfig::set_artifacts_naming_option(::research_scann::InputOutputConfig_ArtifactsNamingOption value) {
  assert(::research_scann::InputOutputConfig_ArtifactsNamingOption_IsValid(value));
  _has_bits_[0] |= 0x00020000u;
  artifacts_naming_option_ = value;
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.artifacts_naming_option)
}

// optional .research_scann.InputOutputConfig.PureDynamicConfig pure_dynamic_config = 21;
inline bool InputOutputConfig::has_pure_dynamic_config() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InputOutputConfig::clear_pure_dynamic_config() {
  if (pure_dynamic_config_ != nullptr) pure_dynamic_config_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::research_scann::InputOutputConfig_PureDynamicConfig& InputOutputConfig::pure_dynamic_config() const {
  const ::research_scann::InputOutputConfig_PureDynamicConfig* p = pure_dynamic_config_;
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.pure_dynamic_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::InputOutputConfig_PureDynamicConfig*>(
      &::research_scann::_InputOutputConfig_PureDynamicConfig_default_instance_);
}
inline ::research_scann::InputOutputConfig_PureDynamicConfig* InputOutputConfig::release_pure_dynamic_config() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.pure_dynamic_config)
  _has_bits_[0] &= ~0x00000400u;
  ::research_scann::InputOutputConfig_PureDynamicConfig* temp = pure_dynamic_config_;
  pure_dynamic_config_ = nullptr;
  return temp;
}
inline ::research_scann::InputOutputConfig_PureDynamicConfig* InputOutputConfig::mutable_pure_dynamic_config() {
  _has_bits_[0] |= 0x00000400u;
  if (pure_dynamic_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::InputOutputConfig_PureDynamicConfig>(GetArenaNoVirtual());
    pure_dynamic_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.pure_dynamic_config)
  return pure_dynamic_config_;
}
inline void InputOutputConfig::set_allocated_pure_dynamic_config(::research_scann::InputOutputConfig_PureDynamicConfig* pure_dynamic_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pure_dynamic_config_;
  }
  if (pure_dynamic_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pure_dynamic_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pure_dynamic_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  pure_dynamic_config_ = pure_dynamic_config;
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.pure_dynamic_config)
}

// optional .research_scann.InputOutputConfig.FeatureNorm norm_type = 5 [default = NONE];
inline bool InputOutputConfig::has_norm_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void InputOutputConfig::clear_norm_type() {
  norm_type_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::research_scann::InputOutputConfig_FeatureNorm InputOutputConfig::norm_type() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.norm_type)
  return static_cast< ::research_scann::InputOutputConfig_FeatureNorm >(norm_type_);
}
inline void InputOutputConfig::set_norm_type(::research_scann::InputOutputConfig_FeatureNorm value) {
  assert(::research_scann::InputOutputConfig_FeatureNorm_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  norm_type_ = value;
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.norm_type)
}

// optional .research_scann.InputOutputConfig.TeamsterConfig teamster = 20;
inline bool InputOutputConfig::has_teamster() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InputOutputConfig::clear_teamster() {
  if (teamster_ != nullptr) teamster_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::research_scann::InputOutputConfig_TeamsterConfig& InputOutputConfig::teamster() const {
  const ::research_scann::InputOutputConfig_TeamsterConfig* p = teamster_;
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.teamster)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::InputOutputConfig_TeamsterConfig*>(
      &::research_scann::_InputOutputConfig_TeamsterConfig_default_instance_);
}
inline ::research_scann::InputOutputConfig_TeamsterConfig* InputOutputConfig::release_teamster() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.teamster)
  _has_bits_[0] &= ~0x00000200u;
  ::research_scann::InputOutputConfig_TeamsterConfig* temp = teamster_;
  teamster_ = nullptr;
  return temp;
}
inline ::research_scann::InputOutputConfig_TeamsterConfig* InputOutputConfig::mutable_teamster() {
  _has_bits_[0] |= 0x00000200u;
  if (teamster_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::InputOutputConfig_TeamsterConfig>(GetArenaNoVirtual());
    teamster_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.teamster)
  return teamster_;
}
inline void InputOutputConfig::set_allocated_teamster(::research_scann::InputOutputConfig_TeamsterConfig* teamster) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete teamster_;
  }
  if (teamster) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      teamster = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, teamster, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  teamster_ = teamster;
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.teamster)
}

// optional bool non_negative = 6 [default = false];
inline bool InputOutputConfig::has_non_negative() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void InputOutputConfig::clear_non_negative() {
  non_negative_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool InputOutputConfig::non_negative() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.non_negative)
  return non_negative_;
}
inline void InputOutputConfig::set_non_negative(bool value) {
  _has_bits_[0] |= 0x00004000u;
  non_negative_ = value;
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.non_negative)
}

// optional bool is_dense = 7;
inline bool InputOutputConfig::has_is_dense() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void InputOutputConfig::clear_is_dense() {
  is_dense_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool InputOutputConfig::is_dense() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.is_dense)
  return is_dense_;
}
inline void InputOutputConfig::set_is_dense(bool value) {
  _has_bits_[0] |= 0x00008000u;
  is_dense_ = value;
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.is_dense)
}

// optional .research_scann.InputOutputConfig.PreprocessingFunction query_preprocessing_function = 16;
inline bool InputOutputConfig::has_query_preprocessing_function() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InputOutputConfig::clear_query_preprocessing_function() {
  if (query_preprocessing_function_ != nullptr) query_preprocessing_function_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::research_scann::InputOutputConfig_PreprocessingFunction& InputOutputConfig::query_preprocessing_function() const {
  const ::research_scann::InputOutputConfig_PreprocessingFunction* p = query_preprocessing_function_;
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.query_preprocessing_function)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::InputOutputConfig_PreprocessingFunction*>(
      &::research_scann::_InputOutputConfig_PreprocessingFunction_default_instance_);
}
inline ::research_scann::InputOutputConfig_PreprocessingFunction* InputOutputConfig::release_query_preprocessing_function() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.query_preprocessing_function)
  _has_bits_[0] &= ~0x00000100u;
  ::research_scann::InputOutputConfig_PreprocessingFunction* temp = query_preprocessing_function_;
  query_preprocessing_function_ = nullptr;
  return temp;
}
inline ::research_scann::InputOutputConfig_PreprocessingFunction* InputOutputConfig::mutable_query_preprocessing_function() {
  _has_bits_[0] |= 0x00000100u;
  if (query_preprocessing_function_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::InputOutputConfig_PreprocessingFunction>(GetArenaNoVirtual());
    query_preprocessing_function_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.query_preprocessing_function)
  return query_preprocessing_function_;
}
inline void InputOutputConfig::set_allocated_query_preprocessing_function(::research_scann::InputOutputConfig_PreprocessingFunction* query_preprocessing_function) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete query_preprocessing_function_;
  }
  if (query_preprocessing_function) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      query_preprocessing_function = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_preprocessing_function, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  query_preprocessing_function_ = query_preprocessing_function;
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.query_preprocessing_function)
}

// optional string hashed_database_wildcard = 12;
inline bool InputOutputConfig::has_hashed_database_wildcard() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InputOutputConfig::clear_hashed_database_wildcard() {
  hashed_database_wildcard_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& InputOutputConfig::hashed_database_wildcard() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.hashed_database_wildcard)
  return hashed_database_wildcard_.GetNoArena();
}
inline void InputOutputConfig::set_hashed_database_wildcard(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  hashed_database_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.hashed_database_wildcard)
}
inline void InputOutputConfig::set_hashed_database_wildcard(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  hashed_database_wildcard_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.InputOutputConfig.hashed_database_wildcard)
}
inline void InputOutputConfig::set_hashed_database_wildcard(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  hashed_database_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.InputOutputConfig.hashed_database_wildcard)
}
inline void InputOutputConfig::set_hashed_database_wildcard(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  hashed_database_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.InputOutputConfig.hashed_database_wildcard)
}
inline std::string* InputOutputConfig::mutable_hashed_database_wildcard() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.hashed_database_wildcard)
  return hashed_database_wildcard_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InputOutputConfig::release_hashed_database_wildcard() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.hashed_database_wildcard)
  if (!has_hashed_database_wildcard()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return hashed_database_wildcard_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InputOutputConfig::set_allocated_hashed_database_wildcard(std::string* hashed_database_wildcard) {
  if (hashed_database_wildcard != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  hashed_database_wildcard_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hashed_database_wildcard);
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.hashed_database_wildcard)
}

// optional string fixed_point_database_wildcard = 17;
inline bool InputOutputConfig::has_fixed_point_database_wildcard() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InputOutputConfig::clear_fixed_point_database_wildcard() {
  fixed_point_database_wildcard_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& InputOutputConfig::fixed_point_database_wildcard() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.fixed_point_database_wildcard)
  return fixed_point_database_wildcard_.GetNoArena();
}
inline void InputOutputConfig::set_fixed_point_database_wildcard(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  fixed_point_database_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.fixed_point_database_wildcard)
}
inline void InputOutputConfig::set_fixed_point_database_wildcard(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  fixed_point_database_wildcard_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.InputOutputConfig.fixed_point_database_wildcard)
}
inline void InputOutputConfig::set_fixed_point_database_wildcard(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  fixed_point_database_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.InputOutputConfig.fixed_point_database_wildcard)
}
inline void InputOutputConfig::set_fixed_point_database_wildcard(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  fixed_point_database_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.InputOutputConfig.fixed_point_database_wildcard)
}
inline std::string* InputOutputConfig::mutable_fixed_point_database_wildcard() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.fixed_point_database_wildcard)
  return fixed_point_database_wildcard_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InputOutputConfig::release_fixed_point_database_wildcard() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.fixed_point_database_wildcard)
  if (!has_fixed_point_database_wildcard()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return fixed_point_database_wildcard_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InputOutputConfig::set_allocated_fixed_point_database_wildcard(std::string* fixed_point_database_wildcard) {
  if (fixed_point_database_wildcard != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  fixed_point_database_wildcard_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fixed_point_database_wildcard);
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.fixed_point_database_wildcard)
}

// optional string tokenized_database_wildcard = 14;
inline bool InputOutputConfig::has_tokenized_database_wildcard() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InputOutputConfig::clear_tokenized_database_wildcard() {
  tokenized_database_wildcard_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& InputOutputConfig::tokenized_database_wildcard() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.tokenized_database_wildcard)
  return tokenized_database_wildcard_.GetNoArena();
}
inline void InputOutputConfig::set_tokenized_database_wildcard(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  tokenized_database_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.tokenized_database_wildcard)
}
inline void InputOutputConfig::set_tokenized_database_wildcard(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  tokenized_database_wildcard_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.InputOutputConfig.tokenized_database_wildcard)
}
inline void InputOutputConfig::set_tokenized_database_wildcard(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  tokenized_database_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.InputOutputConfig.tokenized_database_wildcard)
}
inline void InputOutputConfig::set_tokenized_database_wildcard(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  tokenized_database_wildcard_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.InputOutputConfig.tokenized_database_wildcard)
}
inline std::string* InputOutputConfig::mutable_tokenized_database_wildcard() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.tokenized_database_wildcard)
  return tokenized_database_wildcard_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InputOutputConfig::release_tokenized_database_wildcard() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.tokenized_database_wildcard)
  if (!has_tokenized_database_wildcard()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return tokenized_database_wildcard_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InputOutputConfig::set_allocated_tokenized_database_wildcard(std::string* tokenized_database_wildcard) {
  if (tokenized_database_wildcard != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  tokenized_database_wildcard_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tokenized_database_wildcard);
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.tokenized_database_wildcard)
}

// optional string memory_consumption_estimate_filename = 24;
inline bool InputOutputConfig::has_memory_consumption_estimate_filename() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InputOutputConfig::clear_memory_consumption_estimate_filename() {
  memory_consumption_estimate_filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& InputOutputConfig::memory_consumption_estimate_filename() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
  return memory_consumption_estimate_filename_.GetNoArena();
}
inline void InputOutputConfig::set_memory_consumption_estimate_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  memory_consumption_estimate_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
}
inline void InputOutputConfig::set_memory_consumption_estimate_filename(std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  memory_consumption_estimate_filename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
}
inline void InputOutputConfig::set_memory_consumption_estimate_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  memory_consumption_estimate_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
}
inline void InputOutputConfig::set_memory_consumption_estimate_filename(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000080u;
  memory_consumption_estimate_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
}
inline std::string* InputOutputConfig::mutable_memory_consumption_estimate_filename() {
  _has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_mutable:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
  return memory_consumption_estimate_filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InputOutputConfig::release_memory_consumption_estimate_filename() {
  // @@protoc_insertion_point(field_release:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
  if (!has_memory_consumption_estimate_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return memory_consumption_estimate_filename_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InputOutputConfig::set_allocated_memory_consumption_estimate_filename(std::string* memory_consumption_estimate_filename) {
  if (memory_consumption_estimate_filename != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  memory_consumption_estimate_filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), memory_consumption_estimate_filename);
  // @@protoc_insertion_point(field_set_allocated:research_scann.InputOutputConfig.memory_consumption_estimate_filename)
}

// optional bool saturate = 10 [default = false, deprecated = true];
inline bool InputOutputConfig::has_saturate() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void InputOutputConfig::clear_saturate() {
  saturate_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool InputOutputConfig::saturate() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.saturate)
  return saturate_;
}
inline void InputOutputConfig::set_saturate(bool value) {
  _has_bits_[0] |= 0x00010000u;
  saturate_ = value;
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.saturate)
}

// optional uint64 dimensionality = 4 [deprecated = true];
inline bool InputOutputConfig::has_dimensionality() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void InputOutputConfig::clear_dimensionality() {
  dimensionality_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InputOutputConfig::dimensionality() const {
  // @@protoc_insertion_point(field_get:research_scann.InputOutputConfig.dimensionality)
  return dimensionality_;
}
inline void InputOutputConfig::set_dimensionality(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000800u;
  dimensionality_ = value;
  // @@protoc_insertion_point(field_set:research_scann.InputOutputConfig.dimensionality)
}

inline bool InputOutputConfig::has_IncrementalUpdateMetadataOneof() const {
  return IncrementalUpdateMetadataOneof_case() != INCREMENTALUPDATEMETADATAONEOF_NOT_SET;
}
inline void InputOutputConfig::clear_has_IncrementalUpdateMetadataOneof() {
  _oneof_case_[0] = INCREMENTALUPDATEMETADATAONEOF_NOT_SET;
}
inline InputOutputConfig::IncrementalUpdateMetadataOneofCase InputOutputConfig::IncrementalUpdateMetadataOneof_case() const {
  return InputOutputConfig::IncrementalUpdateMetadataOneofCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace research_scann

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType>() {
  return ::research_scann::InputOutputConfig_PureDynamicConfig_VectorType_descriptor();
}
template <> struct is_proto_enum< ::research_scann::InputOutputConfig_InMemoryTypes> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::InputOutputConfig_InMemoryTypes>() {
  return ::research_scann::InputOutputConfig_InMemoryTypes_descriptor();
}
template <> struct is_proto_enum< ::research_scann::InputOutputConfig_ArtifactsNamingOption> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::InputOutputConfig_ArtifactsNamingOption>() {
  return ::research_scann::InputOutputConfig_ArtifactsNamingOption_descriptor();
}
template <> struct is_proto_enum< ::research_scann::InputOutputConfig_FeatureNorm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::InputOutputConfig_FeatureNorm>() {
  return ::research_scann::InputOutputConfig_FeatureNorm_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2finput_5foutput_2eproto
