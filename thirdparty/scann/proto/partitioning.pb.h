// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scann/proto/partitioning.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2fpartitioning_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2fpartitioning_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "scann/proto/distance_measure.pb.h"
#include "scann/proto/exact_reordering.pb.h"
#include "scann/proto/input_output.pb.h"
#include "scann/proto/projection.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_scann_2fproto_2fpartitioning_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_scann_2fproto_2fpartitioning_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scann_2fproto_2fpartitioning_2eproto;
namespace research_scann {
class DatabaseSpillingConfig;
class DatabaseSpillingConfigDefaultTypeInternal;
extern DatabaseSpillingConfigDefaultTypeInternal _DatabaseSpillingConfig_default_instance_;
class HierarchicalPartitionerConfig;
class HierarchicalPartitionerConfigDefaultTypeInternal;
extern HierarchicalPartitionerConfigDefaultTypeInternal _HierarchicalPartitionerConfig_default_instance_;
class PartitioningConfig;
class PartitioningConfigDefaultTypeInternal;
extern PartitioningConfigDefaultTypeInternal _PartitioningConfig_default_instance_;
class QuerySpillingConfig;
class QuerySpillingConfigDefaultTypeInternal;
extern QuerySpillingConfigDefaultTypeInternal _QuerySpillingConfig_default_instance_;
class TokenList;
class TokenListDefaultTypeInternal;
extern TokenListDefaultTypeInternal _TokenList_default_instance_;
class TreeXHybridPartitioningConfig;
class TreeXHybridPartitioningConfigDefaultTypeInternal;
extern TreeXHybridPartitioningConfigDefaultTypeInternal _TreeXHybridPartitioningConfig_default_instance_;
}  // namespace research_scann
PROTOBUF_NAMESPACE_OPEN
template<> ::research_scann::DatabaseSpillingConfig* Arena::CreateMaybeMessage<::research_scann::DatabaseSpillingConfig>(Arena*);
template<> ::research_scann::HierarchicalPartitionerConfig* Arena::CreateMaybeMessage<::research_scann::HierarchicalPartitionerConfig>(Arena*);
template<> ::research_scann::PartitioningConfig* Arena::CreateMaybeMessage<::research_scann::PartitioningConfig>(Arena*);
template<> ::research_scann::QuerySpillingConfig* Arena::CreateMaybeMessage<::research_scann::QuerySpillingConfig>(Arena*);
template<> ::research_scann::TokenList* Arena::CreateMaybeMessage<::research_scann::TokenList>(Arena*);
template<> ::research_scann::TreeXHybridPartitioningConfig* Arena::CreateMaybeMessage<::research_scann::TreeXHybridPartitioningConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace research_scann {

enum PartitioningConfig_TreeType : int {
  PartitioningConfig_TreeType_KMEANS_TREE = 0,
  PartitioningConfig_TreeType_PCA_TREE = 1,
  PartitioningConfig_TreeType_RANDOM_PROJECTION_TREE = 2,
  PartitioningConfig_TreeType_BALL_TREE = 3,
  PartitioningConfig_TreeType_RANDOM = 4,
  PartitioningConfig_TreeType_TREE_X_HYBRID = 5
};
bool PartitioningConfig_TreeType_IsValid(int value);
constexpr PartitioningConfig_TreeType PartitioningConfig_TreeType_TreeType_MIN = PartitioningConfig_TreeType_KMEANS_TREE;
constexpr PartitioningConfig_TreeType PartitioningConfig_TreeType_TreeType_MAX = PartitioningConfig_TreeType_TREE_X_HYBRID;
constexpr int PartitioningConfig_TreeType_TreeType_ARRAYSIZE = PartitioningConfig_TreeType_TreeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PartitioningConfig_TreeType_descriptor();
template<typename T>
inline const std::string& PartitioningConfig_TreeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PartitioningConfig_TreeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PartitioningConfig_TreeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PartitioningConfig_TreeType_descriptor(), enum_t_value);
}
inline bool PartitioningConfig_TreeType_Parse(
    const std::string& name, PartitioningConfig_TreeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PartitioningConfig_TreeType>(
    PartitioningConfig_TreeType_descriptor(), name, value);
}
enum PartitioningConfig_TokenizationType : int {
  PartitioningConfig_TokenizationType_FLOAT = 1,
  PartitioningConfig_TokenizationType_FIXED_POINT_INT8 = 2,
  PartitioningConfig_TokenizationType_ASYMMETRIC = 3
};
bool PartitioningConfig_TokenizationType_IsValid(int value);
constexpr PartitioningConfig_TokenizationType PartitioningConfig_TokenizationType_TokenizationType_MIN = PartitioningConfig_TokenizationType_FLOAT;
constexpr PartitioningConfig_TokenizationType PartitioningConfig_TokenizationType_TokenizationType_MAX = PartitioningConfig_TokenizationType_ASYMMETRIC;
constexpr int PartitioningConfig_TokenizationType_TokenizationType_ARRAYSIZE = PartitioningConfig_TokenizationType_TokenizationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PartitioningConfig_TokenizationType_descriptor();
template<typename T>
inline const std::string& PartitioningConfig_TokenizationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PartitioningConfig_TokenizationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PartitioningConfig_TokenizationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PartitioningConfig_TokenizationType_descriptor(), enum_t_value);
}
inline bool PartitioningConfig_TokenizationType_Parse(
    const std::string& name, PartitioningConfig_TokenizationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PartitioningConfig_TokenizationType>(
    PartitioningConfig_TokenizationType_descriptor(), name, value);
}
enum PartitioningConfig_PartitioningType : int {
  PartitioningConfig_PartitioningType_GENERIC = 0,
  PartitioningConfig_PartitioningType_SPHERICAL = 1
};
bool PartitioningConfig_PartitioningType_IsValid(int value);
constexpr PartitioningConfig_PartitioningType PartitioningConfig_PartitioningType_PartitioningType_MIN = PartitioningConfig_PartitioningType_GENERIC;
constexpr PartitioningConfig_PartitioningType PartitioningConfig_PartitioningType_PartitioningType_MAX = PartitioningConfig_PartitioningType_SPHERICAL;
constexpr int PartitioningConfig_PartitioningType_PartitioningType_ARRAYSIZE = PartitioningConfig_PartitioningType_PartitioningType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PartitioningConfig_PartitioningType_descriptor();
template<typename T>
inline const std::string& PartitioningConfig_PartitioningType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PartitioningConfig_PartitioningType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PartitioningConfig_PartitioningType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PartitioningConfig_PartitioningType_descriptor(), enum_t_value);
}
inline bool PartitioningConfig_PartitioningType_Parse(
    const std::string& name, PartitioningConfig_PartitioningType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PartitioningConfig_PartitioningType>(
    PartitioningConfig_PartitioningType_descriptor(), name, value);
}
enum PartitioningConfig_BalancingType : int {
  PartitioningConfig_BalancingType_DEFAULT_UNBALANCED = 0,
  PartitioningConfig_BalancingType_GREEDY_BALANCED = 1
};
bool PartitioningConfig_BalancingType_IsValid(int value);
constexpr PartitioningConfig_BalancingType PartitioningConfig_BalancingType_BalancingType_MIN = PartitioningConfig_BalancingType_DEFAULT_UNBALANCED;
constexpr PartitioningConfig_BalancingType PartitioningConfig_BalancingType_BalancingType_MAX = PartitioningConfig_BalancingType_GREEDY_BALANCED;
constexpr int PartitioningConfig_BalancingType_BalancingType_ARRAYSIZE = PartitioningConfig_BalancingType_BalancingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PartitioningConfig_BalancingType_descriptor();
template<typename T>
inline const std::string& PartitioningConfig_BalancingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PartitioningConfig_BalancingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PartitioningConfig_BalancingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PartitioningConfig_BalancingType_descriptor(), enum_t_value);
}
inline bool PartitioningConfig_BalancingType_Parse(
    const std::string& name, PartitioningConfig_BalancingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PartitioningConfig_BalancingType>(
    PartitioningConfig_BalancingType_descriptor(), name, value);
}
enum PartitioningConfig_SingleMachineCenterInitializationType : int {
  PartitioningConfig_SingleMachineCenterInitializationType_DEFAULT_KMEANS_PLUS_PLUS = 0,
  PartitioningConfig_SingleMachineCenterInitializationType_RANDOM_INITIALIZATION = 1
};
bool PartitioningConfig_SingleMachineCenterInitializationType_IsValid(int value);
constexpr PartitioningConfig_SingleMachineCenterInitializationType PartitioningConfig_SingleMachineCenterInitializationType_SingleMachineCenterInitializationType_MIN = PartitioningConfig_SingleMachineCenterInitializationType_DEFAULT_KMEANS_PLUS_PLUS;
constexpr PartitioningConfig_SingleMachineCenterInitializationType PartitioningConfig_SingleMachineCenterInitializationType_SingleMachineCenterInitializationType_MAX = PartitioningConfig_SingleMachineCenterInitializationType_RANDOM_INITIALIZATION;
constexpr int PartitioningConfig_SingleMachineCenterInitializationType_SingleMachineCenterInitializationType_ARRAYSIZE = PartitioningConfig_SingleMachineCenterInitializationType_SingleMachineCenterInitializationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PartitioningConfig_SingleMachineCenterInitializationType_descriptor();
template<typename T>
inline const std::string& PartitioningConfig_SingleMachineCenterInitializationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PartitioningConfig_SingleMachineCenterInitializationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PartitioningConfig_SingleMachineCenterInitializationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PartitioningConfig_SingleMachineCenterInitializationType_descriptor(), enum_t_value);
}
inline bool PartitioningConfig_SingleMachineCenterInitializationType_Parse(
    const std::string& name, PartitioningConfig_SingleMachineCenterInitializationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PartitioningConfig_SingleMachineCenterInitializationType>(
    PartitioningConfig_SingleMachineCenterInitializationType_descriptor(), name, value);
}
enum PartitioningConfig_PartitionerTrainerType : int {
  PartitioningConfig_PartitionerTrainerType_DEFAULT_SAMPLING_TRAINER = 0,
  PartitioningConfig_PartitionerTrainerType_FLUME_KMEANS_TRAINER = 1,
  PartitioningConfig_PartitionerTrainerType_PCA_KMEANS_TRAINER = 3,
  PartitioningConfig_PartitionerTrainerType_SAMPLING_PCA_KMEANS_TRAINER = 4
};
bool PartitioningConfig_PartitionerTrainerType_IsValid(int value);
constexpr PartitioningConfig_PartitionerTrainerType PartitioningConfig_PartitionerTrainerType_PartitionerTrainerType_MIN = PartitioningConfig_PartitionerTrainerType_DEFAULT_SAMPLING_TRAINER;
constexpr PartitioningConfig_PartitionerTrainerType PartitioningConfig_PartitionerTrainerType_PartitionerTrainerType_MAX = PartitioningConfig_PartitionerTrainerType_SAMPLING_PCA_KMEANS_TRAINER;
constexpr int PartitioningConfig_PartitionerTrainerType_PartitionerTrainerType_ARRAYSIZE = PartitioningConfig_PartitionerTrainerType_PartitionerTrainerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PartitioningConfig_PartitionerTrainerType_descriptor();
template<typename T>
inline const std::string& PartitioningConfig_PartitionerTrainerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PartitioningConfig_PartitionerTrainerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PartitioningConfig_PartitionerTrainerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PartitioningConfig_PartitionerTrainerType_descriptor(), enum_t_value);
}
inline bool PartitioningConfig_PartitionerTrainerType_Parse(
    const std::string& name, PartitioningConfig_PartitionerTrainerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PartitioningConfig_PartitionerTrainerType>(
    PartitioningConfig_PartitionerTrainerType_descriptor(), name, value);
}
enum DatabaseSpillingConfig_SpillingType : int {
  DatabaseSpillingConfig_SpillingType_NO_SPILLING = 0,
  DatabaseSpillingConfig_SpillingType_MULTIPLICATIVE = 1,
  DatabaseSpillingConfig_SpillingType_ADDITIVE = 2,
  DatabaseSpillingConfig_SpillingType_FIXED_NUMBER_OF_CENTERS = 3
};
bool DatabaseSpillingConfig_SpillingType_IsValid(int value);
constexpr DatabaseSpillingConfig_SpillingType DatabaseSpillingConfig_SpillingType_SpillingType_MIN = DatabaseSpillingConfig_SpillingType_NO_SPILLING;
constexpr DatabaseSpillingConfig_SpillingType DatabaseSpillingConfig_SpillingType_SpillingType_MAX = DatabaseSpillingConfig_SpillingType_FIXED_NUMBER_OF_CENTERS;
constexpr int DatabaseSpillingConfig_SpillingType_SpillingType_ARRAYSIZE = DatabaseSpillingConfig_SpillingType_SpillingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DatabaseSpillingConfig_SpillingType_descriptor();
template<typename T>
inline const std::string& DatabaseSpillingConfig_SpillingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DatabaseSpillingConfig_SpillingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DatabaseSpillingConfig_SpillingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DatabaseSpillingConfig_SpillingType_descriptor(), enum_t_value);
}
inline bool DatabaseSpillingConfig_SpillingType_Parse(
    const std::string& name, DatabaseSpillingConfig_SpillingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DatabaseSpillingConfig_SpillingType>(
    DatabaseSpillingConfig_SpillingType_descriptor(), name, value);
}
enum QuerySpillingConfig_SpillingType : int {
  QuerySpillingConfig_SpillingType_NO_SPILLING = 0,
  QuerySpillingConfig_SpillingType_MULTIPLICATIVE = 1,
  QuerySpillingConfig_SpillingType_ADDITIVE = 2,
  QuerySpillingConfig_SpillingType_ABSOLUTE_DISTANCE = 3,
  QuerySpillingConfig_SpillingType_FIXED_NUMBER_OF_CENTERS = 4
};
bool QuerySpillingConfig_SpillingType_IsValid(int value);
constexpr QuerySpillingConfig_SpillingType QuerySpillingConfig_SpillingType_SpillingType_MIN = QuerySpillingConfig_SpillingType_NO_SPILLING;
constexpr QuerySpillingConfig_SpillingType QuerySpillingConfig_SpillingType_SpillingType_MAX = QuerySpillingConfig_SpillingType_FIXED_NUMBER_OF_CENTERS;
constexpr int QuerySpillingConfig_SpillingType_SpillingType_ARRAYSIZE = QuerySpillingConfig_SpillingType_SpillingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuerySpillingConfig_SpillingType_descriptor();
template<typename T>
inline const std::string& QuerySpillingConfig_SpillingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuerySpillingConfig_SpillingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuerySpillingConfig_SpillingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuerySpillingConfig_SpillingType_descriptor(), enum_t_value);
}
inline bool QuerySpillingConfig_SpillingType_Parse(
    const std::string& name, QuerySpillingConfig_SpillingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuerySpillingConfig_SpillingType>(
    QuerySpillingConfig_SpillingType_descriptor(), name, value);
}
// ===================================================================

class PartitioningConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.PartitioningConfig) */ {
 public:
  PartitioningConfig();
  virtual ~PartitioningConfig();

  PartitioningConfig(const PartitioningConfig& from);
  PartitioningConfig(PartitioningConfig&& from) noexcept
    : PartitioningConfig() {
    *this = ::std::move(from);
  }

  inline PartitioningConfig& operator=(const PartitioningConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitioningConfig& operator=(PartitioningConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartitioningConfig& default_instance();

  enum SamplingFractionOrExpectedSizeCase {
    kPartitioningSamplingFraction = 4,
    kExpectedSampleSize = 45,
    SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartitioningConfig* internal_default_instance() {
    return reinterpret_cast<const PartitioningConfig*>(
               &_PartitioningConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PartitioningConfig& a, PartitioningConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitioningConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartitioningConfig* New() const final {
    return CreateMaybeMessage<PartitioningConfig>(nullptr);
  }

  PartitioningConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartitioningConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartitioningConfig& from);
  void MergeFrom(const PartitioningConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitioningConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.PartitioningConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2fpartitioning_2eproto);
    return ::descriptor_table_scann_2fproto_2fpartitioning_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PartitioningConfig_TreeType TreeType;
  static constexpr TreeType KMEANS_TREE =
    PartitioningConfig_TreeType_KMEANS_TREE;
  static constexpr TreeType PCA_TREE =
    PartitioningConfig_TreeType_PCA_TREE;
  static constexpr TreeType RANDOM_PROJECTION_TREE =
    PartitioningConfig_TreeType_RANDOM_PROJECTION_TREE;
  static constexpr TreeType BALL_TREE =
    PartitioningConfig_TreeType_BALL_TREE;
  static constexpr TreeType RANDOM =
    PartitioningConfig_TreeType_RANDOM;
  static constexpr TreeType TREE_X_HYBRID =
    PartitioningConfig_TreeType_TREE_X_HYBRID;
  static inline bool TreeType_IsValid(int value) {
    return PartitioningConfig_TreeType_IsValid(value);
  }
  static constexpr TreeType TreeType_MIN =
    PartitioningConfig_TreeType_TreeType_MIN;
  static constexpr TreeType TreeType_MAX =
    PartitioningConfig_TreeType_TreeType_MAX;
  static constexpr int TreeType_ARRAYSIZE =
    PartitioningConfig_TreeType_TreeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TreeType_descriptor() {
    return PartitioningConfig_TreeType_descriptor();
  }
  template<typename T>
  static inline const std::string& TreeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TreeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TreeType_Name.");
    return PartitioningConfig_TreeType_Name(enum_t_value);
  }
  static inline bool TreeType_Parse(const std::string& name,
      TreeType* value) {
    return PartitioningConfig_TreeType_Parse(name, value);
  }

  typedef PartitioningConfig_TokenizationType TokenizationType;
  static constexpr TokenizationType FLOAT =
    PartitioningConfig_TokenizationType_FLOAT;
  static constexpr TokenizationType FIXED_POINT_INT8 =
    PartitioningConfig_TokenizationType_FIXED_POINT_INT8;
  static constexpr TokenizationType ASYMMETRIC =
    PartitioningConfig_TokenizationType_ASYMMETRIC;
  static inline bool TokenizationType_IsValid(int value) {
    return PartitioningConfig_TokenizationType_IsValid(value);
  }
  static constexpr TokenizationType TokenizationType_MIN =
    PartitioningConfig_TokenizationType_TokenizationType_MIN;
  static constexpr TokenizationType TokenizationType_MAX =
    PartitioningConfig_TokenizationType_TokenizationType_MAX;
  static constexpr int TokenizationType_ARRAYSIZE =
    PartitioningConfig_TokenizationType_TokenizationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TokenizationType_descriptor() {
    return PartitioningConfig_TokenizationType_descriptor();
  }
  template<typename T>
  static inline const std::string& TokenizationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TokenizationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TokenizationType_Name.");
    return PartitioningConfig_TokenizationType_Name(enum_t_value);
  }
  static inline bool TokenizationType_Parse(const std::string& name,
      TokenizationType* value) {
    return PartitioningConfig_TokenizationType_Parse(name, value);
  }

  typedef PartitioningConfig_PartitioningType PartitioningType;
  static constexpr PartitioningType GENERIC =
    PartitioningConfig_PartitioningType_GENERIC;
  static constexpr PartitioningType SPHERICAL =
    PartitioningConfig_PartitioningType_SPHERICAL;
  static inline bool PartitioningType_IsValid(int value) {
    return PartitioningConfig_PartitioningType_IsValid(value);
  }
  static constexpr PartitioningType PartitioningType_MIN =
    PartitioningConfig_PartitioningType_PartitioningType_MIN;
  static constexpr PartitioningType PartitioningType_MAX =
    PartitioningConfig_PartitioningType_PartitioningType_MAX;
  static constexpr int PartitioningType_ARRAYSIZE =
    PartitioningConfig_PartitioningType_PartitioningType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PartitioningType_descriptor() {
    return PartitioningConfig_PartitioningType_descriptor();
  }
  template<typename T>
  static inline const std::string& PartitioningType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PartitioningType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PartitioningType_Name.");
    return PartitioningConfig_PartitioningType_Name(enum_t_value);
  }
  static inline bool PartitioningType_Parse(const std::string& name,
      PartitioningType* value) {
    return PartitioningConfig_PartitioningType_Parse(name, value);
  }

  typedef PartitioningConfig_BalancingType BalancingType;
  static constexpr BalancingType DEFAULT_UNBALANCED =
    PartitioningConfig_BalancingType_DEFAULT_UNBALANCED;
  static constexpr BalancingType GREEDY_BALANCED =
    PartitioningConfig_BalancingType_GREEDY_BALANCED;
  static inline bool BalancingType_IsValid(int value) {
    return PartitioningConfig_BalancingType_IsValid(value);
  }
  static constexpr BalancingType BalancingType_MIN =
    PartitioningConfig_BalancingType_BalancingType_MIN;
  static constexpr BalancingType BalancingType_MAX =
    PartitioningConfig_BalancingType_BalancingType_MAX;
  static constexpr int BalancingType_ARRAYSIZE =
    PartitioningConfig_BalancingType_BalancingType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BalancingType_descriptor() {
    return PartitioningConfig_BalancingType_descriptor();
  }
  template<typename T>
  static inline const std::string& BalancingType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BalancingType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BalancingType_Name.");
    return PartitioningConfig_BalancingType_Name(enum_t_value);
  }
  static inline bool BalancingType_Parse(const std::string& name,
      BalancingType* value) {
    return PartitioningConfig_BalancingType_Parse(name, value);
  }

  typedef PartitioningConfig_SingleMachineCenterInitializationType SingleMachineCenterInitializationType;
  static constexpr SingleMachineCenterInitializationType DEFAULT_KMEANS_PLUS_PLUS =
    PartitioningConfig_SingleMachineCenterInitializationType_DEFAULT_KMEANS_PLUS_PLUS;
  static constexpr SingleMachineCenterInitializationType RANDOM_INITIALIZATION =
    PartitioningConfig_SingleMachineCenterInitializationType_RANDOM_INITIALIZATION;
  static inline bool SingleMachineCenterInitializationType_IsValid(int value) {
    return PartitioningConfig_SingleMachineCenterInitializationType_IsValid(value);
  }
  static constexpr SingleMachineCenterInitializationType SingleMachineCenterInitializationType_MIN =
    PartitioningConfig_SingleMachineCenterInitializationType_SingleMachineCenterInitializationType_MIN;
  static constexpr SingleMachineCenterInitializationType SingleMachineCenterInitializationType_MAX =
    PartitioningConfig_SingleMachineCenterInitializationType_SingleMachineCenterInitializationType_MAX;
  static constexpr int SingleMachineCenterInitializationType_ARRAYSIZE =
    PartitioningConfig_SingleMachineCenterInitializationType_SingleMachineCenterInitializationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SingleMachineCenterInitializationType_descriptor() {
    return PartitioningConfig_SingleMachineCenterInitializationType_descriptor();
  }
  template<typename T>
  static inline const std::string& SingleMachineCenterInitializationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SingleMachineCenterInitializationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SingleMachineCenterInitializationType_Name.");
    return PartitioningConfig_SingleMachineCenterInitializationType_Name(enum_t_value);
  }
  static inline bool SingleMachineCenterInitializationType_Parse(const std::string& name,
      SingleMachineCenterInitializationType* value) {
    return PartitioningConfig_SingleMachineCenterInitializationType_Parse(name, value);
  }

  typedef PartitioningConfig_PartitionerTrainerType PartitionerTrainerType;
  static constexpr PartitionerTrainerType DEFAULT_SAMPLING_TRAINER =
    PartitioningConfig_PartitionerTrainerType_DEFAULT_SAMPLING_TRAINER;
  static constexpr PartitionerTrainerType FLUME_KMEANS_TRAINER =
    PartitioningConfig_PartitionerTrainerType_FLUME_KMEANS_TRAINER;
  static constexpr PartitionerTrainerType PCA_KMEANS_TRAINER =
    PartitioningConfig_PartitionerTrainerType_PCA_KMEANS_TRAINER;
  static constexpr PartitionerTrainerType SAMPLING_PCA_KMEANS_TRAINER =
    PartitioningConfig_PartitionerTrainerType_SAMPLING_PCA_KMEANS_TRAINER;
  static inline bool PartitionerTrainerType_IsValid(int value) {
    return PartitioningConfig_PartitionerTrainerType_IsValid(value);
  }
  static constexpr PartitionerTrainerType PartitionerTrainerType_MIN =
    PartitioningConfig_PartitionerTrainerType_PartitionerTrainerType_MIN;
  static constexpr PartitionerTrainerType PartitionerTrainerType_MAX =
    PartitioningConfig_PartitionerTrainerType_PartitionerTrainerType_MAX;
  static constexpr int PartitionerTrainerType_ARRAYSIZE =
    PartitioningConfig_PartitionerTrainerType_PartitionerTrainerType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PartitionerTrainerType_descriptor() {
    return PartitioningConfig_PartitionerTrainerType_descriptor();
  }
  template<typename T>
  static inline const std::string& PartitionerTrainerType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PartitionerTrainerType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PartitionerTrainerType_Name.");
    return PartitioningConfig_PartitionerTrainerType_Name(enum_t_value);
  }
  static inline bool PartitionerTrainerType_Parse(const std::string& name,
      PartitionerTrainerType* value) {
    return PartitioningConfig_PartitionerTrainerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionerPrefixFieldNumber = 8,
    kMrJobnamePrefixFieldNumber = 13,
    kReshardedPrefixFieldNumber = 14,
    kCellFieldNumber = 15,
    kTrainerStatsPrefixFieldNumber = 37,
    kPartitioningDistanceFieldNumber = 10,
    kProjectionFieldNumber = 12,
    kDatabaseSpillingFieldNumber = 20,
    kQuerySpillingFieldNumber = 21,
    kDatabaseTokenizationDistanceOverrideFieldNumber = 24,
    kQueryTokenizationDistanceOverrideFieldNumber = 25,
    kTreeXHybridFieldNumber = 46,
    kPartitioningTypeFieldNumber = 23,
    kClusteringSeedFieldNumber = 27,
    kTreeTypeFieldNumber = 31,
    kComputeResidualStdevFieldNumber = 47,
    kUseFloatCentersForQueryTokenizationFieldNumber = 26,
    kPartitioningOnTheFlyFieldNumber = 22,
    kUseFlumeKmeansFieldNumber = 32,
    kBalancingTypeFieldNumber = 35,
    kTrainerTypeFieldNumber = 36,
    kPerturbationFieldNumber = 41,
    kMaxClusterSizeFieldNumber = 40,
    kSingleMachineCenterInitializationFieldNumber = 49,
    kNumPartitioningEpochsFieldNumber = 1,
    kMaxNumLevelsFieldNumber = 2,
    kNumChildrenFieldNumber = 3,
    kMaxClusteringIterationsFieldNumber = 6,
    kClusteringConvergenceToleranceFieldNumber = 7,
    kMinClusterSizeFieldNumber = 9,
    kMaxLeafSizeFieldNumber = 11,
    kRamGbFieldNumber = 16,
    kDiskGbFieldNumber = 17,
    kNumCpusFieldNumber = 19,
    kQueryTokenizationTypeFieldNumber = 28,
    kDatabaseTokenizationTypeFieldNumber = 29,
    kNumMapperMachinesFieldNumber = 30,
    kMaxSampleSizeFieldNumber = 33,
    kDesiredAverageClusterSizeFieldNumber = 34,
    kNumMiniBatchesFieldNumber = 38,
    kMaxPowerOf2SplitFieldNumber = 39,
    kNumTopTokensForPcaFieldNumber = 42,
    kPcaSplittingSimilarityThresholdFieldNumber = 43,
    kAvqFieldNumber = 51,
    kResidualStdevMinValueFieldNumber = 48,
    kPartitioningSamplingFractionFieldNumber = 4,
    kExpectedSampleSizeFieldNumber = 45,
  };
  // optional string partitioner_prefix = 8;
  bool has_partitioner_prefix() const;
  void clear_partitioner_prefix();
  const std::string& partitioner_prefix() const;
  void set_partitioner_prefix(const std::string& value);
  void set_partitioner_prefix(std::string&& value);
  void set_partitioner_prefix(const char* value);
  void set_partitioner_prefix(const char* value, size_t size);
  std::string* mutable_partitioner_prefix();
  std::string* release_partitioner_prefix();
  void set_allocated_partitioner_prefix(std::string* partitioner_prefix);

  // optional string mr_jobname_prefix = 13 [default = "PartitionReshard"];
  bool has_mr_jobname_prefix() const;
  void clear_mr_jobname_prefix();
  const std::string& mr_jobname_prefix() const;
  void set_mr_jobname_prefix(const std::string& value);
  void set_mr_jobname_prefix(std::string&& value);
  void set_mr_jobname_prefix(const char* value);
  void set_mr_jobname_prefix(const char* value, size_t size);
  std::string* mutable_mr_jobname_prefix();
  std::string* release_mr_jobname_prefix();
  void set_allocated_mr_jobname_prefix(std::string* mr_jobname_prefix);

  // optional string resharded_prefix = 14;
  bool has_resharded_prefix() const;
  void clear_resharded_prefix();
  const std::string& resharded_prefix() const;
  void set_resharded_prefix(const std::string& value);
  void set_resharded_prefix(std::string&& value);
  void set_resharded_prefix(const char* value);
  void set_resharded_prefix(const char* value, size_t size);
  std::string* mutable_resharded_prefix();
  std::string* release_resharded_prefix();
  void set_allocated_resharded_prefix(std::string* resharded_prefix);

  // optional string cell = 15;
  bool has_cell() const;
  void clear_cell();
  const std::string& cell() const;
  void set_cell(const std::string& value);
  void set_cell(std::string&& value);
  void set_cell(const char* value);
  void set_cell(const char* value, size_t size);
  std::string* mutable_cell();
  std::string* release_cell();
  void set_allocated_cell(std::string* cell);

  // optional string trainer_stats_prefix = 37;
  bool has_trainer_stats_prefix() const;
  void clear_trainer_stats_prefix();
  const std::string& trainer_stats_prefix() const;
  void set_trainer_stats_prefix(const std::string& value);
  void set_trainer_stats_prefix(std::string&& value);
  void set_trainer_stats_prefix(const char* value);
  void set_trainer_stats_prefix(const char* value, size_t size);
  std::string* mutable_trainer_stats_prefix();
  std::string* release_trainer_stats_prefix();
  void set_allocated_trainer_stats_prefix(std::string* trainer_stats_prefix);

  // optional .research_scann.DistanceMeasureConfig partitioning_distance = 10;
  bool has_partitioning_distance() const;
  void clear_partitioning_distance();
  const ::research_scann::DistanceMeasureConfig& partitioning_distance() const;
  ::research_scann::DistanceMeasureConfig* release_partitioning_distance();
  ::research_scann::DistanceMeasureConfig* mutable_partitioning_distance();
  void set_allocated_partitioning_distance(::research_scann::DistanceMeasureConfig* partitioning_distance);

  // optional .research_scann.ProjectionConfig projection = 12;
  bool has_projection() const;
  void clear_projection();
  const ::research_scann::ProjectionConfig& projection() const;
  ::research_scann::ProjectionConfig* release_projection();
  ::research_scann::ProjectionConfig* mutable_projection();
  void set_allocated_projection(::research_scann::ProjectionConfig* projection);

  // optional .research_scann.DatabaseSpillingConfig database_spilling = 20;
  bool has_database_spilling() const;
  void clear_database_spilling();
  const ::research_scann::DatabaseSpillingConfig& database_spilling() const;
  ::research_scann::DatabaseSpillingConfig* release_database_spilling();
  ::research_scann::DatabaseSpillingConfig* mutable_database_spilling();
  void set_allocated_database_spilling(::research_scann::DatabaseSpillingConfig* database_spilling);

  // optional .research_scann.QuerySpillingConfig query_spilling = 21;
  bool has_query_spilling() const;
  void clear_query_spilling();
  const ::research_scann::QuerySpillingConfig& query_spilling() const;
  ::research_scann::QuerySpillingConfig* release_query_spilling();
  ::research_scann::QuerySpillingConfig* mutable_query_spilling();
  void set_allocated_query_spilling(::research_scann::QuerySpillingConfig* query_spilling);

  // optional .research_scann.DistanceMeasureConfig database_tokenization_distance_override = 24;
  bool has_database_tokenization_distance_override() const;
  void clear_database_tokenization_distance_override();
  const ::research_scann::DistanceMeasureConfig& database_tokenization_distance_override() const;
  ::research_scann::DistanceMeasureConfig* release_database_tokenization_distance_override();
  ::research_scann::DistanceMeasureConfig* mutable_database_tokenization_distance_override();
  void set_allocated_database_tokenization_distance_override(::research_scann::DistanceMeasureConfig* database_tokenization_distance_override);

  // optional .research_scann.DistanceMeasureConfig query_tokenization_distance_override = 25;
  bool has_query_tokenization_distance_override() const;
  void clear_query_tokenization_distance_override();
  const ::research_scann::DistanceMeasureConfig& query_tokenization_distance_override() const;
  ::research_scann::DistanceMeasureConfig* release_query_tokenization_distance_override();
  ::research_scann::DistanceMeasureConfig* mutable_query_tokenization_distance_override();
  void set_allocated_query_tokenization_distance_override(::research_scann::DistanceMeasureConfig* query_tokenization_distance_override);

  // optional .research_scann.TreeXHybridPartitioningConfig tree_x_hybrid = 46;
  bool has_tree_x_hybrid() const;
  void clear_tree_x_hybrid();
  const ::research_scann::TreeXHybridPartitioningConfig& tree_x_hybrid() const;
  ::research_scann::TreeXHybridPartitioningConfig* release_tree_x_hybrid();
  ::research_scann::TreeXHybridPartitioningConfig* mutable_tree_x_hybrid();
  void set_allocated_tree_x_hybrid(::research_scann::TreeXHybridPartitioningConfig* tree_x_hybrid);

  // optional .research_scann.PartitioningConfig.PartitioningType partitioning_type = 23 [default = GENERIC];
  bool has_partitioning_type() const;
  void clear_partitioning_type();
  ::research_scann::PartitioningConfig_PartitioningType partitioning_type() const;
  void set_partitioning_type(::research_scann::PartitioningConfig_PartitioningType value);

  // optional int32 clustering_seed = 27 [default = 0];
  bool has_clustering_seed() const;
  void clear_clustering_seed();
  ::PROTOBUF_NAMESPACE_ID::int32 clustering_seed() const;
  void set_clustering_seed(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .research_scann.PartitioningConfig.TreeType tree_type = 31 [default = KMEANS_TREE];
  bool has_tree_type() const;
  void clear_tree_type();
  ::research_scann::PartitioningConfig_TreeType tree_type() const;
  void set_tree_type(::research_scann::PartitioningConfig_TreeType value);

  // optional bool compute_residual_stdev = 47 [default = false];
  bool has_compute_residual_stdev() const;
  void clear_compute_residual_stdev();
  bool compute_residual_stdev() const;
  void set_compute_residual_stdev(bool value);

  // optional bool use_float_centers_for_query_tokenization = 26 [default = false, deprecated = true];
  PROTOBUF_DEPRECATED bool has_use_float_centers_for_query_tokenization() const;
  PROTOBUF_DEPRECATED void clear_use_float_centers_for_query_tokenization();
  PROTOBUF_DEPRECATED bool use_float_centers_for_query_tokenization() const;
  PROTOBUF_DEPRECATED void set_use_float_centers_for_query_tokenization(bool value);

  // optional bool partitioning_on_the_fly = 22 [default = false, deprecated = true];
  PROTOBUF_DEPRECATED bool has_partitioning_on_the_fly() const;
  PROTOBUF_DEPRECATED void clear_partitioning_on_the_fly();
  PROTOBUF_DEPRECATED bool partitioning_on_the_fly() const;
  PROTOBUF_DEPRECATED void set_partitioning_on_the_fly(bool value);

  // optional bool use_flume_kmeans = 32 [default = false, deprecated = true];
  PROTOBUF_DEPRECATED bool has_use_flume_kmeans() const;
  PROTOBUF_DEPRECATED void clear_use_flume_kmeans();
  PROTOBUF_DEPRECATED bool use_flume_kmeans() const;
  PROTOBUF_DEPRECATED void set_use_flume_kmeans(bool value);

  // optional .research_scann.PartitioningConfig.BalancingType balancing_type = 35 [default = DEFAULT_UNBALANCED];
  bool has_balancing_type() const;
  void clear_balancing_type();
  ::research_scann::PartitioningConfig_BalancingType balancing_type() const;
  void set_balancing_type(::research_scann::PartitioningConfig_BalancingType value);

  // optional .research_scann.PartitioningConfig.PartitionerTrainerType trainer_type = 36 [default = DEFAULT_SAMPLING_TRAINER];
  bool has_trainer_type() const;
  void clear_trainer_type();
  ::research_scann::PartitioningConfig_PartitionerTrainerType trainer_type() const;
  void set_trainer_type(::research_scann::PartitioningConfig_PartitionerTrainerType value);

  // optional double perturbation = 41;
  bool has_perturbation() const;
  void clear_perturbation();
  double perturbation() const;
  void set_perturbation(double value);

  // optional int32 max_cluster_size = 40;
  bool has_max_cluster_size() const;
  void clear_max_cluster_size();
  ::PROTOBUF_NAMESPACE_ID::int32 max_cluster_size() const;
  void set_max_cluster_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .research_scann.PartitioningConfig.SingleMachineCenterInitializationType single_machine_center_initialization = 49 [default = DEFAULT_KMEANS_PLUS_PLUS];
  bool has_single_machine_center_initialization() const;
  void clear_single_machine_center_initialization();
  ::research_scann::PartitioningConfig_SingleMachineCenterInitializationType single_machine_center_initialization() const;
  void set_single_machine_center_initialization(::research_scann::PartitioningConfig_SingleMachineCenterInitializationType value);

  // optional int32 num_partitioning_epochs = 1 [default = 1];
  bool has_num_partitioning_epochs() const;
  void clear_num_partitioning_epochs();
  ::PROTOBUF_NAMESPACE_ID::int32 num_partitioning_epochs() const;
  void set_num_partitioning_epochs(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 max_num_levels = 2 [default = 1];
  bool has_max_num_levels() const;
  void clear_max_num_levels();
  ::PROTOBUF_NAMESPACE_ID::int32 max_num_levels() const;
  void set_max_num_levels(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_children = 3 [default = 2];
  bool has_num_children() const;
  void clear_num_children();
  ::PROTOBUF_NAMESPACE_ID::int32 num_children() const;
  void set_num_children(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 max_clustering_iterations = 6 [default = 10];
  bool has_max_clustering_iterations() const;
  void clear_max_clustering_iterations();
  ::PROTOBUF_NAMESPACE_ID::int32 max_clustering_iterations() const;
  void set_max_clustering_iterations(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional float clustering_convergence_tolerance = 7 [default = 1e-05];
  bool has_clustering_convergence_tolerance() const;
  void clear_clustering_convergence_tolerance();
  float clustering_convergence_tolerance() const;
  void set_clustering_convergence_tolerance(float value);

  // optional float min_cluster_size = 9 [default = 1];
  bool has_min_cluster_size() const;
  void clear_min_cluster_size();
  float min_cluster_size() const;
  void set_min_cluster_size(float value);

  // optional int32 max_leaf_size = 11 [default = 1];
  bool has_max_leaf_size() const;
  void clear_max_leaf_size();
  ::PROTOBUF_NAMESPACE_ID::int32 max_leaf_size() const;
  void set_max_leaf_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 ram_gb = 16 [default = 4];
  bool has_ram_gb() const;
  void clear_ram_gb();
  ::PROTOBUF_NAMESPACE_ID::int32 ram_gb() const;
  void set_ram_gb(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 disk_gb = 17 [default = 1];
  bool has_disk_gb() const;
  void clear_disk_gb();
  ::PROTOBUF_NAMESPACE_ID::int32 disk_gb() const;
  void set_disk_gb(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_cpus = 19 [default = 1];
  bool has_num_cpus() const;
  void clear_num_cpus();
  ::PROTOBUF_NAMESPACE_ID::int32 num_cpus() const;
  void set_num_cpus(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .research_scann.PartitioningConfig.TokenizationType query_tokenization_type = 28 [default = FLOAT];
  bool has_query_tokenization_type() const;
  void clear_query_tokenization_type();
  ::research_scann::PartitioningConfig_TokenizationType query_tokenization_type() const;
  void set_query_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value);

  // optional .research_scann.PartitioningConfig.TokenizationType database_tokenization_type = 29 [default = FLOAT];
  bool has_database_tokenization_type() const;
  void clear_database_tokenization_type();
  ::research_scann::PartitioningConfig_TokenizationType database_tokenization_type() const;
  void set_database_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value);

  // optional int32 num_mapper_machines = 30 [default = -1];
  bool has_num_mapper_machines() const;
  void clear_num_mapper_machines();
  ::PROTOBUF_NAMESPACE_ID::int32 num_mapper_machines() const;
  void set_num_mapper_machines(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 max_sample_size = 33 [default = 2147483647, deprecated = true];
  PROTOBUF_DEPRECATED bool has_max_sample_size() const;
  PROTOBUF_DEPRECATED void clear_max_sample_size();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 max_sample_size() const;
  PROTOBUF_DEPRECATED void set_max_sample_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 desired_average_cluster_size = 34 [default = 3000];
  bool has_desired_average_cluster_size() const;
  void clear_desired_average_cluster_size();
  ::PROTOBUF_NAMESPACE_ID::int32 desired_average_cluster_size() const;
  void set_desired_average_cluster_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_mini_batches = 38 [default = 1];
  bool has_num_mini_batches() const;
  void clear_num_mini_batches();
  ::PROTOBUF_NAMESPACE_ID::int32 num_mini_batches() const;
  void set_num_mini_batches(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 max_power_of_2_split = 39 [default = 2];
  bool has_max_power_of_2_split() const;
  void clear_max_power_of_2_split();
  ::PROTOBUF_NAMESPACE_ID::int32 max_power_of_2_split() const;
  void set_max_power_of_2_split(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_top_tokens_for_pca = 42 [default = 20];
  bool has_num_top_tokens_for_pca() const;
  void clear_num_top_tokens_for_pca();
  ::PROTOBUF_NAMESPACE_ID::int32 num_top_tokens_for_pca() const;
  void set_num_top_tokens_for_pca(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional float pca_splitting_similarity_threshold = 43 [default = 1e-05];
  bool has_pca_splitting_similarity_threshold() const;
  void clear_pca_splitting_similarity_threshold();
  float pca_splitting_similarity_threshold() const;
  void set_pca_splitting_similarity_threshold(float value);

  // optional float avq = 51 [default = nan];
  bool has_avq() const;
  void clear_avq();
  float avq() const;
  void set_avq(float value);

  // optional double residual_stdev_min_value = 48 [default = 1e-05];
  bool has_residual_stdev_min_value() const;
  void clear_residual_stdev_min_value();
  double residual_stdev_min_value() const;
  void set_residual_stdev_min_value(double value);

  // optional float partitioning_sampling_fraction = 4 [default = 1];
  bool has_partitioning_sampling_fraction() const;
  void clear_partitioning_sampling_fraction();
  float partitioning_sampling_fraction() const;
  void set_partitioning_sampling_fraction(float value);

  // optional int32 expected_sample_size = 45;
  bool has_expected_sample_size() const;
  void clear_expected_sample_size();
  ::PROTOBUF_NAMESPACE_ID::int32 expected_sample_size() const;
  void set_expected_sample_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  void clear_SamplingFractionOrExpectedSize();
  SamplingFractionOrExpectedSizeCase SamplingFractionOrExpectedSize_case() const;
  // @@protoc_insertion_point(class_scope:research_scann.PartitioningConfig)
 private:
  class _Internal;
  void set_has_partitioning_sampling_fraction();
  void set_has_expected_sample_size();

  inline bool has_SamplingFractionOrExpectedSize() const;
  inline void clear_has_SamplingFractionOrExpectedSize();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partitioner_prefix_;
  public:
  static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> _i_give_permission_to_break_this_code_default_mr_jobname_prefix_;
  private:
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mr_jobname_prefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resharded_prefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cell_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trainer_stats_prefix_;
  ::research_scann::DistanceMeasureConfig* partitioning_distance_;
  ::research_scann::ProjectionConfig* projection_;
  ::research_scann::DatabaseSpillingConfig* database_spilling_;
  ::research_scann::QuerySpillingConfig* query_spilling_;
  ::research_scann::DistanceMeasureConfig* database_tokenization_distance_override_;
  ::research_scann::DistanceMeasureConfig* query_tokenization_distance_override_;
  ::research_scann::TreeXHybridPartitioningConfig* tree_x_hybrid_;
  int partitioning_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 clustering_seed_;
  int tree_type_;
  bool compute_residual_stdev_;
  bool use_float_centers_for_query_tokenization_;
  bool partitioning_on_the_fly_;
  bool use_flume_kmeans_;
  int balancing_type_;
  int trainer_type_;
  double perturbation_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_cluster_size_;
  int single_machine_center_initialization_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_partitioning_epochs_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_num_levels_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_children_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_clustering_iterations_;
  float clustering_convergence_tolerance_;
  float min_cluster_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_leaf_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 ram_gb_;
  ::PROTOBUF_NAMESPACE_ID::int32 disk_gb_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_cpus_;
  int query_tokenization_type_;
  int database_tokenization_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_mapper_machines_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_sample_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 desired_average_cluster_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_mini_batches_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_power_of_2_split_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_top_tokens_for_pca_;
  float pca_splitting_similarity_threshold_;
  float avq_;
  double residual_stdev_min_value_;
  union SamplingFractionOrExpectedSizeUnion {
    SamplingFractionOrExpectedSizeUnion() {}
    float partitioning_sampling_fraction_;
    ::PROTOBUF_NAMESPACE_ID::int32 expected_sample_size_;
  } SamplingFractionOrExpectedSize_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_scann_2fproto_2fpartitioning_2eproto;
};
// -------------------------------------------------------------------

class DatabaseSpillingConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.DatabaseSpillingConfig) */ {
 public:
  DatabaseSpillingConfig();
  virtual ~DatabaseSpillingConfig();

  DatabaseSpillingConfig(const DatabaseSpillingConfig& from);
  DatabaseSpillingConfig(DatabaseSpillingConfig&& from) noexcept
    : DatabaseSpillingConfig() {
    *this = ::std::move(from);
  }

  inline DatabaseSpillingConfig& operator=(const DatabaseSpillingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatabaseSpillingConfig& operator=(DatabaseSpillingConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DatabaseSpillingConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DatabaseSpillingConfig* internal_default_instance() {
    return reinterpret_cast<const DatabaseSpillingConfig*>(
               &_DatabaseSpillingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DatabaseSpillingConfig& a, DatabaseSpillingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(DatabaseSpillingConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DatabaseSpillingConfig* New() const final {
    return CreateMaybeMessage<DatabaseSpillingConfig>(nullptr);
  }

  DatabaseSpillingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DatabaseSpillingConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DatabaseSpillingConfig& from);
  void MergeFrom(const DatabaseSpillingConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatabaseSpillingConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.DatabaseSpillingConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2fpartitioning_2eproto);
    return ::descriptor_table_scann_2fproto_2fpartitioning_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DatabaseSpillingConfig_SpillingType SpillingType;
  static constexpr SpillingType NO_SPILLING =
    DatabaseSpillingConfig_SpillingType_NO_SPILLING;
  static constexpr SpillingType MULTIPLICATIVE =
    DatabaseSpillingConfig_SpillingType_MULTIPLICATIVE;
  static constexpr SpillingType ADDITIVE =
    DatabaseSpillingConfig_SpillingType_ADDITIVE;
  static constexpr SpillingType FIXED_NUMBER_OF_CENTERS =
    DatabaseSpillingConfig_SpillingType_FIXED_NUMBER_OF_CENTERS;
  static inline bool SpillingType_IsValid(int value) {
    return DatabaseSpillingConfig_SpillingType_IsValid(value);
  }
  static constexpr SpillingType SpillingType_MIN =
    DatabaseSpillingConfig_SpillingType_SpillingType_MIN;
  static constexpr SpillingType SpillingType_MAX =
    DatabaseSpillingConfig_SpillingType_SpillingType_MAX;
  static constexpr int SpillingType_ARRAYSIZE =
    DatabaseSpillingConfig_SpillingType_SpillingType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SpillingType_descriptor() {
    return DatabaseSpillingConfig_SpillingType_descriptor();
  }
  template<typename T>
  static inline const std::string& SpillingType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SpillingType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SpillingType_Name.");
    return DatabaseSpillingConfig_SpillingType_Name(enum_t_value);
  }
  static inline bool SpillingType_Parse(const std::string& name,
      SpillingType* value) {
    return DatabaseSpillingConfig_SpillingType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSpillingTypeFieldNumber = 1,
    kReplicationFactorFieldNumber = 2,
    kMaxSpillCentersFieldNumber = 3,
  };
  // optional .research_scann.DatabaseSpillingConfig.SpillingType spilling_type = 1 [default = NO_SPILLING];
  bool has_spilling_type() const;
  void clear_spilling_type();
  ::research_scann::DatabaseSpillingConfig_SpillingType spilling_type() const;
  void set_spilling_type(::research_scann::DatabaseSpillingConfig_SpillingType value);

  // optional float replication_factor = 2;
  bool has_replication_factor() const;
  void clear_replication_factor();
  float replication_factor() const;
  void set_replication_factor(float value);

  // optional uint32 max_spill_centers = 3 [default = 4294967295];
  bool has_max_spill_centers() const;
  void clear_max_spill_centers();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_spill_centers() const;
  void set_max_spill_centers(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:research_scann.DatabaseSpillingConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int spilling_type_;
  float replication_factor_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_spill_centers_;
  friend struct ::TableStruct_scann_2fproto_2fpartitioning_2eproto;
};
// -------------------------------------------------------------------

class QuerySpillingConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.QuerySpillingConfig) */ {
 public:
  QuerySpillingConfig();
  virtual ~QuerySpillingConfig();

  QuerySpillingConfig(const QuerySpillingConfig& from);
  QuerySpillingConfig(QuerySpillingConfig&& from) noexcept
    : QuerySpillingConfig() {
    *this = ::std::move(from);
  }

  inline QuerySpillingConfig& operator=(const QuerySpillingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySpillingConfig& operator=(QuerySpillingConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QuerySpillingConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QuerySpillingConfig* internal_default_instance() {
    return reinterpret_cast<const QuerySpillingConfig*>(
               &_QuerySpillingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(QuerySpillingConfig& a, QuerySpillingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySpillingConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QuerySpillingConfig* New() const final {
    return CreateMaybeMessage<QuerySpillingConfig>(nullptr);
  }

  QuerySpillingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QuerySpillingConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QuerySpillingConfig& from);
  void MergeFrom(const QuerySpillingConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySpillingConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.QuerySpillingConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2fpartitioning_2eproto);
    return ::descriptor_table_scann_2fproto_2fpartitioning_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef QuerySpillingConfig_SpillingType SpillingType;
  static constexpr SpillingType NO_SPILLING =
    QuerySpillingConfig_SpillingType_NO_SPILLING;
  static constexpr SpillingType MULTIPLICATIVE =
    QuerySpillingConfig_SpillingType_MULTIPLICATIVE;
  static constexpr SpillingType ADDITIVE =
    QuerySpillingConfig_SpillingType_ADDITIVE;
  static constexpr SpillingType ABSOLUTE_DISTANCE =
    QuerySpillingConfig_SpillingType_ABSOLUTE_DISTANCE;
  static constexpr SpillingType FIXED_NUMBER_OF_CENTERS =
    QuerySpillingConfig_SpillingType_FIXED_NUMBER_OF_CENTERS;
  static inline bool SpillingType_IsValid(int value) {
    return QuerySpillingConfig_SpillingType_IsValid(value);
  }
  static constexpr SpillingType SpillingType_MIN =
    QuerySpillingConfig_SpillingType_SpillingType_MIN;
  static constexpr SpillingType SpillingType_MAX =
    QuerySpillingConfig_SpillingType_SpillingType_MAX;
  static constexpr int SpillingType_ARRAYSIZE =
    QuerySpillingConfig_SpillingType_SpillingType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SpillingType_descriptor() {
    return QuerySpillingConfig_SpillingType_descriptor();
  }
  template<typename T>
  static inline const std::string& SpillingType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SpillingType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SpillingType_Name.");
    return QuerySpillingConfig_SpillingType_Name(enum_t_value);
  }
  static inline bool SpillingType_Parse(const std::string& name,
      SpillingType* value) {
    return QuerySpillingConfig_SpillingType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSpillingTypeFieldNumber = 1,
    kSpillingThresholdFieldNumber = 2,
    kMaxSpillCentersFieldNumber = 3,
  };
  // optional .research_scann.QuerySpillingConfig.SpillingType spilling_type = 1 [default = NO_SPILLING];
  bool has_spilling_type() const;
  void clear_spilling_type();
  ::research_scann::QuerySpillingConfig_SpillingType spilling_type() const;
  void set_spilling_type(::research_scann::QuerySpillingConfig_SpillingType value);

  // optional float spilling_threshold = 2;
  bool has_spilling_threshold() const;
  void clear_spilling_threshold();
  float spilling_threshold() const;
  void set_spilling_threshold(float value);

  // optional uint32 max_spill_centers = 3 [default = 4294967295];
  bool has_max_spill_centers() const;
  void clear_max_spill_centers();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_spill_centers() const;
  void set_max_spill_centers(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:research_scann.QuerySpillingConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int spilling_type_;
  float spilling_threshold_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_spill_centers_;
  friend struct ::TableStruct_scann_2fproto_2fpartitioning_2eproto;
};
// -------------------------------------------------------------------

class TreeXHybridPartitioningConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.TreeXHybridPartitioningConfig) */ {
 public:
  TreeXHybridPartitioningConfig();
  virtual ~TreeXHybridPartitioningConfig();

  TreeXHybridPartitioningConfig(const TreeXHybridPartitioningConfig& from);
  TreeXHybridPartitioningConfig(TreeXHybridPartitioningConfig&& from) noexcept
    : TreeXHybridPartitioningConfig() {
    *this = ::std::move(from);
  }

  inline TreeXHybridPartitioningConfig& operator=(const TreeXHybridPartitioningConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TreeXHybridPartitioningConfig& operator=(TreeXHybridPartitioningConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TreeXHybridPartitioningConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TreeXHybridPartitioningConfig* internal_default_instance() {
    return reinterpret_cast<const TreeXHybridPartitioningConfig*>(
               &_TreeXHybridPartitioningConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TreeXHybridPartitioningConfig& a, TreeXHybridPartitioningConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TreeXHybridPartitioningConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TreeXHybridPartitioningConfig* New() const final {
    return CreateMaybeMessage<TreeXHybridPartitioningConfig>(nullptr);
  }

  TreeXHybridPartitioningConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TreeXHybridPartitioningConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TreeXHybridPartitioningConfig& from);
  void MergeFrom(const TreeXHybridPartitioningConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreeXHybridPartitioningConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.TreeXHybridPartitioningConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2fpartitioning_2eproto);
    return ::descriptor_table_scann_2fproto_2fpartitioning_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetsDirFieldNumber = 3,
    kTrainingReorderingFieldNumber = 4,
    kDatabaseTokenizationReorderingFieldNumber = 5,
    kQueryTokenizationReorderingFieldNumber = 6,
    kTopPartitioningChildrenFieldNumber = 1,
    kTopPartitionerUseFlumeTrainerFieldNumber = 9,
    kTopPartitionerSpillingRatioFieldNumber = 2,
    kTopPartitionerQueryTokenizationTypeFieldNumber = 7,
    kTopPartitionerDatabaseTokenizationTypeFieldNumber = 8,
    kTopPartitionerTrainingTokenizationTypeFieldNumber = 10,
  };
  // optional string assets_dir = 3;
  bool has_assets_dir() const;
  void clear_assets_dir();
  const std::string& assets_dir() const;
  void set_assets_dir(const std::string& value);
  void set_assets_dir(std::string&& value);
  void set_assets_dir(const char* value);
  void set_assets_dir(const char* value, size_t size);
  std::string* mutable_assets_dir();
  std::string* release_assets_dir();
  void set_allocated_assets_dir(std::string* assets_dir);

  // optional .research_scann.ExactReordering training_reordering = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_training_reordering() const;
  PROTOBUF_DEPRECATED void clear_training_reordering();
  PROTOBUF_DEPRECATED const ::research_scann::ExactReordering& training_reordering() const;
  PROTOBUF_DEPRECATED ::research_scann::ExactReordering* release_training_reordering();
  PROTOBUF_DEPRECATED ::research_scann::ExactReordering* mutable_training_reordering();
  PROTOBUF_DEPRECATED void set_allocated_training_reordering(::research_scann::ExactReordering* training_reordering);

  // optional .research_scann.ExactReordering database_tokenization_reordering = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_database_tokenization_reordering() const;
  PROTOBUF_DEPRECATED void clear_database_tokenization_reordering();
  PROTOBUF_DEPRECATED const ::research_scann::ExactReordering& database_tokenization_reordering() const;
  PROTOBUF_DEPRECATED ::research_scann::ExactReordering* release_database_tokenization_reordering();
  PROTOBUF_DEPRECATED ::research_scann::ExactReordering* mutable_database_tokenization_reordering();
  PROTOBUF_DEPRECATED void set_allocated_database_tokenization_reordering(::research_scann::ExactReordering* database_tokenization_reordering);

  // optional .research_scann.ExactReordering query_tokenization_reordering = 6;
  bool has_query_tokenization_reordering() const;
  void clear_query_tokenization_reordering();
  const ::research_scann::ExactReordering& query_tokenization_reordering() const;
  ::research_scann::ExactReordering* release_query_tokenization_reordering();
  ::research_scann::ExactReordering* mutable_query_tokenization_reordering();
  void set_allocated_query_tokenization_reordering(::research_scann::ExactReordering* query_tokenization_reordering);

  // optional uint32 top_partitioning_children = 1;
  bool has_top_partitioning_children() const;
  void clear_top_partitioning_children();
  ::PROTOBUF_NAMESPACE_ID::uint32 top_partitioning_children() const;
  void set_top_partitioning_children(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional bool top_partitioner_use_flume_trainer = 9 [default = false];
  bool has_top_partitioner_use_flume_trainer() const;
  void clear_top_partitioner_use_flume_trainer();
  bool top_partitioner_use_flume_trainer() const;
  void set_top_partitioner_use_flume_trainer(bool value);

  // optional float top_partitioner_spilling_ratio = 2 [default = 0.05];
  bool has_top_partitioner_spilling_ratio() const;
  void clear_top_partitioner_spilling_ratio();
  float top_partitioner_spilling_ratio() const;
  void set_top_partitioner_spilling_ratio(float value);

  // optional .research_scann.PartitioningConfig.TokenizationType top_partitioner_query_tokenization_type = 7 [default = FLOAT];
  bool has_top_partitioner_query_tokenization_type() const;
  void clear_top_partitioner_query_tokenization_type();
  ::research_scann::PartitioningConfig_TokenizationType top_partitioner_query_tokenization_type() const;
  void set_top_partitioner_query_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value);

  // optional .research_scann.PartitioningConfig.TokenizationType top_partitioner_database_tokenization_type = 8 [default = FLOAT];
  bool has_top_partitioner_database_tokenization_type() const;
  void clear_top_partitioner_database_tokenization_type();
  ::research_scann::PartitioningConfig_TokenizationType top_partitioner_database_tokenization_type() const;
  void set_top_partitioner_database_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value);

  // optional .research_scann.PartitioningConfig.TokenizationType top_partitioner_training_tokenization_type = 10 [default = FLOAT];
  bool has_top_partitioner_training_tokenization_type() const;
  void clear_top_partitioner_training_tokenization_type();
  ::research_scann::PartitioningConfig_TokenizationType top_partitioner_training_tokenization_type() const;
  void set_top_partitioner_training_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value);

  // @@protoc_insertion_point(class_scope:research_scann.TreeXHybridPartitioningConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assets_dir_;
  ::research_scann::ExactReordering* training_reordering_;
  ::research_scann::ExactReordering* database_tokenization_reordering_;
  ::research_scann::ExactReordering* query_tokenization_reordering_;
  ::PROTOBUF_NAMESPACE_ID::uint32 top_partitioning_children_;
  bool top_partitioner_use_flume_trainer_;
  float top_partitioner_spilling_ratio_;
  int top_partitioner_query_tokenization_type_;
  int top_partitioner_database_tokenization_type_;
  int top_partitioner_training_tokenization_type_;
  friend struct ::TableStruct_scann_2fproto_2fpartitioning_2eproto;
};
// -------------------------------------------------------------------

class TokenList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.TokenList) */ {
 public:
  TokenList();
  virtual ~TokenList();

  TokenList(const TokenList& from);
  TokenList(TokenList&& from) noexcept
    : TokenList() {
    *this = ::std::move(from);
  }

  inline TokenList& operator=(const TokenList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenList& operator=(TokenList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TokenList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TokenList* internal_default_instance() {
    return reinterpret_cast<const TokenList*>(
               &_TokenList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TokenList& a, TokenList& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenList* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TokenList* New() const final {
    return CreateMaybeMessage<TokenList>(nullptr);
  }

  TokenList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TokenList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TokenList& from);
  void MergeFrom(const TokenList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.TokenList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2fpartitioning_2eproto);
    return ::descriptor_table_scann_2fproto_2fpartitioning_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatapointIndexFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated int64 datapoint_index = 2;
  int datapoint_index_size() const;
  void clear_datapoint_index();
  ::PROTOBUF_NAMESPACE_ID::int64 datapoint_index(int index) const;
  void set_datapoint_index(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_datapoint_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      datapoint_index() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_datapoint_index();

  // optional uint64 id = 1;
  bool has_id() const;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:research_scann.TokenList)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > datapoint_index_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  friend struct ::TableStruct_scann_2fproto_2fpartitioning_2eproto;
};
// -------------------------------------------------------------------

class HierarchicalPartitionerConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:research_scann.HierarchicalPartitionerConfig) */ {
 public:
  HierarchicalPartitionerConfig();
  virtual ~HierarchicalPartitionerConfig();

  HierarchicalPartitionerConfig(const HierarchicalPartitionerConfig& from);
  HierarchicalPartitionerConfig(HierarchicalPartitionerConfig&& from) noexcept
    : HierarchicalPartitionerConfig() {
    *this = ::std::move(from);
  }

  inline HierarchicalPartitionerConfig& operator=(const HierarchicalPartitionerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline HierarchicalPartitionerConfig& operator=(HierarchicalPartitionerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HierarchicalPartitionerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HierarchicalPartitionerConfig* internal_default_instance() {
    return reinterpret_cast<const HierarchicalPartitionerConfig*>(
               &_HierarchicalPartitionerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HierarchicalPartitionerConfig& a, HierarchicalPartitionerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(HierarchicalPartitionerConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HierarchicalPartitionerConfig* New() const final {
    return CreateMaybeMessage<HierarchicalPartitionerConfig>(nullptr);
  }

  HierarchicalPartitionerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HierarchicalPartitionerConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HierarchicalPartitionerConfig& from);
  void MergeFrom(const HierarchicalPartitionerConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HierarchicalPartitionerConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "research_scann.HierarchicalPartitionerConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scann_2fproto_2fpartitioning_2eproto);
    return ::descriptor_table_scann_2fproto_2fpartitioning_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitioningFieldNumber = 2,
    kInputOutputFieldNumber = 1,
  };
  // repeated .research_scann.PartitioningConfig partitioning = 2;
  int partitioning_size() const;
  void clear_partitioning();
  ::research_scann::PartitioningConfig* mutable_partitioning(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::research_scann::PartitioningConfig >*
      mutable_partitioning();
  const ::research_scann::PartitioningConfig& partitioning(int index) const;
  ::research_scann::PartitioningConfig* add_partitioning();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::research_scann::PartitioningConfig >&
      partitioning() const;

  // optional .research_scann.InputOutputConfig input_output = 1;
  bool has_input_output() const;
  void clear_input_output();
  const ::research_scann::InputOutputConfig& input_output() const;
  ::research_scann::InputOutputConfig* release_input_output();
  ::research_scann::InputOutputConfig* mutable_input_output();
  void set_allocated_input_output(::research_scann::InputOutputConfig* input_output);

  // @@protoc_insertion_point(class_scope:research_scann.HierarchicalPartitionerConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::research_scann::PartitioningConfig > partitioning_;
  ::research_scann::InputOutputConfig* input_output_;
  friend struct ::TableStruct_scann_2fproto_2fpartitioning_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PartitioningConfig

// optional .research_scann.PartitioningConfig.TreeType tree_type = 31 [default = KMEANS_TREE];
inline bool PartitioningConfig::has_tree_type() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PartitioningConfig::clear_tree_type() {
  tree_type_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::research_scann::PartitioningConfig_TreeType PartitioningConfig::tree_type() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.tree_type)
  return static_cast< ::research_scann::PartitioningConfig_TreeType >(tree_type_);
}
inline void PartitioningConfig::set_tree_type(::research_scann::PartitioningConfig_TreeType value) {
  assert(::research_scann::PartitioningConfig_TreeType_IsValid(value));
  _has_bits_[0] |= 0x00004000u;
  tree_type_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.tree_type)
}

// optional .research_scann.TreeXHybridPartitioningConfig tree_x_hybrid = 46;
inline bool PartitioningConfig::has_tree_x_hybrid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PartitioningConfig::clear_tree_x_hybrid() {
  if (tree_x_hybrid_ != nullptr) tree_x_hybrid_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::research_scann::TreeXHybridPartitioningConfig& PartitioningConfig::tree_x_hybrid() const {
  const ::research_scann::TreeXHybridPartitioningConfig* p = tree_x_hybrid_;
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.tree_x_hybrid)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::TreeXHybridPartitioningConfig*>(
      &::research_scann::_TreeXHybridPartitioningConfig_default_instance_);
}
inline ::research_scann::TreeXHybridPartitioningConfig* PartitioningConfig::release_tree_x_hybrid() {
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.tree_x_hybrid)
  _has_bits_[0] &= ~0x00000800u;
  ::research_scann::TreeXHybridPartitioningConfig* temp = tree_x_hybrid_;
  tree_x_hybrid_ = nullptr;
  return temp;
}
inline ::research_scann::TreeXHybridPartitioningConfig* PartitioningConfig::mutable_tree_x_hybrid() {
  _has_bits_[0] |= 0x00000800u;
  if (tree_x_hybrid_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::TreeXHybridPartitioningConfig>(GetArenaNoVirtual());
    tree_x_hybrid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.tree_x_hybrid)
  return tree_x_hybrid_;
}
inline void PartitioningConfig::set_allocated_tree_x_hybrid(::research_scann::TreeXHybridPartitioningConfig* tree_x_hybrid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tree_x_hybrid_;
  }
  if (tree_x_hybrid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tree_x_hybrid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tree_x_hybrid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  tree_x_hybrid_ = tree_x_hybrid;
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.tree_x_hybrid)
}

// optional float partitioning_sampling_fraction = 4 [default = 1];
inline bool PartitioningConfig::has_partitioning_sampling_fraction() const {
  return SamplingFractionOrExpectedSize_case() == kPartitioningSamplingFraction;
}
inline void PartitioningConfig::set_has_partitioning_sampling_fraction() {
  _oneof_case_[0] = kPartitioningSamplingFraction;
}
inline void PartitioningConfig::clear_partitioning_sampling_fraction() {
  if (has_partitioning_sampling_fraction()) {
    SamplingFractionOrExpectedSize_.partitioning_sampling_fraction_ = 1;
    clear_has_SamplingFractionOrExpectedSize();
  }
}
inline float PartitioningConfig::partitioning_sampling_fraction() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.partitioning_sampling_fraction)
  if (has_partitioning_sampling_fraction()) {
    return SamplingFractionOrExpectedSize_.partitioning_sampling_fraction_;
  }
  return 1;
}
inline void PartitioningConfig::set_partitioning_sampling_fraction(float value) {
  if (!has_partitioning_sampling_fraction()) {
    clear_SamplingFractionOrExpectedSize();
    set_has_partitioning_sampling_fraction();
  }
  SamplingFractionOrExpectedSize_.partitioning_sampling_fraction_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.partitioning_sampling_fraction)
}

// optional int32 expected_sample_size = 45;
inline bool PartitioningConfig::has_expected_sample_size() const {
  return SamplingFractionOrExpectedSize_case() == kExpectedSampleSize;
}
inline void PartitioningConfig::set_has_expected_sample_size() {
  _oneof_case_[0] = kExpectedSampleSize;
}
inline void PartitioningConfig::clear_expected_sample_size() {
  if (has_expected_sample_size()) {
    SamplingFractionOrExpectedSize_.expected_sample_size_ = 0;
    clear_has_SamplingFractionOrExpectedSize();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::expected_sample_size() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.expected_sample_size)
  if (has_expected_sample_size()) {
    return SamplingFractionOrExpectedSize_.expected_sample_size_;
  }
  return 0;
}
inline void PartitioningConfig::set_expected_sample_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  if (!has_expected_sample_size()) {
    clear_SamplingFractionOrExpectedSize();
    set_has_expected_sample_size();
  }
  SamplingFractionOrExpectedSize_.expected_sample_size_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.expected_sample_size)
}

// optional string partitioner_prefix = 8;
inline bool PartitioningConfig::has_partitioner_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PartitioningConfig::clear_partitioner_prefix() {
  partitioner_prefix_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PartitioningConfig::partitioner_prefix() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.partitioner_prefix)
  return partitioner_prefix_.GetNoArena();
}
inline void PartitioningConfig::set_partitioner_prefix(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  partitioner_prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.partitioner_prefix)
}
inline void PartitioningConfig::set_partitioner_prefix(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  partitioner_prefix_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.PartitioningConfig.partitioner_prefix)
}
inline void PartitioningConfig::set_partitioner_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  partitioner_prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.PartitioningConfig.partitioner_prefix)
}
inline void PartitioningConfig::set_partitioner_prefix(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  partitioner_prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.PartitioningConfig.partitioner_prefix)
}
inline std::string* PartitioningConfig::mutable_partitioner_prefix() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.partitioner_prefix)
  return partitioner_prefix_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PartitioningConfig::release_partitioner_prefix() {
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.partitioner_prefix)
  if (!has_partitioner_prefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return partitioner_prefix_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PartitioningConfig::set_allocated_partitioner_prefix(std::string* partitioner_prefix) {
  if (partitioner_prefix != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  partitioner_prefix_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partitioner_prefix);
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.partitioner_prefix)
}

// optional int32 max_num_levels = 2 [default = 1];
inline bool PartitioningConfig::has_max_num_levels() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PartitioningConfig::clear_max_num_levels() {
  max_num_levels_ = 1;
  _has_bits_[0] &= ~0x02000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::max_num_levels() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.max_num_levels)
  return max_num_levels_;
}
inline void PartitioningConfig::set_max_num_levels(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x02000000u;
  max_num_levels_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.max_num_levels)
}

// optional int32 max_leaf_size = 11 [default = 1];
inline bool PartitioningConfig::has_max_leaf_size() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PartitioningConfig::clear_max_leaf_size() {
  max_leaf_size_ = 1;
  _has_bits_[0] &= ~0x40000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::max_leaf_size() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.max_leaf_size)
  return max_leaf_size_;
}
inline void PartitioningConfig::set_max_leaf_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x40000000u;
  max_leaf_size_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.max_leaf_size)
}

// optional int32 clustering_seed = 27 [default = 0];
inline bool PartitioningConfig::has_clustering_seed() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PartitioningConfig::clear_clustering_seed() {
  clustering_seed_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::clustering_seed() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.clustering_seed)
  return clustering_seed_;
}
inline void PartitioningConfig::set_clustering_seed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00002000u;
  clustering_seed_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.clustering_seed)
}

// optional .research_scann.ProjectionConfig projection = 12;
inline bool PartitioningConfig::has_projection() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline const ::research_scann::ProjectionConfig& PartitioningConfig::projection() const {
  const ::research_scann::ProjectionConfig* p = projection_;
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.projection)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::ProjectionConfig*>(
      &::research_scann::_ProjectionConfig_default_instance_);
}
inline ::research_scann::ProjectionConfig* PartitioningConfig::release_projection() {
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.projection)
  _has_bits_[0] &= ~0x00000040u;
  ::research_scann::ProjectionConfig* temp = projection_;
  projection_ = nullptr;
  return temp;
}
inline ::research_scann::ProjectionConfig* PartitioningConfig::mutable_projection() {
  _has_bits_[0] |= 0x00000040u;
  if (projection_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::ProjectionConfig>(GetArenaNoVirtual());
    projection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.projection)
  return projection_;
}
inline void PartitioningConfig::set_allocated_projection(::research_scann::ProjectionConfig* projection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(projection_);
  }
  if (projection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      projection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, projection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  projection_ = projection;
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.projection)
}

// optional int32 num_children = 3 [default = 2];
inline bool PartitioningConfig::has_num_children() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PartitioningConfig::clear_num_children() {
  num_children_ = 2;
  _has_bits_[0] &= ~0x04000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::num_children() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.num_children)
  return num_children_;
}
inline void PartitioningConfig::set_num_children(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x04000000u;
  num_children_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.num_children)
}

// optional .research_scann.DistanceMeasureConfig partitioning_distance = 10;
inline bool PartitioningConfig::has_partitioning_distance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline const ::research_scann::DistanceMeasureConfig& PartitioningConfig::partitioning_distance() const {
  const ::research_scann::DistanceMeasureConfig* p = partitioning_distance_;
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.partitioning_distance)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::DistanceMeasureConfig*>(
      &::research_scann::_DistanceMeasureConfig_default_instance_);
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::release_partitioning_distance() {
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.partitioning_distance)
  _has_bits_[0] &= ~0x00000020u;
  ::research_scann::DistanceMeasureConfig* temp = partitioning_distance_;
  partitioning_distance_ = nullptr;
  return temp;
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::mutable_partitioning_distance() {
  _has_bits_[0] |= 0x00000020u;
  if (partitioning_distance_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::DistanceMeasureConfig>(GetArenaNoVirtual());
    partitioning_distance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.partitioning_distance)
  return partitioning_distance_;
}
inline void PartitioningConfig::set_allocated_partitioning_distance(::research_scann::DistanceMeasureConfig* partitioning_distance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(partitioning_distance_);
  }
  if (partitioning_distance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      partitioning_distance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partitioning_distance, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  partitioning_distance_ = partitioning_distance;
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.partitioning_distance)
}

// optional .research_scann.DistanceMeasureConfig database_tokenization_distance_override = 24;
inline bool PartitioningConfig::has_database_tokenization_distance_override() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline const ::research_scann::DistanceMeasureConfig& PartitioningConfig::database_tokenization_distance_override() const {
  const ::research_scann::DistanceMeasureConfig* p = database_tokenization_distance_override_;
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.database_tokenization_distance_override)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::DistanceMeasureConfig*>(
      &::research_scann::_DistanceMeasureConfig_default_instance_);
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::release_database_tokenization_distance_override() {
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.database_tokenization_distance_override)
  _has_bits_[0] &= ~0x00000200u;
  ::research_scann::DistanceMeasureConfig* temp = database_tokenization_distance_override_;
  database_tokenization_distance_override_ = nullptr;
  return temp;
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::mutable_database_tokenization_distance_override() {
  _has_bits_[0] |= 0x00000200u;
  if (database_tokenization_distance_override_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::DistanceMeasureConfig>(GetArenaNoVirtual());
    database_tokenization_distance_override_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.database_tokenization_distance_override)
  return database_tokenization_distance_override_;
}
inline void PartitioningConfig::set_allocated_database_tokenization_distance_override(::research_scann::DistanceMeasureConfig* database_tokenization_distance_override) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_tokenization_distance_override_);
  }
  if (database_tokenization_distance_override) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      database_tokenization_distance_override = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_tokenization_distance_override, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  database_tokenization_distance_override_ = database_tokenization_distance_override;
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.database_tokenization_distance_override)
}

// optional .research_scann.DistanceMeasureConfig query_tokenization_distance_override = 25;
inline bool PartitioningConfig::has_query_tokenization_distance_override() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline const ::research_scann::DistanceMeasureConfig& PartitioningConfig::query_tokenization_distance_override() const {
  const ::research_scann::DistanceMeasureConfig* p = query_tokenization_distance_override_;
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.query_tokenization_distance_override)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::DistanceMeasureConfig*>(
      &::research_scann::_DistanceMeasureConfig_default_instance_);
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::release_query_tokenization_distance_override() {
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.query_tokenization_distance_override)
  _has_bits_[0] &= ~0x00000400u;
  ::research_scann::DistanceMeasureConfig* temp = query_tokenization_distance_override_;
  query_tokenization_distance_override_ = nullptr;
  return temp;
}
inline ::research_scann::DistanceMeasureConfig* PartitioningConfig::mutable_query_tokenization_distance_override() {
  _has_bits_[0] |= 0x00000400u;
  if (query_tokenization_distance_override_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::DistanceMeasureConfig>(GetArenaNoVirtual());
    query_tokenization_distance_override_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.query_tokenization_distance_override)
  return query_tokenization_distance_override_;
}
inline void PartitioningConfig::set_allocated_query_tokenization_distance_override(::research_scann::DistanceMeasureConfig* query_tokenization_distance_override) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(query_tokenization_distance_override_);
  }
  if (query_tokenization_distance_override) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      query_tokenization_distance_override = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_tokenization_distance_override, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  query_tokenization_distance_override_ = query_tokenization_distance_override;
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.query_tokenization_distance_override)
}

// optional .research_scann.PartitioningConfig.TokenizationType query_tokenization_type = 28 [default = FLOAT];
inline bool PartitioningConfig::has_query_tokenization_type() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void PartitioningConfig::clear_query_tokenization_type() {
  query_tokenization_type_ = 1;
  _has_bits_[1] &= ~0x00000004u;
}
inline ::research_scann::PartitioningConfig_TokenizationType PartitioningConfig::query_tokenization_type() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.query_tokenization_type)
  return static_cast< ::research_scann::PartitioningConfig_TokenizationType >(query_tokenization_type_);
}
inline void PartitioningConfig::set_query_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value) {
  assert(::research_scann::PartitioningConfig_TokenizationType_IsValid(value));
  _has_bits_[1] |= 0x00000004u;
  query_tokenization_type_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.query_tokenization_type)
}

// optional .research_scann.PartitioningConfig.TokenizationType database_tokenization_type = 29 [default = FLOAT];
inline bool PartitioningConfig::has_database_tokenization_type() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void PartitioningConfig::clear_database_tokenization_type() {
  database_tokenization_type_ = 1;
  _has_bits_[1] &= ~0x00000008u;
}
inline ::research_scann::PartitioningConfig_TokenizationType PartitioningConfig::database_tokenization_type() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.database_tokenization_type)
  return static_cast< ::research_scann::PartitioningConfig_TokenizationType >(database_tokenization_type_);
}
inline void PartitioningConfig::set_database_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value) {
  assert(::research_scann::PartitioningConfig_TokenizationType_IsValid(value));
  _has_bits_[1] |= 0x00000008u;
  database_tokenization_type_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.database_tokenization_type)
}

// optional int32 max_clustering_iterations = 6 [default = 10];
inline bool PartitioningConfig::has_max_clustering_iterations() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PartitioningConfig::clear_max_clustering_iterations() {
  max_clustering_iterations_ = 10;
  _has_bits_[0] &= ~0x08000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::max_clustering_iterations() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.max_clustering_iterations)
  return max_clustering_iterations_;
}
inline void PartitioningConfig::set_max_clustering_iterations(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x08000000u;
  max_clustering_iterations_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.max_clustering_iterations)
}

// optional int32 num_mini_batches = 38 [default = 1];
inline bool PartitioningConfig::has_num_mini_batches() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void PartitioningConfig::clear_num_mini_batches() {
  num_mini_batches_ = 1;
  _has_bits_[1] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::num_mini_batches() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.num_mini_batches)
  return num_mini_batches_;
}
inline void PartitioningConfig::set_num_mini_batches(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00000080u;
  num_mini_batches_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.num_mini_batches)
}

// optional float clustering_convergence_tolerance = 7 [default = 1e-05];
inline bool PartitioningConfig::has_clustering_convergence_tolerance() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PartitioningConfig::clear_clustering_convergence_tolerance() {
  clustering_convergence_tolerance_ = 1e-05f;
  _has_bits_[0] &= ~0x10000000u;
}
inline float PartitioningConfig::clustering_convergence_tolerance() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.clustering_convergence_tolerance)
  return clustering_convergence_tolerance_;
}
inline void PartitioningConfig::set_clustering_convergence_tolerance(float value) {
  _has_bits_[0] |= 0x10000000u;
  clustering_convergence_tolerance_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.clustering_convergence_tolerance)
}

// optional float min_cluster_size = 9 [default = 1];
inline bool PartitioningConfig::has_min_cluster_size() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PartitioningConfig::clear_min_cluster_size() {
  min_cluster_size_ = 1;
  _has_bits_[0] &= ~0x20000000u;
}
inline float PartitioningConfig::min_cluster_size() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.min_cluster_size)
  return min_cluster_size_;
}
inline void PartitioningConfig::set_min_cluster_size(float value) {
  _has_bits_[0] |= 0x20000000u;
  min_cluster_size_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.min_cluster_size)
}

// optional int32 max_cluster_size = 40;
inline bool PartitioningConfig::has_max_cluster_size() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PartitioningConfig::clear_max_cluster_size() {
  max_cluster_size_ = 0;
  _has_bits_[0] &= ~0x00400000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::max_cluster_size() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.max_cluster_size)
  return max_cluster_size_;
}
inline void PartitioningConfig::set_max_cluster_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00400000u;
  max_cluster_size_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.max_cluster_size)
}

// optional double perturbation = 41;
inline bool PartitioningConfig::has_perturbation() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PartitioningConfig::clear_perturbation() {
  perturbation_ = 0;
  _has_bits_[0] &= ~0x00200000u;
}
inline double PartitioningConfig::perturbation() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.perturbation)
  return perturbation_;
}
inline void PartitioningConfig::set_perturbation(double value) {
  _has_bits_[0] |= 0x00200000u;
  perturbation_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.perturbation)
}

// optional .research_scann.PartitioningConfig.PartitioningType partitioning_type = 23 [default = GENERIC];
inline bool PartitioningConfig::has_partitioning_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PartitioningConfig::clear_partitioning_type() {
  partitioning_type_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::research_scann::PartitioningConfig_PartitioningType PartitioningConfig::partitioning_type() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.partitioning_type)
  return static_cast< ::research_scann::PartitioningConfig_PartitioningType >(partitioning_type_);
}
inline void PartitioningConfig::set_partitioning_type(::research_scann::PartitioningConfig_PartitioningType value) {
  assert(::research_scann::PartitioningConfig_PartitioningType_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  partitioning_type_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.partitioning_type)
}

// optional .research_scann.PartitioningConfig.BalancingType balancing_type = 35 [default = DEFAULT_UNBALANCED];
inline bool PartitioningConfig::has_balancing_type() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PartitioningConfig::clear_balancing_type() {
  balancing_type_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline ::research_scann::PartitioningConfig_BalancingType PartitioningConfig::balancing_type() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.balancing_type)
  return static_cast< ::research_scann::PartitioningConfig_BalancingType >(balancing_type_);
}
inline void PartitioningConfig::set_balancing_type(::research_scann::PartitioningConfig_BalancingType value) {
  assert(::research_scann::PartitioningConfig_BalancingType_IsValid(value));
  _has_bits_[0] |= 0x00080000u;
  balancing_type_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.balancing_type)
}

// optional .research_scann.PartitioningConfig.SingleMachineCenterInitializationType single_machine_center_initialization = 49 [default = DEFAULT_KMEANS_PLUS_PLUS];
inline bool PartitioningConfig::has_single_machine_center_initialization() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PartitioningConfig::clear_single_machine_center_initialization() {
  single_machine_center_initialization_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline ::research_scann::PartitioningConfig_SingleMachineCenterInitializationType PartitioningConfig::single_machine_center_initialization() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.single_machine_center_initialization)
  return static_cast< ::research_scann::PartitioningConfig_SingleMachineCenterInitializationType >(single_machine_center_initialization_);
}
inline void PartitioningConfig::set_single_machine_center_initialization(::research_scann::PartitioningConfig_SingleMachineCenterInitializationType value) {
  assert(::research_scann::PartitioningConfig_SingleMachineCenterInitializationType_IsValid(value));
  _has_bits_[0] |= 0x00800000u;
  single_machine_center_initialization_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.single_machine_center_initialization)
}

// optional .research_scann.DatabaseSpillingConfig database_spilling = 20;
inline bool PartitioningConfig::has_database_spilling() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PartitioningConfig::clear_database_spilling() {
  if (database_spilling_ != nullptr) database_spilling_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::research_scann::DatabaseSpillingConfig& PartitioningConfig::database_spilling() const {
  const ::research_scann::DatabaseSpillingConfig* p = database_spilling_;
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.database_spilling)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::DatabaseSpillingConfig*>(
      &::research_scann::_DatabaseSpillingConfig_default_instance_);
}
inline ::research_scann::DatabaseSpillingConfig* PartitioningConfig::release_database_spilling() {
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.database_spilling)
  _has_bits_[0] &= ~0x00000080u;
  ::research_scann::DatabaseSpillingConfig* temp = database_spilling_;
  database_spilling_ = nullptr;
  return temp;
}
inline ::research_scann::DatabaseSpillingConfig* PartitioningConfig::mutable_database_spilling() {
  _has_bits_[0] |= 0x00000080u;
  if (database_spilling_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::DatabaseSpillingConfig>(GetArenaNoVirtual());
    database_spilling_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.database_spilling)
  return database_spilling_;
}
inline void PartitioningConfig::set_allocated_database_spilling(::research_scann::DatabaseSpillingConfig* database_spilling) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete database_spilling_;
  }
  if (database_spilling) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      database_spilling = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_spilling, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  database_spilling_ = database_spilling;
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.database_spilling)
}

// optional .research_scann.QuerySpillingConfig query_spilling = 21;
inline bool PartitioningConfig::has_query_spilling() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PartitioningConfig::clear_query_spilling() {
  if (query_spilling_ != nullptr) query_spilling_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::research_scann::QuerySpillingConfig& PartitioningConfig::query_spilling() const {
  const ::research_scann::QuerySpillingConfig* p = query_spilling_;
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.query_spilling)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::QuerySpillingConfig*>(
      &::research_scann::_QuerySpillingConfig_default_instance_);
}
inline ::research_scann::QuerySpillingConfig* PartitioningConfig::release_query_spilling() {
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.query_spilling)
  _has_bits_[0] &= ~0x00000100u;
  ::research_scann::QuerySpillingConfig* temp = query_spilling_;
  query_spilling_ = nullptr;
  return temp;
}
inline ::research_scann::QuerySpillingConfig* PartitioningConfig::mutable_query_spilling() {
  _has_bits_[0] |= 0x00000100u;
  if (query_spilling_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::QuerySpillingConfig>(GetArenaNoVirtual());
    query_spilling_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.query_spilling)
  return query_spilling_;
}
inline void PartitioningConfig::set_allocated_query_spilling(::research_scann::QuerySpillingConfig* query_spilling) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete query_spilling_;
  }
  if (query_spilling) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      query_spilling = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_spilling, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  query_spilling_ = query_spilling;
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.query_spilling)
}

// optional string resharded_prefix = 14;
inline bool PartitioningConfig::has_resharded_prefix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PartitioningConfig::clear_resharded_prefix() {
  resharded_prefix_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PartitioningConfig::resharded_prefix() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.resharded_prefix)
  return resharded_prefix_.GetNoArena();
}
inline void PartitioningConfig::set_resharded_prefix(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  resharded_prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.resharded_prefix)
}
inline void PartitioningConfig::set_resharded_prefix(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  resharded_prefix_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.PartitioningConfig.resharded_prefix)
}
inline void PartitioningConfig::set_resharded_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  resharded_prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.PartitioningConfig.resharded_prefix)
}
inline void PartitioningConfig::set_resharded_prefix(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  resharded_prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.PartitioningConfig.resharded_prefix)
}
inline std::string* PartitioningConfig::mutable_resharded_prefix() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.resharded_prefix)
  return resharded_prefix_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PartitioningConfig::release_resharded_prefix() {
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.resharded_prefix)
  if (!has_resharded_prefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return resharded_prefix_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PartitioningConfig::set_allocated_resharded_prefix(std::string* resharded_prefix) {
  if (resharded_prefix != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  resharded_prefix_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resharded_prefix);
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.resharded_prefix)
}

// optional int32 num_partitioning_epochs = 1 [default = 1];
inline bool PartitioningConfig::has_num_partitioning_epochs() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PartitioningConfig::clear_num_partitioning_epochs() {
  num_partitioning_epochs_ = 1;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::num_partitioning_epochs() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.num_partitioning_epochs)
  return num_partitioning_epochs_;
}
inline void PartitioningConfig::set_num_partitioning_epochs(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x01000000u;
  num_partitioning_epochs_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.num_partitioning_epochs)
}

// optional string mr_jobname_prefix = 13 [default = "PartitionReshard"];
inline bool PartitioningConfig::has_mr_jobname_prefix() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PartitioningConfig::clear_mr_jobname_prefix() {
  mr_jobname_prefix_.ClearToDefaultNoArena(&::research_scann::PartitioningConfig::_i_give_permission_to_break_this_code_default_mr_jobname_prefix_.get());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PartitioningConfig::mr_jobname_prefix() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.mr_jobname_prefix)
  return mr_jobname_prefix_.GetNoArena();
}
inline void PartitioningConfig::set_mr_jobname_prefix(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  mr_jobname_prefix_.SetNoArena(&::research_scann::PartitioningConfig::_i_give_permission_to_break_this_code_default_mr_jobname_prefix_.get(), value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.mr_jobname_prefix)
}
inline void PartitioningConfig::set_mr_jobname_prefix(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  mr_jobname_prefix_.SetNoArena(
    &::research_scann::PartitioningConfig::_i_give_permission_to_break_this_code_default_mr_jobname_prefix_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.PartitioningConfig.mr_jobname_prefix)
}
inline void PartitioningConfig::set_mr_jobname_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  mr_jobname_prefix_.SetNoArena(&::research_scann::PartitioningConfig::_i_give_permission_to_break_this_code_default_mr_jobname_prefix_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.PartitioningConfig.mr_jobname_prefix)
}
inline void PartitioningConfig::set_mr_jobname_prefix(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  mr_jobname_prefix_.SetNoArena(&::research_scann::PartitioningConfig::_i_give_permission_to_break_this_code_default_mr_jobname_prefix_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.PartitioningConfig.mr_jobname_prefix)
}
inline std::string* PartitioningConfig::mutable_mr_jobname_prefix() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.mr_jobname_prefix)
  return mr_jobname_prefix_.MutableNoArena(&::research_scann::PartitioningConfig::_i_give_permission_to_break_this_code_default_mr_jobname_prefix_.get());
}
inline std::string* PartitioningConfig::release_mr_jobname_prefix() {
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.mr_jobname_prefix)
  if (!has_mr_jobname_prefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return mr_jobname_prefix_.ReleaseNonDefaultNoArena(&::research_scann::PartitioningConfig::_i_give_permission_to_break_this_code_default_mr_jobname_prefix_.get());
}
inline void PartitioningConfig::set_allocated_mr_jobname_prefix(std::string* mr_jobname_prefix) {
  if (mr_jobname_prefix != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mr_jobname_prefix_.SetAllocatedNoArena(&::research_scann::PartitioningConfig::_i_give_permission_to_break_this_code_default_mr_jobname_prefix_.get(), mr_jobname_prefix);
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.mr_jobname_prefix)
}

// optional string cell = 15;
inline bool PartitioningConfig::has_cell() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PartitioningConfig::clear_cell() {
  cell_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PartitioningConfig::cell() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.cell)
  return cell_.GetNoArena();
}
inline void PartitioningConfig::set_cell(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  cell_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.cell)
}
inline void PartitioningConfig::set_cell(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  cell_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.PartitioningConfig.cell)
}
inline void PartitioningConfig::set_cell(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  cell_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.PartitioningConfig.cell)
}
inline void PartitioningConfig::set_cell(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  cell_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.PartitioningConfig.cell)
}
inline std::string* PartitioningConfig::mutable_cell() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.cell)
  return cell_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PartitioningConfig::release_cell() {
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.cell)
  if (!has_cell()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return cell_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PartitioningConfig::set_allocated_cell(std::string* cell) {
  if (cell != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  cell_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cell);
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.cell)
}

// optional int32 num_cpus = 19 [default = 1];
inline bool PartitioningConfig::has_num_cpus() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PartitioningConfig::clear_num_cpus() {
  num_cpus_ = 1;
  _has_bits_[1] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::num_cpus() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.num_cpus)
  return num_cpus_;
}
inline void PartitioningConfig::set_num_cpus(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00000002u;
  num_cpus_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.num_cpus)
}

// optional int32 num_mapper_machines = 30 [default = -1];
inline bool PartitioningConfig::has_num_mapper_machines() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void PartitioningConfig::clear_num_mapper_machines() {
  num_mapper_machines_ = -1;
  _has_bits_[1] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::num_mapper_machines() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.num_mapper_machines)
  return num_mapper_machines_;
}
inline void PartitioningConfig::set_num_mapper_machines(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00000010u;
  num_mapper_machines_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.num_mapper_machines)
}

// optional int32 ram_gb = 16 [default = 4];
inline bool PartitioningConfig::has_ram_gb() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PartitioningConfig::clear_ram_gb() {
  ram_gb_ = 4;
  _has_bits_[0] &= ~0x80000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::ram_gb() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.ram_gb)
  return ram_gb_;
}
inline void PartitioningConfig::set_ram_gb(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x80000000u;
  ram_gb_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.ram_gb)
}

// optional int32 disk_gb = 17 [default = 1];
inline bool PartitioningConfig::has_disk_gb() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PartitioningConfig::clear_disk_gb() {
  disk_gb_ = 1;
  _has_bits_[1] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::disk_gb() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.disk_gb)
  return disk_gb_;
}
inline void PartitioningConfig::set_disk_gb(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00000001u;
  disk_gb_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.disk_gb)
}

// optional .research_scann.PartitioningConfig.PartitionerTrainerType trainer_type = 36 [default = DEFAULT_SAMPLING_TRAINER];
inline bool PartitioningConfig::has_trainer_type() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PartitioningConfig::clear_trainer_type() {
  trainer_type_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::research_scann::PartitioningConfig_PartitionerTrainerType PartitioningConfig::trainer_type() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.trainer_type)
  return static_cast< ::research_scann::PartitioningConfig_PartitionerTrainerType >(trainer_type_);
}
inline void PartitioningConfig::set_trainer_type(::research_scann::PartitioningConfig_PartitionerTrainerType value) {
  assert(::research_scann::PartitioningConfig_PartitionerTrainerType_IsValid(value));
  _has_bits_[0] |= 0x00100000u;
  trainer_type_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.trainer_type)
}

// optional string trainer_stats_prefix = 37;
inline bool PartitioningConfig::has_trainer_stats_prefix() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PartitioningConfig::clear_trainer_stats_prefix() {
  trainer_stats_prefix_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PartitioningConfig::trainer_stats_prefix() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.trainer_stats_prefix)
  return trainer_stats_prefix_.GetNoArena();
}
inline void PartitioningConfig::set_trainer_stats_prefix(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  trainer_stats_prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.trainer_stats_prefix)
}
inline void PartitioningConfig::set_trainer_stats_prefix(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  trainer_stats_prefix_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.PartitioningConfig.trainer_stats_prefix)
}
inline void PartitioningConfig::set_trainer_stats_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  trainer_stats_prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.PartitioningConfig.trainer_stats_prefix)
}
inline void PartitioningConfig::set_trainer_stats_prefix(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  trainer_stats_prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.PartitioningConfig.trainer_stats_prefix)
}
inline std::string* PartitioningConfig::mutable_trainer_stats_prefix() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:research_scann.PartitioningConfig.trainer_stats_prefix)
  return trainer_stats_prefix_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PartitioningConfig::release_trainer_stats_prefix() {
  // @@protoc_insertion_point(field_release:research_scann.PartitioningConfig.trainer_stats_prefix)
  if (!has_trainer_stats_prefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return trainer_stats_prefix_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PartitioningConfig::set_allocated_trainer_stats_prefix(std::string* trainer_stats_prefix) {
  if (trainer_stats_prefix != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  trainer_stats_prefix_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trainer_stats_prefix);
  // @@protoc_insertion_point(field_set_allocated:research_scann.PartitioningConfig.trainer_stats_prefix)
}

// optional int32 max_power_of_2_split = 39 [default = 2];
inline bool PartitioningConfig::has_max_power_of_2_split() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void PartitioningConfig::clear_max_power_of_2_split() {
  max_power_of_2_split_ = 2;
  _has_bits_[1] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::max_power_of_2_split() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.max_power_of_2_split)
  return max_power_of_2_split_;
}
inline void PartitioningConfig::set_max_power_of_2_split(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00000100u;
  max_power_of_2_split_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.max_power_of_2_split)
}

// optional int32 num_top_tokens_for_pca = 42 [default = 20];
inline bool PartitioningConfig::has_num_top_tokens_for_pca() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void PartitioningConfig::clear_num_top_tokens_for_pca() {
  num_top_tokens_for_pca_ = 20;
  _has_bits_[1] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::num_top_tokens_for_pca() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.num_top_tokens_for_pca)
  return num_top_tokens_for_pca_;
}
inline void PartitioningConfig::set_num_top_tokens_for_pca(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00000200u;
  num_top_tokens_for_pca_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.num_top_tokens_for_pca)
}

// optional float pca_splitting_similarity_threshold = 43 [default = 1e-05];
inline bool PartitioningConfig::has_pca_splitting_similarity_threshold() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void PartitioningConfig::clear_pca_splitting_similarity_threshold() {
  pca_splitting_similarity_threshold_ = 1e-05f;
  _has_bits_[1] &= ~0x00000400u;
}
inline float PartitioningConfig::pca_splitting_similarity_threshold() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.pca_splitting_similarity_threshold)
  return pca_splitting_similarity_threshold_;
}
inline void PartitioningConfig::set_pca_splitting_similarity_threshold(float value) {
  _has_bits_[1] |= 0x00000400u;
  pca_splitting_similarity_threshold_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.pca_splitting_similarity_threshold)
}

// optional int32 desired_average_cluster_size = 34 [default = 3000];
inline bool PartitioningConfig::has_desired_average_cluster_size() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void PartitioningConfig::clear_desired_average_cluster_size() {
  desired_average_cluster_size_ = 3000;
  _has_bits_[1] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::desired_average_cluster_size() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.desired_average_cluster_size)
  return desired_average_cluster_size_;
}
inline void PartitioningConfig::set_desired_average_cluster_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00000040u;
  desired_average_cluster_size_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.desired_average_cluster_size)
}

// optional bool compute_residual_stdev = 47 [default = false];
inline bool PartitioningConfig::has_compute_residual_stdev() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PartitioningConfig::clear_compute_residual_stdev() {
  compute_residual_stdev_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool PartitioningConfig::compute_residual_stdev() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.compute_residual_stdev)
  return compute_residual_stdev_;
}
inline void PartitioningConfig::set_compute_residual_stdev(bool value) {
  _has_bits_[0] |= 0x00008000u;
  compute_residual_stdev_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.compute_residual_stdev)
}

// optional double residual_stdev_min_value = 48 [default = 1e-05];
inline bool PartitioningConfig::has_residual_stdev_min_value() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void PartitioningConfig::clear_residual_stdev_min_value() {
  residual_stdev_min_value_ = 1e-05;
  _has_bits_[1] &= ~0x00001000u;
}
inline double PartitioningConfig::residual_stdev_min_value() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.residual_stdev_min_value)
  return residual_stdev_min_value_;
}
inline void PartitioningConfig::set_residual_stdev_min_value(double value) {
  _has_bits_[1] |= 0x00001000u;
  residual_stdev_min_value_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.residual_stdev_min_value)
}

// optional float avq = 51 [default = nan];
inline bool PartitioningConfig::has_avq() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void PartitioningConfig::clear_avq() {
  avq_ = std::numeric_limits<float>::quiet_NaN();
  _has_bits_[1] &= ~0x00000800u;
}
inline float PartitioningConfig::avq() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.avq)
  return avq_;
}
inline void PartitioningConfig::set_avq(float value) {
  _has_bits_[1] |= 0x00000800u;
  avq_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.avq)
}

// optional bool use_float_centers_for_query_tokenization = 26 [default = false, deprecated = true];
inline bool PartitioningConfig::has_use_float_centers_for_query_tokenization() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PartitioningConfig::clear_use_float_centers_for_query_tokenization() {
  use_float_centers_for_query_tokenization_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool PartitioningConfig::use_float_centers_for_query_tokenization() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.use_float_centers_for_query_tokenization)
  return use_float_centers_for_query_tokenization_;
}
inline void PartitioningConfig::set_use_float_centers_for_query_tokenization(bool value) {
  _has_bits_[0] |= 0x00010000u;
  use_float_centers_for_query_tokenization_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.use_float_centers_for_query_tokenization)
}

// optional bool partitioning_on_the_fly = 22 [default = false, deprecated = true];
inline bool PartitioningConfig::has_partitioning_on_the_fly() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PartitioningConfig::clear_partitioning_on_the_fly() {
  partitioning_on_the_fly_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool PartitioningConfig::partitioning_on_the_fly() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.partitioning_on_the_fly)
  return partitioning_on_the_fly_;
}
inline void PartitioningConfig::set_partitioning_on_the_fly(bool value) {
  _has_bits_[0] |= 0x00020000u;
  partitioning_on_the_fly_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.partitioning_on_the_fly)
}

// optional bool use_flume_kmeans = 32 [default = false, deprecated = true];
inline bool PartitioningConfig::has_use_flume_kmeans() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PartitioningConfig::clear_use_flume_kmeans() {
  use_flume_kmeans_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool PartitioningConfig::use_flume_kmeans() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.use_flume_kmeans)
  return use_flume_kmeans_;
}
inline void PartitioningConfig::set_use_flume_kmeans(bool value) {
  _has_bits_[0] |= 0x00040000u;
  use_flume_kmeans_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.use_flume_kmeans)
}

// optional int32 max_sample_size = 33 [default = 2147483647, deprecated = true];
inline bool PartitioningConfig::has_max_sample_size() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void PartitioningConfig::clear_max_sample_size() {
  max_sample_size_ = 2147483647;
  _has_bits_[1] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitioningConfig::max_sample_size() const {
  // @@protoc_insertion_point(field_get:research_scann.PartitioningConfig.max_sample_size)
  return max_sample_size_;
}
inline void PartitioningConfig::set_max_sample_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00000020u;
  max_sample_size_ = value;
  // @@protoc_insertion_point(field_set:research_scann.PartitioningConfig.max_sample_size)
}

inline bool PartitioningConfig::has_SamplingFractionOrExpectedSize() const {
  return SamplingFractionOrExpectedSize_case() != SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET;
}
inline void PartitioningConfig::clear_has_SamplingFractionOrExpectedSize() {
  _oneof_case_[0] = SAMPLINGFRACTIONOREXPECTEDSIZE_NOT_SET;
}
inline PartitioningConfig::SamplingFractionOrExpectedSizeCase PartitioningConfig::SamplingFractionOrExpectedSize_case() const {
  return PartitioningConfig::SamplingFractionOrExpectedSizeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DatabaseSpillingConfig

// optional .research_scann.DatabaseSpillingConfig.SpillingType spilling_type = 1 [default = NO_SPILLING];
inline bool DatabaseSpillingConfig::has_spilling_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatabaseSpillingConfig::clear_spilling_type() {
  spilling_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::research_scann::DatabaseSpillingConfig_SpillingType DatabaseSpillingConfig::spilling_type() const {
  // @@protoc_insertion_point(field_get:research_scann.DatabaseSpillingConfig.spilling_type)
  return static_cast< ::research_scann::DatabaseSpillingConfig_SpillingType >(spilling_type_);
}
inline void DatabaseSpillingConfig::set_spilling_type(::research_scann::DatabaseSpillingConfig_SpillingType value) {
  assert(::research_scann::DatabaseSpillingConfig_SpillingType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  spilling_type_ = value;
  // @@protoc_insertion_point(field_set:research_scann.DatabaseSpillingConfig.spilling_type)
}

// optional float replication_factor = 2;
inline bool DatabaseSpillingConfig::has_replication_factor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatabaseSpillingConfig::clear_replication_factor() {
  replication_factor_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float DatabaseSpillingConfig::replication_factor() const {
  // @@protoc_insertion_point(field_get:research_scann.DatabaseSpillingConfig.replication_factor)
  return replication_factor_;
}
inline void DatabaseSpillingConfig::set_replication_factor(float value) {
  _has_bits_[0] |= 0x00000002u;
  replication_factor_ = value;
  // @@protoc_insertion_point(field_set:research_scann.DatabaseSpillingConfig.replication_factor)
}

// optional uint32 max_spill_centers = 3 [default = 4294967295];
inline bool DatabaseSpillingConfig::has_max_spill_centers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DatabaseSpillingConfig::clear_max_spill_centers() {
  max_spill_centers_ = 4294967295u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DatabaseSpillingConfig::max_spill_centers() const {
  // @@protoc_insertion_point(field_get:research_scann.DatabaseSpillingConfig.max_spill_centers)
  return max_spill_centers_;
}
inline void DatabaseSpillingConfig::set_max_spill_centers(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  max_spill_centers_ = value;
  // @@protoc_insertion_point(field_set:research_scann.DatabaseSpillingConfig.max_spill_centers)
}

// -------------------------------------------------------------------

// QuerySpillingConfig

// optional .research_scann.QuerySpillingConfig.SpillingType spilling_type = 1 [default = NO_SPILLING];
inline bool QuerySpillingConfig::has_spilling_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuerySpillingConfig::clear_spilling_type() {
  spilling_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::research_scann::QuerySpillingConfig_SpillingType QuerySpillingConfig::spilling_type() const {
  // @@protoc_insertion_point(field_get:research_scann.QuerySpillingConfig.spilling_type)
  return static_cast< ::research_scann::QuerySpillingConfig_SpillingType >(spilling_type_);
}
inline void QuerySpillingConfig::set_spilling_type(::research_scann::QuerySpillingConfig_SpillingType value) {
  assert(::research_scann::QuerySpillingConfig_SpillingType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  spilling_type_ = value;
  // @@protoc_insertion_point(field_set:research_scann.QuerySpillingConfig.spilling_type)
}

// optional float spilling_threshold = 2;
inline bool QuerySpillingConfig::has_spilling_threshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuerySpillingConfig::clear_spilling_threshold() {
  spilling_threshold_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float QuerySpillingConfig::spilling_threshold() const {
  // @@protoc_insertion_point(field_get:research_scann.QuerySpillingConfig.spilling_threshold)
  return spilling_threshold_;
}
inline void QuerySpillingConfig::set_spilling_threshold(float value) {
  _has_bits_[0] |= 0x00000002u;
  spilling_threshold_ = value;
  // @@protoc_insertion_point(field_set:research_scann.QuerySpillingConfig.spilling_threshold)
}

// optional uint32 max_spill_centers = 3 [default = 4294967295];
inline bool QuerySpillingConfig::has_max_spill_centers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QuerySpillingConfig::clear_max_spill_centers() {
  max_spill_centers_ = 4294967295u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 QuerySpillingConfig::max_spill_centers() const {
  // @@protoc_insertion_point(field_get:research_scann.QuerySpillingConfig.max_spill_centers)
  return max_spill_centers_;
}
inline void QuerySpillingConfig::set_max_spill_centers(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  max_spill_centers_ = value;
  // @@protoc_insertion_point(field_set:research_scann.QuerySpillingConfig.max_spill_centers)
}

// -------------------------------------------------------------------

// TreeXHybridPartitioningConfig

// optional uint32 top_partitioning_children = 1;
inline bool TreeXHybridPartitioningConfig::has_top_partitioning_children() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TreeXHybridPartitioningConfig::clear_top_partitioning_children() {
  top_partitioning_children_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TreeXHybridPartitioningConfig::top_partitioning_children() const {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.top_partitioning_children)
  return top_partitioning_children_;
}
inline void TreeXHybridPartitioningConfig::set_top_partitioning_children(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  top_partitioning_children_ = value;
  // @@protoc_insertion_point(field_set:research_scann.TreeXHybridPartitioningConfig.top_partitioning_children)
}

// optional float top_partitioner_spilling_ratio = 2 [default = 0.05];
inline bool TreeXHybridPartitioningConfig::has_top_partitioner_spilling_ratio() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TreeXHybridPartitioningConfig::clear_top_partitioner_spilling_ratio() {
  top_partitioner_spilling_ratio_ = 0.05f;
  _has_bits_[0] &= ~0x00000040u;
}
inline float TreeXHybridPartitioningConfig::top_partitioner_spilling_ratio() const {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.top_partitioner_spilling_ratio)
  return top_partitioner_spilling_ratio_;
}
inline void TreeXHybridPartitioningConfig::set_top_partitioner_spilling_ratio(float value) {
  _has_bits_[0] |= 0x00000040u;
  top_partitioner_spilling_ratio_ = value;
  // @@protoc_insertion_point(field_set:research_scann.TreeXHybridPartitioningConfig.top_partitioner_spilling_ratio)
}

// optional .research_scann.PartitioningConfig.TokenizationType top_partitioner_query_tokenization_type = 7 [default = FLOAT];
inline bool TreeXHybridPartitioningConfig::has_top_partitioner_query_tokenization_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TreeXHybridPartitioningConfig::clear_top_partitioner_query_tokenization_type() {
  top_partitioner_query_tokenization_type_ = 1;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::research_scann::PartitioningConfig_TokenizationType TreeXHybridPartitioningConfig::top_partitioner_query_tokenization_type() const {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.top_partitioner_query_tokenization_type)
  return static_cast< ::research_scann::PartitioningConfig_TokenizationType >(top_partitioner_query_tokenization_type_);
}
inline void TreeXHybridPartitioningConfig::set_top_partitioner_query_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value) {
  assert(::research_scann::PartitioningConfig_TokenizationType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  top_partitioner_query_tokenization_type_ = value;
  // @@protoc_insertion_point(field_set:research_scann.TreeXHybridPartitioningConfig.top_partitioner_query_tokenization_type)
}

// optional .research_scann.PartitioningConfig.TokenizationType top_partitioner_database_tokenization_type = 8 [default = FLOAT];
inline bool TreeXHybridPartitioningConfig::has_top_partitioner_database_tokenization_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TreeXHybridPartitioningConfig::clear_top_partitioner_database_tokenization_type() {
  top_partitioner_database_tokenization_type_ = 1;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::research_scann::PartitioningConfig_TokenizationType TreeXHybridPartitioningConfig::top_partitioner_database_tokenization_type() const {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.top_partitioner_database_tokenization_type)
  return static_cast< ::research_scann::PartitioningConfig_TokenizationType >(top_partitioner_database_tokenization_type_);
}
inline void TreeXHybridPartitioningConfig::set_top_partitioner_database_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value) {
  assert(::research_scann::PartitioningConfig_TokenizationType_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  top_partitioner_database_tokenization_type_ = value;
  // @@protoc_insertion_point(field_set:research_scann.TreeXHybridPartitioningConfig.top_partitioner_database_tokenization_type)
}

// optional .research_scann.PartitioningConfig.TokenizationType top_partitioner_training_tokenization_type = 10 [default = FLOAT];
inline bool TreeXHybridPartitioningConfig::has_top_partitioner_training_tokenization_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TreeXHybridPartitioningConfig::clear_top_partitioner_training_tokenization_type() {
  top_partitioner_training_tokenization_type_ = 1;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::research_scann::PartitioningConfig_TokenizationType TreeXHybridPartitioningConfig::top_partitioner_training_tokenization_type() const {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.top_partitioner_training_tokenization_type)
  return static_cast< ::research_scann::PartitioningConfig_TokenizationType >(top_partitioner_training_tokenization_type_);
}
inline void TreeXHybridPartitioningConfig::set_top_partitioner_training_tokenization_type(::research_scann::PartitioningConfig_TokenizationType value) {
  assert(::research_scann::PartitioningConfig_TokenizationType_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  top_partitioner_training_tokenization_type_ = value;
  // @@protoc_insertion_point(field_set:research_scann.TreeXHybridPartitioningConfig.top_partitioner_training_tokenization_type)
}

// optional bool top_partitioner_use_flume_trainer = 9 [default = false];
inline bool TreeXHybridPartitioningConfig::has_top_partitioner_use_flume_trainer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TreeXHybridPartitioningConfig::clear_top_partitioner_use_flume_trainer() {
  top_partitioner_use_flume_trainer_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool TreeXHybridPartitioningConfig::top_partitioner_use_flume_trainer() const {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.top_partitioner_use_flume_trainer)
  return top_partitioner_use_flume_trainer_;
}
inline void TreeXHybridPartitioningConfig::set_top_partitioner_use_flume_trainer(bool value) {
  _has_bits_[0] |= 0x00000020u;
  top_partitioner_use_flume_trainer_ = value;
  // @@protoc_insertion_point(field_set:research_scann.TreeXHybridPartitioningConfig.top_partitioner_use_flume_trainer)
}

// optional string assets_dir = 3;
inline bool TreeXHybridPartitioningConfig::has_assets_dir() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TreeXHybridPartitioningConfig::clear_assets_dir() {
  assets_dir_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TreeXHybridPartitioningConfig::assets_dir() const {
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.assets_dir)
  return assets_dir_.GetNoArena();
}
inline void TreeXHybridPartitioningConfig::set_assets_dir(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  assets_dir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:research_scann.TreeXHybridPartitioningConfig.assets_dir)
}
inline void TreeXHybridPartitioningConfig::set_assets_dir(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  assets_dir_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:research_scann.TreeXHybridPartitioningConfig.assets_dir)
}
inline void TreeXHybridPartitioningConfig::set_assets_dir(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  assets_dir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:research_scann.TreeXHybridPartitioningConfig.assets_dir)
}
inline void TreeXHybridPartitioningConfig::set_assets_dir(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  assets_dir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:research_scann.TreeXHybridPartitioningConfig.assets_dir)
}
inline std::string* TreeXHybridPartitioningConfig::mutable_assets_dir() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:research_scann.TreeXHybridPartitioningConfig.assets_dir)
  return assets_dir_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TreeXHybridPartitioningConfig::release_assets_dir() {
  // @@protoc_insertion_point(field_release:research_scann.TreeXHybridPartitioningConfig.assets_dir)
  if (!has_assets_dir()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return assets_dir_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TreeXHybridPartitioningConfig::set_allocated_assets_dir(std::string* assets_dir) {
  if (assets_dir != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  assets_dir_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), assets_dir);
  // @@protoc_insertion_point(field_set_allocated:research_scann.TreeXHybridPartitioningConfig.assets_dir)
}

// optional .research_scann.ExactReordering query_tokenization_reordering = 6;
inline bool TreeXHybridPartitioningConfig::has_query_tokenization_reordering() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline const ::research_scann::ExactReordering& TreeXHybridPartitioningConfig::query_tokenization_reordering() const {
  const ::research_scann::ExactReordering* p = query_tokenization_reordering_;
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.query_tokenization_reordering)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::ExactReordering*>(
      &::research_scann::_ExactReordering_default_instance_);
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::release_query_tokenization_reordering() {
  // @@protoc_insertion_point(field_release:research_scann.TreeXHybridPartitioningConfig.query_tokenization_reordering)
  _has_bits_[0] &= ~0x00000008u;
  ::research_scann::ExactReordering* temp = query_tokenization_reordering_;
  query_tokenization_reordering_ = nullptr;
  return temp;
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::mutable_query_tokenization_reordering() {
  _has_bits_[0] |= 0x00000008u;
  if (query_tokenization_reordering_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::ExactReordering>(GetArenaNoVirtual());
    query_tokenization_reordering_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.TreeXHybridPartitioningConfig.query_tokenization_reordering)
  return query_tokenization_reordering_;
}
inline void TreeXHybridPartitioningConfig::set_allocated_query_tokenization_reordering(::research_scann::ExactReordering* query_tokenization_reordering) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(query_tokenization_reordering_);
  }
  if (query_tokenization_reordering) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      query_tokenization_reordering = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_tokenization_reordering, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  query_tokenization_reordering_ = query_tokenization_reordering;
  // @@protoc_insertion_point(field_set_allocated:research_scann.TreeXHybridPartitioningConfig.query_tokenization_reordering)
}

// optional .research_scann.ExactReordering training_reordering = 4 [deprecated = true];
inline bool TreeXHybridPartitioningConfig::has_training_reordering() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::research_scann::ExactReordering& TreeXHybridPartitioningConfig::training_reordering() const {
  const ::research_scann::ExactReordering* p = training_reordering_;
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.training_reordering)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::ExactReordering*>(
      &::research_scann::_ExactReordering_default_instance_);
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::release_training_reordering() {
  // @@protoc_insertion_point(field_release:research_scann.TreeXHybridPartitioningConfig.training_reordering)
  _has_bits_[0] &= ~0x00000002u;
  ::research_scann::ExactReordering* temp = training_reordering_;
  training_reordering_ = nullptr;
  return temp;
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::mutable_training_reordering() {
  _has_bits_[0] |= 0x00000002u;
  if (training_reordering_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::ExactReordering>(GetArenaNoVirtual());
    training_reordering_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.TreeXHybridPartitioningConfig.training_reordering)
  return training_reordering_;
}
inline void TreeXHybridPartitioningConfig::set_allocated_training_reordering(::research_scann::ExactReordering* training_reordering) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(training_reordering_);
  }
  if (training_reordering) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      training_reordering = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, training_reordering, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  training_reordering_ = training_reordering;
  // @@protoc_insertion_point(field_set_allocated:research_scann.TreeXHybridPartitioningConfig.training_reordering)
}

// optional .research_scann.ExactReordering database_tokenization_reordering = 5 [deprecated = true];
inline bool TreeXHybridPartitioningConfig::has_database_tokenization_reordering() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::research_scann::ExactReordering& TreeXHybridPartitioningConfig::database_tokenization_reordering() const {
  const ::research_scann::ExactReordering* p = database_tokenization_reordering_;
  // @@protoc_insertion_point(field_get:research_scann.TreeXHybridPartitioningConfig.database_tokenization_reordering)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::ExactReordering*>(
      &::research_scann::_ExactReordering_default_instance_);
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::release_database_tokenization_reordering() {
  // @@protoc_insertion_point(field_release:research_scann.TreeXHybridPartitioningConfig.database_tokenization_reordering)
  _has_bits_[0] &= ~0x00000004u;
  ::research_scann::ExactReordering* temp = database_tokenization_reordering_;
  database_tokenization_reordering_ = nullptr;
  return temp;
}
inline ::research_scann::ExactReordering* TreeXHybridPartitioningConfig::mutable_database_tokenization_reordering() {
  _has_bits_[0] |= 0x00000004u;
  if (database_tokenization_reordering_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::ExactReordering>(GetArenaNoVirtual());
    database_tokenization_reordering_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.TreeXHybridPartitioningConfig.database_tokenization_reordering)
  return database_tokenization_reordering_;
}
inline void TreeXHybridPartitioningConfig::set_allocated_database_tokenization_reordering(::research_scann::ExactReordering* database_tokenization_reordering) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_tokenization_reordering_);
  }
  if (database_tokenization_reordering) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      database_tokenization_reordering = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_tokenization_reordering, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  database_tokenization_reordering_ = database_tokenization_reordering;
  // @@protoc_insertion_point(field_set_allocated:research_scann.TreeXHybridPartitioningConfig.database_tokenization_reordering)
}

// -------------------------------------------------------------------

// TokenList

// optional uint64 id = 1;
inline bool TokenList::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TokenList::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TokenList::id() const {
  // @@protoc_insertion_point(field_get:research_scann.TokenList.id)
  return id_;
}
inline void TokenList::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
  // @@protoc_insertion_point(field_set:research_scann.TokenList.id)
}

// repeated int64 datapoint_index = 2;
inline int TokenList::datapoint_index_size() const {
  return datapoint_index_.size();
}
inline void TokenList::clear_datapoint_index() {
  datapoint_index_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TokenList::datapoint_index(int index) const {
  // @@protoc_insertion_point(field_get:research_scann.TokenList.datapoint_index)
  return datapoint_index_.Get(index);
}
inline void TokenList::set_datapoint_index(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  datapoint_index_.Set(index, value);
  // @@protoc_insertion_point(field_set:research_scann.TokenList.datapoint_index)
}
inline void TokenList::add_datapoint_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  datapoint_index_.Add(value);
  // @@protoc_insertion_point(field_add:research_scann.TokenList.datapoint_index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
TokenList::datapoint_index() const {
  // @@protoc_insertion_point(field_list:research_scann.TokenList.datapoint_index)
  return datapoint_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
TokenList::mutable_datapoint_index() {
  // @@protoc_insertion_point(field_mutable_list:research_scann.TokenList.datapoint_index)
  return &datapoint_index_;
}

// -------------------------------------------------------------------

// HierarchicalPartitionerConfig

// optional .research_scann.InputOutputConfig input_output = 1;
inline bool HierarchicalPartitionerConfig::has_input_output() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::research_scann::InputOutputConfig& HierarchicalPartitionerConfig::input_output() const {
  const ::research_scann::InputOutputConfig* p = input_output_;
  // @@protoc_insertion_point(field_get:research_scann.HierarchicalPartitionerConfig.input_output)
  return p != nullptr ? *p : *reinterpret_cast<const ::research_scann::InputOutputConfig*>(
      &::research_scann::_InputOutputConfig_default_instance_);
}
inline ::research_scann::InputOutputConfig* HierarchicalPartitionerConfig::release_input_output() {
  // @@protoc_insertion_point(field_release:research_scann.HierarchicalPartitionerConfig.input_output)
  _has_bits_[0] &= ~0x00000001u;
  ::research_scann::InputOutputConfig* temp = input_output_;
  input_output_ = nullptr;
  return temp;
}
inline ::research_scann::InputOutputConfig* HierarchicalPartitionerConfig::mutable_input_output() {
  _has_bits_[0] |= 0x00000001u;
  if (input_output_ == nullptr) {
    auto* p = CreateMaybeMessage<::research_scann::InputOutputConfig>(GetArenaNoVirtual());
    input_output_ = p;
  }
  // @@protoc_insertion_point(field_mutable:research_scann.HierarchicalPartitionerConfig.input_output)
  return input_output_;
}
inline void HierarchicalPartitionerConfig::set_allocated_input_output(::research_scann::InputOutputConfig* input_output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(input_output_);
  }
  if (input_output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      input_output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_output, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  input_output_ = input_output;
  // @@protoc_insertion_point(field_set_allocated:research_scann.HierarchicalPartitionerConfig.input_output)
}

// repeated .research_scann.PartitioningConfig partitioning = 2;
inline int HierarchicalPartitionerConfig::partitioning_size() const {
  return partitioning_.size();
}
inline void HierarchicalPartitionerConfig::clear_partitioning() {
  partitioning_.Clear();
}
inline ::research_scann::PartitioningConfig* HierarchicalPartitionerConfig::mutable_partitioning(int index) {
  // @@protoc_insertion_point(field_mutable:research_scann.HierarchicalPartitionerConfig.partitioning)
  return partitioning_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::research_scann::PartitioningConfig >*
HierarchicalPartitionerConfig::mutable_partitioning() {
  // @@protoc_insertion_point(field_mutable_list:research_scann.HierarchicalPartitionerConfig.partitioning)
  return &partitioning_;
}
inline const ::research_scann::PartitioningConfig& HierarchicalPartitionerConfig::partitioning(int index) const {
  // @@protoc_insertion_point(field_get:research_scann.HierarchicalPartitionerConfig.partitioning)
  return partitioning_.Get(index);
}
inline ::research_scann::PartitioningConfig* HierarchicalPartitionerConfig::add_partitioning() {
  // @@protoc_insertion_point(field_add:research_scann.HierarchicalPartitionerConfig.partitioning)
  return partitioning_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::research_scann::PartitioningConfig >&
HierarchicalPartitionerConfig::partitioning() const {
  // @@protoc_insertion_point(field_list:research_scann.HierarchicalPartitionerConfig.partitioning)
  return partitioning_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace research_scann

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::research_scann::PartitioningConfig_TreeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::PartitioningConfig_TreeType>() {
  return ::research_scann::PartitioningConfig_TreeType_descriptor();
}
template <> struct is_proto_enum< ::research_scann::PartitioningConfig_TokenizationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::PartitioningConfig_TokenizationType>() {
  return ::research_scann::PartitioningConfig_TokenizationType_descriptor();
}
template <> struct is_proto_enum< ::research_scann::PartitioningConfig_PartitioningType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::PartitioningConfig_PartitioningType>() {
  return ::research_scann::PartitioningConfig_PartitioningType_descriptor();
}
template <> struct is_proto_enum< ::research_scann::PartitioningConfig_BalancingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::PartitioningConfig_BalancingType>() {
  return ::research_scann::PartitioningConfig_BalancingType_descriptor();
}
template <> struct is_proto_enum< ::research_scann::PartitioningConfig_SingleMachineCenterInitializationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::PartitioningConfig_SingleMachineCenterInitializationType>() {
  return ::research_scann::PartitioningConfig_SingleMachineCenterInitializationType_descriptor();
}
template <> struct is_proto_enum< ::research_scann::PartitioningConfig_PartitionerTrainerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::PartitioningConfig_PartitionerTrainerType>() {
  return ::research_scann::PartitioningConfig_PartitionerTrainerType_descriptor();
}
template <> struct is_proto_enum< ::research_scann::DatabaseSpillingConfig_SpillingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::DatabaseSpillingConfig_SpillingType>() {
  return ::research_scann::DatabaseSpillingConfig_SpillingType_descriptor();
}
template <> struct is_proto_enum< ::research_scann::QuerySpillingConfig_SpillingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::research_scann::QuerySpillingConfig_SpillingType>() {
  return ::research_scann::QuerySpillingConfig_SpillingType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_scann_2fproto_2fpartitioning_2eproto
